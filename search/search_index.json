{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"libROM is a free , lightweight , scalable C++ library for data-driven physical simulation methods. It is the main tool box that the reduced order modeling team at LLNL uses to develop efficient model order reduction techniques and physics-constrained data-driven methods . We try to collect any useful reduced order model routines, which are separable to the high-fidelity physics solvers, into libROM. Plus, libROM is open source, so anyone is welcome to suggest new ideas or contribute to the development. Let's work together for better data-driven technology! Features Proper Orthogonal Decomposition Dynamic mode decomposition Projection-based reduced order models Hyper-reduction Greedy algorithm Many more features will be available soon. Stay tuned! libROM is used in many projects, including BLAST , ARDRA , Laghos , and SU2 . Many MFEM -based ROM examples can be found in Examples . See also our Gallery , Publications and News pages. News Date Message Nov 19, 2021 NM-ROM paper is published in JCP. Free download is available for 50 days. Nov 10, 2021 Laghos ROM is published at CMAME. Free download is available for 50 days. Oct 1, 2021 Domain decomposition ROM paper is published at CMAME Sep 27, 2021 First version of libROM webpage is launched July 19, 2021 Space time ROM-Python paper is published in Mathematics libROM tutorials in YouTube Date Title July 22, 2021 Poisson equation & its finite element discretization Sep. 1, 2021 Poisson equation & its reduced order model Sep. 23, 2021 Physics-informed sampling procedure for reduced order models Latest Release Examples \u250a Code documentation \u250a Sources Download libROM-master.zip Documentation Building libROM \u250a Poisson equation \u250a Greedy for Poisson New users should start by examining the example codes and tutorials . We also recommend using GLVis or VisIt for visualization. Contact Use the GitHub issue tracker to report bugs or post questions or comments . See the About page for citation information.","title":"Home"},{"location":"index.html#features","text":"Proper Orthogonal Decomposition Dynamic mode decomposition Projection-based reduced order models Hyper-reduction Greedy algorithm Many more features will be available soon. Stay tuned! libROM is used in many projects, including BLAST , ARDRA , Laghos , and SU2 . Many MFEM -based ROM examples can be found in Examples . See also our Gallery , Publications and News pages.","title":"Features"},{"location":"index.html#news","text":"Date Message Nov 19, 2021 NM-ROM paper is published in JCP. Free download is available for 50 days. Nov 10, 2021 Laghos ROM is published at CMAME. Free download is available for 50 days. Oct 1, 2021 Domain decomposition ROM paper is published at CMAME Sep 27, 2021 First version of libROM webpage is launched July 19, 2021 Space time ROM-Python paper is published in Mathematics","title":"News"},{"location":"index.html#librom-tutorials-in-youtube","text":"Date Title July 22, 2021 Poisson equation & its finite element discretization Sep. 1, 2021 Poisson equation & its reduced order model Sep. 23, 2021 Physics-informed sampling procedure for reduced order models","title":"libROM tutorials in YouTube"},{"location":"index.html#latest-release","text":"Examples \u250a Code documentation \u250a Sources Download libROM-master.zip","title":"Latest Release"},{"location":"index.html#documentation","text":"Building libROM \u250a Poisson equation \u250a Greedy for Poisson New users should start by examining the example codes and tutorials . We also recommend using GLVis or VisIt for visualization.","title":"Documentation"},{"location":"index.html#contact","text":"Use the GitHub issue tracker to report bugs or post questions or comments . See the About page for citation information.","title":"Contact"},{"location":"about.html","text":"About libROM Please cite with: @misc{ doecode_24508, title = {libROM}, author = {Choi, Youngsoo and Arrighi, William J. and Copeland, Dylan M. and Anderson, Robert W. and Oxberry, Geoffrey M.}, abstractNote = {libROM is a collection of C++ classes that compute reduced order models and hyperreduced order models for systems of ordinary differential equations. libROM includes parallel, adaptive methods for proper orthogonal decomposition, and parallel, non-adaptive methods for hyperreduction using the discrete empirical interpolation method.}, doi = {10.11578/dc.20190408.3}, url = {https://doi.org/10.11578/dc.20190408.3}, howpublished = {[Computer Software] \\url{https://doi.org/10.11578/dc.20190408.3}}, year = {2019}, month = {oct} } Contributors Bob Anderson Siu Wun Cheung Youngsoo Choi Dylan Copeland Kevin Huynh Jessica Lauzon Sean McBane Geoffrey Oxberry License MIT license Apache license This work performed under the auspices of the U.S. Department of Energy by Lawrence Livermore Laboratory under Contract DE-AC52-07NA27344. Software release number: LLNL-CODE-766763. DOI: 10.11578/dc.20190408.3 . Disclaimer This document was prepared as an account of work sponsored by an agency of the United States government. Neither the United States government nor Lawrence Livermore National Security, LLC, nor any of their employees makes any warranty, expressed or implied, or assumes any legal liability or responsibility for the accuracy, completeness, or usefulness of any information, apparatus, product, or process disclosed, or represents that its use would not infringe privately owned rights. Reference herein to any specific commercial product, process, or service by trade name, trademark, manufacturer, or otherwise does not necessarily constitute or imply its endorsement, recommendation, or favoring by the United States government or Lawrence Livermore National Security, LLC. The views and opinions of authors expressed herein do not necessarily state or reflect those of the United States government or Lawrence Livermore National Security, LLC, and shall not be used for advertising or product endorsement purposes. Website built with MkDocs , Bootstrap and Bootswatch . Hosted on GitHub .","title":"About"},{"location":"about.html#about-librom","text":"Please cite with: @misc{ doecode_24508, title = {libROM}, author = {Choi, Youngsoo and Arrighi, William J. and Copeland, Dylan M. and Anderson, Robert W. and Oxberry, Geoffrey M.}, abstractNote = {libROM is a collection of C++ classes that compute reduced order models and hyperreduced order models for systems of ordinary differential equations. libROM includes parallel, adaptive methods for proper orthogonal decomposition, and parallel, non-adaptive methods for hyperreduction using the discrete empirical interpolation method.}, doi = {10.11578/dc.20190408.3}, url = {https://doi.org/10.11578/dc.20190408.3}, howpublished = {[Computer Software] \\url{https://doi.org/10.11578/dc.20190408.3}}, year = {2019}, month = {oct} }","title":"About libROM"},{"location":"about.html#contributors","text":"Bob Anderson Siu Wun Cheung Youngsoo Choi Dylan Copeland Kevin Huynh Jessica Lauzon Sean McBane Geoffrey Oxberry","title":"Contributors"},{"location":"about.html#license","text":"MIT license Apache license This work performed under the auspices of the U.S. Department of Energy by Lawrence Livermore Laboratory under Contract DE-AC52-07NA27344. Software release number: LLNL-CODE-766763. DOI: 10.11578/dc.20190408.3 .","title":"License"},{"location":"about.html#disclaimer","text":"This document was prepared as an account of work sponsored by an agency of the United States government. Neither the United States government nor Lawrence Livermore National Security, LLC, nor any of their employees makes any warranty, expressed or implied, or assumes any legal liability or responsibility for the accuracy, completeness, or usefulness of any information, apparatus, product, or process disclosed, or represents that its use would not infringe privately owned rights. Reference herein to any specific commercial product, process, or service by trade name, trademark, manufacturer, or otherwise does not necessarily constitute or imply its endorsement, recommendation, or favoring by the United States government or Lawrence Livermore National Security, LLC. The views and opinions of authors expressed herein do not necessarily state or reflect those of the United States government or Lawrence Livermore National Security, LLC, and shall not be used for advertising or product endorsement purposes. Website built with MkDocs , Bootstrap and Bootswatch . Hosted on GitHub .","title":"Disclaimer"},{"location":"building.html","text":"Building libROM A simple tutorial on how to build and run libROM. For more details, see the README file. In addition to the native build system described below, libROM packages are also available in Spack: Spack Instructions Clone libROM https://github.com/LLNL/libROM Installation To compile libROM with default build settings (Mac and LLNL LC Machines): ./scripts/compile.sh To compile libROM for Ardra (LLNL LC Machines only): ./scripts/ardra_compile.sh To compile libROM using a different toolchain within cmake/toolchains (Mac and LLNL LC Machines): ./scripts/toolchain_compile.sh toolchain.cmake Compilation options: -a: Compile a special build for the LLNL codebase: Ardra -d: Compile in debug mode. -m: Compile with MFEM (required to run the libROM examples) -t: Use your own cmake/toolchain -u: Update all of libROM's dependencies.","title":"Building libROM"},{"location":"building.html#building-librom","text":"A simple tutorial on how to build and run libROM. For more details, see the README file. In addition to the native build system described below, libROM packages are also available in Spack: Spack","title":"Building libROM"},{"location":"building.html#instructions","text":"Clone libROM https://github.com/LLNL/libROM","title":"Instructions"},{"location":"building.html#installation","text":"To compile libROM with default build settings (Mac and LLNL LC Machines): ./scripts/compile.sh To compile libROM for Ardra (LLNL LC Machines only): ./scripts/ardra_compile.sh To compile libROM using a different toolchain within cmake/toolchains (Mac and LLNL LC Machines): ./scripts/toolchain_compile.sh toolchain.cmake Compilation options: -a: Compile a special build for the LLNL codebase: Ardra -d: Compile in debug mode. -m: Compile with MFEM (required to run the libROM examples) -t: Use your own cmake/toolchain -u: Update all of libROM's dependencies.","title":"Installation"},{"location":"ddps.html","text":"MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}}); DDPS Webinar ( in California time ) DDPS stands for data-driven physical simulation. We hold weekly webinar, in average, either on Thursday or Friday at Lawrence Livermore National Laboratory. If you are interested in giving a webinar talk or would like to recommend a speaker, please send an email to choi15@llnl.gov. Scheduled Talks, 2022 When Speaker Institution Title WebEx Jan. 6, 10 AM Miles Cranmer Princeton University TBD link Jan. 14, 10 AM Greg Beroza Stanford University Towards Complete Machine-Learning-Based Earthquake Monitoring Workflows link Jan. 20, 10 AM Pat Langley Stanford University TBD link Feb. 4, 10 AM Serkan Gugercin Virginia Tech TBD link Mar. 25, 4 PM Weinan E Princeton University TBD link Apr. 1, 10 AM Laure Zanna New York University TBD link Past Talks in 2021 Date Speaker Institution Title YouTube Dec. 3rd Igor Mezic UC Santa Barbara Koopman operator theory for dynamical systems, control and data analytics link Nov. 18th Michael Mahoney UC Berkeley Toward combining principled scientific models and principled machine learning models link Nov. 12th WaiChing Sun Columbia University Data-driven constitutive updates: from model-free poroelasticity to level set plasticity trained by neural networks link Nov. 4th Misha Khodak CMU Towards automatic architecture design for emerging machine learning tasks link Oct. 28th Masayuki Yano U. of Toronto Towards reliable, efficient, and automated model reduction of parametrized nonlinear PDEs: error estimation, adaptivity, and application to aerodynamics link Oct. 7th Youngsoo Choi LLNL libROM: Library for physics-constrained data-driven physical simulations link Sep. 30th Peter Benner Max Planck Identification of Nonlinear Dynamical Systems from Noisy Measurements link Sep. 2nd Ionut-Gabriel Farcas Oden Institute Learning hierarchies of reduced-dimension and context-aware low-fidelity models for multi-fidelity Monte Carlo sampling link Aug. 26th Jesse Capecelatro U. of Michagan Turbulent disperse two-phase flows: simulations and data-driven modeling link Aug. 19th Christopher J. Earls Cornell U. Gaining mechanistic insight through learning Green's functions: Uncovering the solutions to hidden PDEs link Aug. 13, 10 AM Dmitriy Anistratov North Carolina State U. Reduced order models for thermal radiative transfer problems based on moment equations and POD/DMD of Eddington tensor link Aug. 5th Luca Magri Imperial College, London Physics-aware reservoir-computing for turbulence and chaotic learning NA Jul. 30th Marta D'Elia Sandia Data-driven learning of nonlocal models: bridging scales and design of new neural networks link Jul. 22nd Hannah Lu Stanford U. Dynamic model decomposition for reduced order modeling in flow and transport problems NA Jul. 15th Yeonjong Shin Brown U. Towards a mathematical understanding of modern machine learning: theory, algorithms, and applications link Jul. 9th Rui Wang UC, San Diego Physics-guided deep learning for dynamics for forecasting link Jul. 1st Tan Bui UT, Austin Model-constrained deep learning approaches for inference, control, and uncertainty quantification link Jun. 24th Matthew Zahr U. of Notre Dame Model reduction of convection-dominated partial differential equations via optimization-based implicit feature tracking link Jun. 10th David Ryckelynck Mines ParisTech Model order reduction assisted by deep neural networks (ROM-net) link Jun. 3rd Harbir Antil George Mason U. Applications of Fractional Operators from Optimal Control to Machine Learning link May 27th Romit Maulik Argonne Neural architecture search for surrogate modeling link May 20th Tobias Pfaff, Alvaro Sanchez-Gonzalez DeepMind Learning physical simulation with Graph Network link May 14th George Karniadakis Brown U. Approximating functions, functionals, and operators using deep neural networks for diverse applications link Apr. 29th Traian Iliescu Virginia Tech. Large Eddy Simulation Reduced Order Models (LES-ROMs) link Apr. 15th Tommaso Taddei Inria Registration-based model reduction of parameterized advection-dominated PDEs link Apr. 7th Francisco Chinesta ENSAM ParisTech Empowering Hybrid Twins from Physics-Informed Artificial Intelligence link Apr. 1st Priya Donti Carnegie Mellon U. Incorporating power system physics into deep learning via implicit layers link Mar. 25th Mario Ohlberger U. Munster Model reduction with adaptive enrichment for large scale PDE-constrained optimization link Mar. 18th Karthik Duraisamy U. of Michigan Towards Robust, Accurate and Tractable Reduced Order Models for Multi-scale, Multi-physics Problems link Mar. 10th Pawan Goyal Max Planck Physics-informed learning for nonlinear dynamical systems: a deep learning approach to operator inference link Feb. 18th Nils Thuerey Technische Universitat Munchen Differentiable Physics Simulations for Deep Learning link Jan. 27th Alfio Quarteroni EPFL The mathematical heart: a computational model for the simulation of the heart function link Jan. 21th Steven Brunton U. of Washington Interpretable and Generalizable Machine Learning for Fluid Mechanics link Jan. 7th Irina Tezaur Sandia The Schwarz alternating methods as a means for concurrent multiscale coupling in solid mechanics link Past Talks in 2020 Date Speaker Institution Title YouTube Dec. 17th Jan Hesthaven EPFL Non-intrusive reduced order models using physics informed neural networks link Dec. 10th Jesse Chan Rice U. Entropy stable schemes for nonlinear conservation laws: high order discontinuous Galerkin methods and reduced order modeling link Nov. 18th Paris Perdikaris UPenn When and why physics-informed neural networks fail to train: A neural tangent kernel perspective link Nov. 12th Donsub Rim Courant Institute Distilling nonlinear shock waves: Nonlinear model reduction for transport dominated problems using deep neural networks link Oct. 29th Byungsoo Kim ETH Zurich Data-Driven Methods for Fluid Simulations in Computer Graphics link","title":"DDPS"},{"location":"ddps.html#ddps-webinar-in-california-time","text":"DDPS stands for data-driven physical simulation. We hold weekly webinar, in average, either on Thursday or Friday at Lawrence Livermore National Laboratory. If you are interested in giving a webinar talk or would like to recommend a speaker, please send an email to choi15@llnl.gov.","title":"DDPS Webinar (in California time)"},{"location":"ddps.html#scheduled-talks-2022","text":"When Speaker Institution Title WebEx Jan. 6, 10 AM Miles Cranmer Princeton University TBD link Jan. 14, 10 AM Greg Beroza Stanford University Towards Complete Machine-Learning-Based Earthquake Monitoring Workflows link Jan. 20, 10 AM Pat Langley Stanford University TBD link Feb. 4, 10 AM Serkan Gugercin Virginia Tech TBD link Mar. 25, 4 PM Weinan E Princeton University TBD link Apr. 1, 10 AM Laure Zanna New York University TBD link","title":"Scheduled Talks, 2022"},{"location":"ddps.html#past-talks-in-2021","text":"Date Speaker Institution Title YouTube Dec. 3rd Igor Mezic UC Santa Barbara Koopman operator theory for dynamical systems, control and data analytics link Nov. 18th Michael Mahoney UC Berkeley Toward combining principled scientific models and principled machine learning models link Nov. 12th WaiChing Sun Columbia University Data-driven constitutive updates: from model-free poroelasticity to level set plasticity trained by neural networks link Nov. 4th Misha Khodak CMU Towards automatic architecture design for emerging machine learning tasks link Oct. 28th Masayuki Yano U. of Toronto Towards reliable, efficient, and automated model reduction of parametrized nonlinear PDEs: error estimation, adaptivity, and application to aerodynamics link Oct. 7th Youngsoo Choi LLNL libROM: Library for physics-constrained data-driven physical simulations link Sep. 30th Peter Benner Max Planck Identification of Nonlinear Dynamical Systems from Noisy Measurements link Sep. 2nd Ionut-Gabriel Farcas Oden Institute Learning hierarchies of reduced-dimension and context-aware low-fidelity models for multi-fidelity Monte Carlo sampling link Aug. 26th Jesse Capecelatro U. of Michagan Turbulent disperse two-phase flows: simulations and data-driven modeling link Aug. 19th Christopher J. Earls Cornell U. Gaining mechanistic insight through learning Green's functions: Uncovering the solutions to hidden PDEs link Aug. 13, 10 AM Dmitriy Anistratov North Carolina State U. Reduced order models for thermal radiative transfer problems based on moment equations and POD/DMD of Eddington tensor link Aug. 5th Luca Magri Imperial College, London Physics-aware reservoir-computing for turbulence and chaotic learning NA Jul. 30th Marta D'Elia Sandia Data-driven learning of nonlocal models: bridging scales and design of new neural networks link Jul. 22nd Hannah Lu Stanford U. Dynamic model decomposition for reduced order modeling in flow and transport problems NA Jul. 15th Yeonjong Shin Brown U. Towards a mathematical understanding of modern machine learning: theory, algorithms, and applications link Jul. 9th Rui Wang UC, San Diego Physics-guided deep learning for dynamics for forecasting link Jul. 1st Tan Bui UT, Austin Model-constrained deep learning approaches for inference, control, and uncertainty quantification link Jun. 24th Matthew Zahr U. of Notre Dame Model reduction of convection-dominated partial differential equations via optimization-based implicit feature tracking link Jun. 10th David Ryckelynck Mines ParisTech Model order reduction assisted by deep neural networks (ROM-net) link Jun. 3rd Harbir Antil George Mason U. Applications of Fractional Operators from Optimal Control to Machine Learning link May 27th Romit Maulik Argonne Neural architecture search for surrogate modeling link May 20th Tobias Pfaff, Alvaro Sanchez-Gonzalez DeepMind Learning physical simulation with Graph Network link May 14th George Karniadakis Brown U. Approximating functions, functionals, and operators using deep neural networks for diverse applications link Apr. 29th Traian Iliescu Virginia Tech. Large Eddy Simulation Reduced Order Models (LES-ROMs) link Apr. 15th Tommaso Taddei Inria Registration-based model reduction of parameterized advection-dominated PDEs link Apr. 7th Francisco Chinesta ENSAM ParisTech Empowering Hybrid Twins from Physics-Informed Artificial Intelligence link Apr. 1st Priya Donti Carnegie Mellon U. Incorporating power system physics into deep learning via implicit layers link Mar. 25th Mario Ohlberger U. Munster Model reduction with adaptive enrichment for large scale PDE-constrained optimization link Mar. 18th Karthik Duraisamy U. of Michigan Towards Robust, Accurate and Tractable Reduced Order Models for Multi-scale, Multi-physics Problems link Mar. 10th Pawan Goyal Max Planck Physics-informed learning for nonlinear dynamical systems: a deep learning approach to operator inference link Feb. 18th Nils Thuerey Technische Universitat Munchen Differentiable Physics Simulations for Deep Learning link Jan. 27th Alfio Quarteroni EPFL The mathematical heart: a computational model for the simulation of the heart function link Jan. 21th Steven Brunton U. of Washington Interpretable and Generalizable Machine Learning for Fluid Mechanics link Jan. 7th Irina Tezaur Sandia The Schwarz alternating methods as a means for concurrent multiscale coupling in solid mechanics link","title":"Past Talks in 2021"},{"location":"ddps.html#past-talks-in-2020","text":"Date Speaker Institution Title YouTube Dec. 17th Jan Hesthaven EPFL Non-intrusive reduced order models using physics informed neural networks link Dec. 10th Jesse Chan Rice U. Entropy stable schemes for nonlinear conservation laws: high order discontinuous Galerkin methods and reduced order modeling link Nov. 18th Paris Perdikaris UPenn When and why physics-informed neural networks fail to train: A neural tangent kernel perspective link Nov. 12th Donsub Rim Courant Institute Distilling nonlinear shock waves: Nonlinear model reduction for transport dominated problems using deep neural networks link Oct. 29th Byungsoo Kim ETH Zurich Data-Driven Methods for Fluid Simulations in Computer Graphics link","title":"Past Talks in 2020"},{"location":"download.html","text":"Latest Release Code documentation \u250a Sources Download libROM-master.zip Please use the GitHub issue tracker to report bugs or post questions or comments . All Releases Filename Version Release Date Size CLOC Notes libROM-master.zip v1.0 Sep 2021 160K 22K initial release","title":"Download"},{"location":"download.html#latest-release","text":"Code documentation \u250a Sources Download libROM-master.zip Please use the GitHub issue tracker to report bugs or post questions or comments .","title":"Latest Release"},{"location":"download.html#all-releases","text":"Filename Version Release Date Size CLOC Notes libROM-master.zip v1.0 Sep 2021 160K 22K initial release","title":"All Releases"},{"location":"examples.html","text":"MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}}); Example Applications This page provides a list of libROM example applications. For detailed documentation of the libROM sources, including the examples, see the online Doxygen documentation or the doc directory in the distribution. The goal of the example codes is to provide a step-by-step introduction to libROM in simple model settings. Select from the categories below to display examples and miniapps that contain the respective feature. All examples support (arbitrarily) high-order meshes and finite element spaces . The numerical results from the example codes can be visualized using the GLVis or VisIt visualization tools. See the GLVis and VisIt websites for more details. Users are encouraged to submit any example codes and miniapps that they have created and would like to share. Contact a member of the libROM team to report bugs or post questions or comments . **Application (PDE)** All Diffusion Elasticity Euler Advection Compressible flow **Reduced order models type** All pROM DMD **Parameterization type** All Trust region Interpolation Global Reproductive **hyper-reduction** All Hyper-reduction No hyper-reduction Poisson Problem This example code demonstrates the use of libROM and MFEM to define a reduced order model for a simple isoparametric finite element discretization of the Poisson problem $$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. The example parameterizes the righthand side with frequency variable, $\\kappa$: $$f = \\cases{ \\displaystyle \\sin(\\kappa (x_0+x_1+x_2)) & for 3D \\cr \\displaystyle \\sin(\\kappa (x_0+x_1)) & for 2D }$$ The 2D solution contour plot for $\\kappa=1$ is shown in the figure on the right to show the effect of $\\kappa$. For demonstration, we sample solutions at $\\kappa=1$, $1.1$, and $1.2$. Then a ROM is build with basis size of 3, which is used to predict the solution for $\\kappa = 1.15$. The ROM is able to achieve a speedup of $7.5$ with a relative error of $6.4\\times10^{-4}$. One can follow the command line options below to reproduce the numerical results summarized in the table below: offline1 : poisson -offline -f 1.0 -id 0 offline2 : poisson -offline -f 1.1 -id 1 offline3 : poisson -offline -f 1.2 -id 2 merge : poisson -merge -ns 3 online : poisson -online -f 1.15 FOM solution time ROM solution time Speed-up Solution relative error 0.22 sec 0.029 sec 7.5 6.4e-4 The code that generates the numerical results above can be found in ( poisson.cpp ) and the explanation of codes is provided in here . The poisson.cpp is based on ex1p.cpp from MFEM with a modification on the right hand side function. Advection For a given initial condition, i.e., $u_0(x) = u(0,x)$, DG advection solves the time-dependent advection problem: $$\\frac{\\partial u}{\\partial t} + v\\cdot\\nabla u = 0,$$ where $v$ is a given advection velocity. One can run the following command line options to reproduce the DMD results summarized in the table below: dg_advection -p 3 -rp 1 -dt 0.005 -tf 4 -visit FOM solution time DMD setup time DMD query time DMD relative error 5.2 sec 30.6 sec 1.9e-2 sec 1.9e-4 The code that generates the numerical results above can be found in ( dg_advection.cpp ). The dg_advection.cpp is based on ex9p.cpp from MFEM. Euler equation For a given initial condition, i.e., $u_0(x) = u(0,x)$, DG Euler solves the compressible Euler system of equation, i.e., a model nonlinear hyperbolic PDE: $$\\frac{\\partial u}{\\partial t} + \\nabla\\cdot \\boldsymbol{F}(u) = 0,$$ with a state vector $\\boldsymbol{u} = [\\rho,\\rho v_0, \\rho v_1, \\rho E]$, where $\\rho$ is the density, $v_i$ is the velocity in the $i$th direction, $E$ is the total specific energy, and $H = E + p/\\rho$ is the total specific enthalpy. The pressure, $p$ is computed through a simple equation of state (EOS) call. The conservative hydrodynamic flux $\\boldsymbol{F}$ in each direction $i$ is $$\\boldsymbol{F}_i = [\\rho v_i, \\rho v_0 v_i + p \\delta_{i,0}, \\rho v_1 v_{i,1} + p\\delta_{i,1}, \\rho v_i H]$$ One can run the following command line options to reproduce the DMD results summarized in the table below: mpirun -n 8 ./dg_euler -p 2 -rs 2 -rp 1 -o 1 -s 3 -visit DMD rel.error FOM solution time DMD setup time DMD query time $\\rho$ $\\rho v_0$ $\\rho v_1$ $E$ 5.65 sec 38.9 sec 1.4e-3 sec 8.0e-7 1.2e-4 1.6e-3 2.6e-6 The code that generates the numerical results above can be found in ( dg_euler.cpp ). The dg_euler.cpp is based on ex18p.cpp from MFEM. Heat conduction problem For a given initial condition, i.e., $u_0(x) = u(0,x)$, heat conduction solves a simple 2D/3D time dependent nonlinear heat conduction problem $$\\frac{\\partial u}{\\partial t} = \\nabla\\cdot (\\kappa + \\alpha u)\\nabla u,$$ with a natural insulating boundary condition $\\frac{du}{dn}=0$. We linearize the problem by using the temperature field $u$ from the previous time step to compute the conductivity coefficient. One can run the following command line options to reproduce the DMD results summarized in the table below: mpirun -np 8 ./heat_conduction -s 3 -a 0.5 -k 0.5 -o 4 -tf 0.7 -vs 1 -visit FOM solution time DMD setup time DMD query time DMD relative error 4.8 sec 0.34 sec 1.4e-3 sec 8.2e-4 The code that generates the numerical results above can be found in ( heat_conduction.cpp ). The heat_conduction.cpp is based on ex16p.cpp from MFEM. Mixed nonlinear diffusion For a given initial condition, i.e., $p_0(x) = p(0,x)$, mixed nonlinear diffusion problem solves a simple 2D/3D time dependent nonlinear problem: $$\\frac{\\partial p}{\\partial t} + \\nabla\\cdot \\boldsymbol{v} = f\\,, \\qquad \\nabla p = -a(p)\\boldsymbol{v},$$ with a natural insulating boundary condition $\\frac{\\partial v}{\\partial n}=0$. The $H(div)$-conforming Raviart-Thomas finite element space is used for the velocity function $\\boldsymbol{v}$, and the $L^2$ finite element space is used for pressure function, $p$. This example introduces how the hyper-reduction is implemented and how the reduced bases for two field varibles, $p$ and $\\boldsymbol{v}$. One can run the following command line options to reproduce the DMD results summarized in the table below: offline1 : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -offline -id 0 -sh 0.25 offline2 : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -offline -id 1 -sh 0.15 merge : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -merge -ns 2 offline3 : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -offline -id 2 -sh 0.2 online : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -online -rrdim 8 -rwdim 8 -sh 0.2 -id 2 FOM solution time ROM solution time Speed-up Solution relative error 41.68 sec 1.7 sec 24.5 1.6e-3 The code that generates the numerical results above can be found in ( mixed_nonlinear_diffusion.cpp ). The mixed_nonlinear_diffusion.cpp is based on ex16p.cpp from MFEM and modified to support mixed finite element approach. Nonlinear elasticity For a given initial condition, i.e., $v_0(x) = v(0,x)$, nonlinear elasticity solves a time dependent nonlinear elasticity problem of the form $$\\frac{\\partial v}{\\partial t} = H(x) + Sv\\,, \\qquad \\frac{\\partial x}{\\partial t} = v,$$ where $H$ is a hyperelastic model and $S$ is a viscosity operator of Laplacian type. One can run the following command line options to reproduce the DMD results summarized in the table below: mpirun -np 8 ./nonlinear_elasticity -s 2 -rs 1 -dt 0.01 -tf 5 -visit FOM solution time DMD setup time DMD query time Position relative error Velocity relative error 3.7 sec 4.7e-1 sec 6.9e-4 sec 7.0e-5 1.4e-3 The code that generates the numerical results above can be found in ( nonlinear_elasticity.cpp ). The nonlinear_elasticity.cpp is based on ex10p.cpp from MFEM. Laghos ROM Miniapp Laghos (LAGrangian High-Order Solver) is a miniapp that solves the time-dependent Euler equations of compressible gas dynamics in a moving Lagrangian frame using unstructured high-order finite element spatial discretization and explicit high-order time-stepping. LaghosROM introduces reduced order models of Laghos simulations. A list of example problems that you can solve with LaghosROM includes Sedov blast, Gresho vortex, Taylor-Green vortex, triple-point, and Rayleigh-Taylor instability problems. Below are command line options for each problems and some numerical results. For each problem, four different phases need to be taken, i.e., the offline, hyper-reduction preprocessing, online, and restore phase. The online phase runs necessary full order model (FOM) to generate simulation data. libROM dynamically collects the data as the FOM simulation marches in time domain. In the hyper-reduction preprocessing phase, the libROM builds a library of reduced basis as well as hyper-reduction operators. The online phase runs the ROM and the restore phase projects the ROM solutions to the full order model dimension. Sedov blast problem Sedov blast problem is a three-dimensional standard shock hydrodynamic benchmark test. An initial delta source of internal energy deposited at the origin of a three-dimensional cube is considered. The computational domain is the unit cube $\\tilde{\\Omega} = [0,1]^3$ with wall boundary conditions on all surfaces, i.e., $v\\cdot n = 0$. The initial velocity is given by $v=0$. The initial density is given by $\\rho = 1$. The initial energy is given by a delta function at the origin. The adiabatic index in the ideal gas equations of state is set $\\gamma = 1.4$. The initial mesh is a uniform Catesian hexahedral mesh, which deforms over time. It can be seen that the radial symmetry is maintained in the shock wave propagation in both FOM and ROM simulations. One can reproduce the numerical result, following the command line options described below: offline : ./laghos -o twp_sedov -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -offline -visit -romsvds -ef 0.9999 -writesol -romos -rostype load -romsns -nwinsamp 21 -sample-stages hyper-reduction preprocessing : ./laghos -o twp_sedov -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -online -romsvds -romos -rostype load -romhrprep -romsns -romgs -nwin 66 -sfacv 2 -sface 2 online : ./laghos -o twp_sedov -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -online -romsvds -romos -rostype load -romhr -romsns -romgs -nwin 66 -sfacv 2 -sface 2 restore : ./laghos -o twp_sedov -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -restore -soldiff -romsvds -romos -rostype load -romsns -romgs -nwin 66 FOM solution time ROM solution time Speed-up Velocity relative error 191 sec 8.3 sec 22.8 2.2e-4 Gresho vortex problem Gresho vortex problem is a two-dimensional benchmark test for the incompressible inviscid Navier-Stokes equations. The computational domain is the unit square $\\tilde\\Omega = [-0.5,0.5]^2$ with wall boundary conditions on all surfaces, i.e., $v\\dot n = 0$. Let $(r,\\phi)$ denote the polar coordinates of a particle $\\tilde{x} \\in \\tilde{\\Omega}$. The initial angular velocity is given by $$v_\\phi = \\cases{ \\displaystyle 5r & for 0 $\\leq$ r < 0.2 \\cr \\displaystyle 2-5r & for 0.2 $\\leq$ r < 0.4 \\cr \\displaystyle 0 i & for r $\\geq$ 0.4. }$$ The initial density if given by $\\rho=1$. The initial thermodynamic pressure is given by $$p = \\cases{ 5 + \\frac{25}{2} r^2 & for 0 $\\leq$ r < 0.2 \\cr 9 - 4 \\log(0.2) + \\frac{25}{2} - 20r + 4 \\log(r) & for 0.2 $\\leq$ r < 0.4 \\cr 3 + 4\\log(2) & for r $\\geq$ 0.4 }$$ offline : ./laghos -o twp_gresho -p 4 -m ../data/square_gresho.mesh -rs 4 -ok 3 -ot 2 -tf 0.62 -s 7 -visit -writesol -offline -ef 0.9999 -romsvds -romos -rostype load -romsns -nwinsamp 21 -sample-stages hyper-reduction preprocessing : ./laghos -o twp_gresho -p 4 -m ../data/square_gresho.mesh -rs 4 -ok 3 -ot 2 -tf 0.62 -s 7 -online -romhrprep -romsvds -romos -rostype load -romsns -romgs -nwin 152 -sfacv 2 -sface 2 online : ./laghos -o twp_gresho -p 4 -m ../data/square_gresho.mesh -rs 4 -ok 3 -ot 2 -tf 0.62 -s 7 -online -romhr -romsvds -romos -rostype load -romsns -romgs -nwin 152 -sfacv 2 -sface 2 restore : ./laghos -o twp_gresho -p 4 -m ../data/square_gresho.mesh -rs 4 -ok 3 -ot 2 -tf 0.62 -s 7 -soldiff -restore -romsvds -romos -rostype load -romsns -romgs -nwin 152 FOM solution time ROM solution time Speed-up Velocity relative error 218 sec 8.4 sec 25.9 2.1e-4 Taylor-Green vortex Taylor-Green vortex problem is a three-dimensional benchmark test for the incompressible Navier-Stokes equasions. A manufactured smooth solution is considered by extending the steady state Taylor-Green vortex solution to the compressible Euler equations. The computational domain is the unit cube $\\tilde{\\Omega}=[0,1]^3$ with wall boundary conditions on all surfaces, i.e., $v\\cdot n = 0$. The initial velocity is given by $$ v = (\\sin{(\\pi x)} \\cos{(\\pi y)} \\cos{(\\pi z)}, -\\cos{(\\pi x)}\\sin{(\\pi y)}\\cos{(\\pi z)}, 0) $$ The initial density is given by $\\rho =1$. The initial thermodynamic pressure is given by $$ p = 100 + \\frac{(\\cos{(2\\pi x)} + \\cos{(2\\pi y))(\\cos{(2\\pi z)+2})-2}}{16} $$ The initial energy is related to the pressure and the density by the equation of state for the ideal gas, $p=(\\gamma-1)\\rho e$, with $\\gamma = 5/3$. The initial mesh is a uniform Cartesian hexahedral mesh, which deforms over time. The visualized solution is given on the right. One can reproduce the numerical result, following the command line options described below: offline : ./laghos -o twp_taylor -m ../data/cube01_hex.mesh -p 0 -rs 2 -cfl 0.1 -tf 0.25 -s 7 -pa -offline -visit -romsvds -ef 0.9999 -writesol -romos -rostype load -romsns -nwinsamp 21 -sdim 1000 -sample-stages hyper-reduction preprocessing : ./laghos -o twp_taylor -m ../data/cube01_hex.mesh -p 0 -rs 2 -cfl 0.1 -tf 0.25 -s 7 -pa -online -romsvds -romos -rostype load -romhrprep -romsns -romgs -nwin 82 -sfacv 2 -sface 2 online : ./laghos -o twp_taylor -m ../data/cube01_hex.mesh -p 0 -rs 2 -cfl 0.1 -tf 0.25 -s 7 -pa -online -romsvds -romos -rostype load -romhr -romsns -romgs -nwin 82 -sfacv 2 -sface 2 restore : ./laghos -o twp_taylor -m ../data/cube01_hex.mesh -p 0 -rs 2 -cfl 0.1 -tf 0.25 -s 7 -pa -restore -soldiff -romsvds -romos -rostype load -romsns -romgs -nwin 82 FOM solution time ROM solution time Speed-up Velocity relative error 170 sec 5.4 sec 31.2 1.1e-6 Triple-point problem Triple-point problem is a three-dimensional shock test with two materials in three states. The computational domain is $\\tilde{\\Omega} = [0,7] \\times [0,3 ] \\times [0,1.5]$ with wall boundary conditions on all surfaces, i.e., $v\\cdot n = 0$. The initial velocity is given by $v=0$. The initial density is given by $$\\rho = \\cases{ \\displaystyle 1 & for x $\\leq$ 1 or y $\\leq$ 1.5, \\cr \\displaystyle 1/8 & for x $>$ 1 and y $>$ 1.5 }$$ The initial thermodynamic pressure is given for $$p = \\cases{ \\displaystyle 1 & for x $\\leq$ 1, \\cr \\displaystyle 0.1 & for x $>$ 1 }$$ The initial energy is related to the pressure and the density by the equation of state for the ideal gas, $p=(\\gamma-1)\\rho e$, with $$\\gamma = \\cases{ \\displaystyle 1.5 & for x $\\leq$ 1 or y $>$ 1.5\\cr \\displaystyle 1.4 & for x $>$ 1 and y $\\leq$ 1.5 }$$ The initial mesh is a uniform Cartesian hexahedral mesh, which deforms over time. The visualized solution is given on the right. One can reproduce the numerical result, following the command line options described below: offline : ./laghos -o twp_triple -p 3 -m ../data/box01_hex.mesh -rs 2 -tf 0.8 -s 7 -cfl 0.5 -pa -offline -writesol -visit -romsvds -romos -rostype load -romsns -nwinsamp 21 -ef 0.9999 -sdim 200 -sample-stages hyper-reduction preprocessing : ./laghos -o twp_triple -p 3 -m ../data/box01_hex.mesh -rs 2 -tf 0.8 -s 7 -cfl 0.5 -pa -online -romhrprep -romsvds -romos -rostype load -romgs -romsns -nwin 18 -sfacv 2 -sface 2 online : ./laghos -o twp_triple -p 3 -m ../data/box01_hex.mesh -rs 2 -tf 0.8 -s 7 -cfl 0.5 -pa -online -romhr -romsvds -romos -rostype load -romgs -romsns -nwin 18 -sfacv 2 -sface 2 restore : ./laghos -o twp_triple -p 3 -m ../data/box01_hex.mesh -rs 2 -tf 0.8 -s 7 -cfl 0.5 -pa -restore -soldiff -romsvds -romos -rostype load -romgs -romsns -nwin 18 FOM solution time ROM solution time Speed-up Velocity relative error 122 sec 1.4 sec 87.8 8.1e-4 Rayleigh-Taylor instability problem Rayleigh-Taylor instability problem offline : ./laghos -p 7 -m ../data/rt2D.mesh -tf 1.5 -rs 4 -ok 2 -ot 1 -pa -o twp_rt -s 7 -writesol -offline -romsns -sdim 200000 -romsvds -romos -romgs -nwinsamp 21 -ef 0.9999999999 -sample-stages hyper-reduction preprocessing : ./laghos -p 7 -m ../data/rt2D.mesh -tf 1.5 -rs 4 -ok 2 -ot 1 -pa -o twp_rt -s 7 -online -romsns -romos -romgs -nwin 187 -sfacv 2 -sface 2 -romhrprep online : ./laghos -p 7 -m ../data/rt2D.mesh -tf 1.5 -rs 4 -ok 2 -ot 1 -pa -o twp_rt -s 7 -online -romsns -romos -romgs -nwin 187 -sfacv 2 -sface 2 -romhr restore : ./laghos -p 7 -m ../data/rt2D.mesh -tf 1.5 -rs 4 -ok 2 -ot 1 -pa -o twp_rt -s 7 -restore -romsns -romos -romgs -soldiff -nwin 187 FOM solution time ROM solution time Speed-up Velocity relative error 127 sec 8.7 sec 14.6 7.8e-3 This is an external miniapp, available at https://github.com/CEED/Laghos/tree/rom . No examples or miniapps match your criteria. <!-- function showElement(id, show) { //document.getElementById(id).style.display = show ? \"block\" : \"none\"; // workaround because Doxygen splits and duplicates the divs for some reason var divs = document.getElementsByTagName(\"div\"); for (i = 0; i < divs.length; i++) { if (divs.item(i).id == id) { divs.item(i).style.display = show ? \"block\" : \"none\"; } } return show ? 1 : 0; } function getBooleans(comboId) { combo = document.getElementById(comboId); first_selected = false; for (i = 0; i < combo.options.length; i++) { opt = combo.options[i]; selected = opt.selected || first_selected; if (!i) { first_selected = selected; } // create a boolean variable named after the option this[opt.id] = selected; } } function update() { getBooleans(\"group1\"); getBooleans(\"group2\"); getBooleans(\"group3\"); getBooleans(\"group4\"); numShown = 0 // expression continued... // example codes + showElement(\"poisson\", (diffusion) && (prom) && (global) && (no_hr)) + showElement(\"dg_advection\", (advection) && (dmd) && (reproductive) && (no_hr)) + showElement(\"dg_euler\", (euler) && (dmd) && (reproductive) && (no_hr)) + showElement(\"heat_conduction\", (diffusion) && (dmd) && (reproductive) && (no_hr)) + showElement(\"mixed_nonlinear_diffusion\", (diffusion) && (prom) && (global) && (hr)) + showElement(\"nonlinear_elasticity\", (elasticity) && (dmd) && (reproductive) && (no_hr)) + showElement(\"laghos\", (compressibleflow) && (prom) && (global) && (hr)) ; // ...end of expression // show/hide the message \"No examples match your criteria\" showElement(\"nomatch\", numShown == 0); } function initCombos() { var query = location.search.substr(1); query.split(\"&\").forEach(function(id) { if (id) { opt = document.getElementById(id); if (opt) { opt.selected = true; } } }); } // make sure \"no match\" div is not visible after page is loaded window.onload = update; // force vertical scrollbar document.getElementsByTagName(\"body\")[0].style = \"overflow-y: scroll\" // parse URL part after '?', e.g., http://.../index.html?elasticity&nurbs initCombos(); //-->","title":"Examples"},{"location":"examples.html#example-applications","text":"This page provides a list of libROM example applications. For detailed documentation of the libROM sources, including the examples, see the online Doxygen documentation or the doc directory in the distribution. The goal of the example codes is to provide a step-by-step introduction to libROM in simple model settings. Select from the categories below to display examples and miniapps that contain the respective feature. All examples support (arbitrarily) high-order meshes and finite element spaces . The numerical results from the example codes can be visualized using the GLVis or VisIt visualization tools. See the GLVis and VisIt websites for more details. Users are encouraged to submit any example codes and miniapps that they have created and would like to share. Contact a member of the libROM team to report bugs or post questions or comments .","title":"Example Applications"},{"location":"examples.html#application-pde","text":"All Diffusion Elasticity Euler Advection Compressible flow","title":"**Application (PDE)**"},{"location":"examples.html#reduced-order-models-type","text":"All pROM DMD","title":"**Reduced order models type**"},{"location":"examples.html#parameterization-type","text":"All Trust region Interpolation Global Reproductive","title":"**Parameterization type**"},{"location":"examples.html#hyper-reduction","text":"All Hyper-reduction No hyper-reduction","title":"**hyper-reduction**"},{"location":"examples.html#poisson-problem","text":"This example code demonstrates the use of libROM and MFEM to define a reduced order model for a simple isoparametric finite element discretization of the Poisson problem $$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. The example parameterizes the righthand side with frequency variable, $\\kappa$: $$f = \\cases{ \\displaystyle \\sin(\\kappa (x_0+x_1+x_2)) & for 3D \\cr \\displaystyle \\sin(\\kappa (x_0+x_1)) & for 2D }$$ The 2D solution contour plot for $\\kappa=1$ is shown in the figure on the right to show the effect of $\\kappa$. For demonstration, we sample solutions at $\\kappa=1$, $1.1$, and $1.2$. Then a ROM is build with basis size of 3, which is used to predict the solution for $\\kappa = 1.15$. The ROM is able to achieve a speedup of $7.5$ with a relative error of $6.4\\times10^{-4}$. One can follow the command line options below to reproduce the numerical results summarized in the table below: offline1 : poisson -offline -f 1.0 -id 0 offline2 : poisson -offline -f 1.1 -id 1 offline3 : poisson -offline -f 1.2 -id 2 merge : poisson -merge -ns 3 online : poisson -online -f 1.15 FOM solution time ROM solution time Speed-up Solution relative error 0.22 sec 0.029 sec 7.5 6.4e-4 The code that generates the numerical results above can be found in ( poisson.cpp ) and the explanation of codes is provided in here . The poisson.cpp is based on ex1p.cpp from MFEM with a modification on the right hand side function.","title":"Poisson Problem"},{"location":"examples.html#advection","text":"For a given initial condition, i.e., $u_0(x) = u(0,x)$, DG advection solves the time-dependent advection problem: $$\\frac{\\partial u}{\\partial t} + v\\cdot\\nabla u = 0,$$ where $v$ is a given advection velocity. One can run the following command line options to reproduce the DMD results summarized in the table below: dg_advection -p 3 -rp 1 -dt 0.005 -tf 4 -visit FOM solution time DMD setup time DMD query time DMD relative error 5.2 sec 30.6 sec 1.9e-2 sec 1.9e-4 The code that generates the numerical results above can be found in ( dg_advection.cpp ). The dg_advection.cpp is based on ex9p.cpp from MFEM.","title":"Advection"},{"location":"examples.html#euler-equation","text":"For a given initial condition, i.e., $u_0(x) = u(0,x)$, DG Euler solves the compressible Euler system of equation, i.e., a model nonlinear hyperbolic PDE: $$\\frac{\\partial u}{\\partial t} + \\nabla\\cdot \\boldsymbol{F}(u) = 0,$$ with a state vector $\\boldsymbol{u} = [\\rho,\\rho v_0, \\rho v_1, \\rho E]$, where $\\rho$ is the density, $v_i$ is the velocity in the $i$th direction, $E$ is the total specific energy, and $H = E + p/\\rho$ is the total specific enthalpy. The pressure, $p$ is computed through a simple equation of state (EOS) call. The conservative hydrodynamic flux $\\boldsymbol{F}$ in each direction $i$ is $$\\boldsymbol{F}_i = [\\rho v_i, \\rho v_0 v_i + p \\delta_{i,0}, \\rho v_1 v_{i,1} + p\\delta_{i,1}, \\rho v_i H]$$ One can run the following command line options to reproduce the DMD results summarized in the table below: mpirun -n 8 ./dg_euler -p 2 -rs 2 -rp 1 -o 1 -s 3 -visit DMD rel.error FOM solution time DMD setup time DMD query time $\\rho$ $\\rho v_0$ $\\rho v_1$ $E$ 5.65 sec 38.9 sec 1.4e-3 sec 8.0e-7 1.2e-4 1.6e-3 2.6e-6 The code that generates the numerical results above can be found in ( dg_euler.cpp ). The dg_euler.cpp is based on ex18p.cpp from MFEM.","title":"Euler equation"},{"location":"examples.html#heat-conduction-problem","text":"For a given initial condition, i.e., $u_0(x) = u(0,x)$, heat conduction solves a simple 2D/3D time dependent nonlinear heat conduction problem $$\\frac{\\partial u}{\\partial t} = \\nabla\\cdot (\\kappa + \\alpha u)\\nabla u,$$ with a natural insulating boundary condition $\\frac{du}{dn}=0$. We linearize the problem by using the temperature field $u$ from the previous time step to compute the conductivity coefficient. One can run the following command line options to reproduce the DMD results summarized in the table below: mpirun -np 8 ./heat_conduction -s 3 -a 0.5 -k 0.5 -o 4 -tf 0.7 -vs 1 -visit FOM solution time DMD setup time DMD query time DMD relative error 4.8 sec 0.34 sec 1.4e-3 sec 8.2e-4 The code that generates the numerical results above can be found in ( heat_conduction.cpp ). The heat_conduction.cpp is based on ex16p.cpp from MFEM.","title":"Heat conduction problem"},{"location":"examples.html#mixed-nonlinear-diffusion","text":"For a given initial condition, i.e., $p_0(x) = p(0,x)$, mixed nonlinear diffusion problem solves a simple 2D/3D time dependent nonlinear problem: $$\\frac{\\partial p}{\\partial t} + \\nabla\\cdot \\boldsymbol{v} = f\\,, \\qquad \\nabla p = -a(p)\\boldsymbol{v},$$ with a natural insulating boundary condition $\\frac{\\partial v}{\\partial n}=0$. The $H(div)$-conforming Raviart-Thomas finite element space is used for the velocity function $\\boldsymbol{v}$, and the $L^2$ finite element space is used for pressure function, $p$. This example introduces how the hyper-reduction is implemented and how the reduced bases for two field varibles, $p$ and $\\boldsymbol{v}$. One can run the following command line options to reproduce the DMD results summarized in the table below: offline1 : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -offline -id 0 -sh 0.25 offline2 : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -offline -id 1 -sh 0.15 merge : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -merge -ns 2 offline3 : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -offline -id 2 -sh 0.2 online : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -online -rrdim 8 -rwdim 8 -sh 0.2 -id 2 FOM solution time ROM solution time Speed-up Solution relative error 41.68 sec 1.7 sec 24.5 1.6e-3 The code that generates the numerical results above can be found in ( mixed_nonlinear_diffusion.cpp ). The mixed_nonlinear_diffusion.cpp is based on ex16p.cpp from MFEM and modified to support mixed finite element approach.","title":"Mixed nonlinear diffusion"},{"location":"examples.html#nonlinear-elasticity","text":"For a given initial condition, i.e., $v_0(x) = v(0,x)$, nonlinear elasticity solves a time dependent nonlinear elasticity problem of the form $$\\frac{\\partial v}{\\partial t} = H(x) + Sv\\,, \\qquad \\frac{\\partial x}{\\partial t} = v,$$ where $H$ is a hyperelastic model and $S$ is a viscosity operator of Laplacian type. One can run the following command line options to reproduce the DMD results summarized in the table below: mpirun -np 8 ./nonlinear_elasticity -s 2 -rs 1 -dt 0.01 -tf 5 -visit FOM solution time DMD setup time DMD query time Position relative error Velocity relative error 3.7 sec 4.7e-1 sec 6.9e-4 sec 7.0e-5 1.4e-3 The code that generates the numerical results above can be found in ( nonlinear_elasticity.cpp ). The nonlinear_elasticity.cpp is based on ex10p.cpp from MFEM.","title":"Nonlinear elasticity"},{"location":"examples.html#laghos-rom-miniapp","text":"Laghos (LAGrangian High-Order Solver) is a miniapp that solves the time-dependent Euler equations of compressible gas dynamics in a moving Lagrangian frame using unstructured high-order finite element spatial discretization and explicit high-order time-stepping. LaghosROM introduces reduced order models of Laghos simulations. A list of example problems that you can solve with LaghosROM includes Sedov blast, Gresho vortex, Taylor-Green vortex, triple-point, and Rayleigh-Taylor instability problems. Below are command line options for each problems and some numerical results. For each problem, four different phases need to be taken, i.e., the offline, hyper-reduction preprocessing, online, and restore phase. The online phase runs necessary full order model (FOM) to generate simulation data. libROM dynamically collects the data as the FOM simulation marches in time domain. In the hyper-reduction preprocessing phase, the libROM builds a library of reduced basis as well as hyper-reduction operators. The online phase runs the ROM and the restore phase projects the ROM solutions to the full order model dimension.","title":"Laghos ROM Miniapp"},{"location":"examples.html#sedov-blast-problem","text":"Sedov blast problem is a three-dimensional standard shock hydrodynamic benchmark test. An initial delta source of internal energy deposited at the origin of a three-dimensional cube is considered. The computational domain is the unit cube $\\tilde{\\Omega} = [0,1]^3$ with wall boundary conditions on all surfaces, i.e., $v\\cdot n = 0$. The initial velocity is given by $v=0$. The initial density is given by $\\rho = 1$. The initial energy is given by a delta function at the origin. The adiabatic index in the ideal gas equations of state is set $\\gamma = 1.4$. The initial mesh is a uniform Catesian hexahedral mesh, which deforms over time. It can be seen that the radial symmetry is maintained in the shock wave propagation in both FOM and ROM simulations. One can reproduce the numerical result, following the command line options described below: offline : ./laghos -o twp_sedov -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -offline -visit -romsvds -ef 0.9999 -writesol -romos -rostype load -romsns -nwinsamp 21 -sample-stages hyper-reduction preprocessing : ./laghos -o twp_sedov -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -online -romsvds -romos -rostype load -romhrprep -romsns -romgs -nwin 66 -sfacv 2 -sface 2 online : ./laghos -o twp_sedov -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -online -romsvds -romos -rostype load -romhr -romsns -romgs -nwin 66 -sfacv 2 -sface 2 restore : ./laghos -o twp_sedov -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -restore -soldiff -romsvds -romos -rostype load -romsns -romgs -nwin 66 FOM solution time ROM solution time Speed-up Velocity relative error 191 sec 8.3 sec 22.8 2.2e-4","title":"Sedov blast problem"},{"location":"examples.html#gresho-vortex-problem","text":"Gresho vortex problem is a two-dimensional benchmark test for the incompressible inviscid Navier-Stokes equations. The computational domain is the unit square $\\tilde\\Omega = [-0.5,0.5]^2$ with wall boundary conditions on all surfaces, i.e., $v\\dot n = 0$. Let $(r,\\phi)$ denote the polar coordinates of a particle $\\tilde{x} \\in \\tilde{\\Omega}$. The initial angular velocity is given by $$v_\\phi = \\cases{ \\displaystyle 5r & for 0 $\\leq$ r < 0.2 \\cr \\displaystyle 2-5r & for 0.2 $\\leq$ r < 0.4 \\cr \\displaystyle 0 i & for r $\\geq$ 0.4. }$$ The initial density if given by $\\rho=1$. The initial thermodynamic pressure is given by $$p = \\cases{ 5 + \\frac{25}{2} r^2 & for 0 $\\leq$ r < 0.2 \\cr 9 - 4 \\log(0.2) + \\frac{25}{2} - 20r + 4 \\log(r) & for 0.2 $\\leq$ r < 0.4 \\cr 3 + 4\\log(2) & for r $\\geq$ 0.4 }$$ offline : ./laghos -o twp_gresho -p 4 -m ../data/square_gresho.mesh -rs 4 -ok 3 -ot 2 -tf 0.62 -s 7 -visit -writesol -offline -ef 0.9999 -romsvds -romos -rostype load -romsns -nwinsamp 21 -sample-stages hyper-reduction preprocessing : ./laghos -o twp_gresho -p 4 -m ../data/square_gresho.mesh -rs 4 -ok 3 -ot 2 -tf 0.62 -s 7 -online -romhrprep -romsvds -romos -rostype load -romsns -romgs -nwin 152 -sfacv 2 -sface 2 online : ./laghos -o twp_gresho -p 4 -m ../data/square_gresho.mesh -rs 4 -ok 3 -ot 2 -tf 0.62 -s 7 -online -romhr -romsvds -romos -rostype load -romsns -romgs -nwin 152 -sfacv 2 -sface 2 restore : ./laghos -o twp_gresho -p 4 -m ../data/square_gresho.mesh -rs 4 -ok 3 -ot 2 -tf 0.62 -s 7 -soldiff -restore -romsvds -romos -rostype load -romsns -romgs -nwin 152 FOM solution time ROM solution time Speed-up Velocity relative error 218 sec 8.4 sec 25.9 2.1e-4","title":"Gresho vortex problem"},{"location":"examples.html#taylor-green-vortex","text":"Taylor-Green vortex problem is a three-dimensional benchmark test for the incompressible Navier-Stokes equasions. A manufactured smooth solution is considered by extending the steady state Taylor-Green vortex solution to the compressible Euler equations. The computational domain is the unit cube $\\tilde{\\Omega}=[0,1]^3$ with wall boundary conditions on all surfaces, i.e., $v\\cdot n = 0$. The initial velocity is given by $$ v = (\\sin{(\\pi x)} \\cos{(\\pi y)} \\cos{(\\pi z)}, -\\cos{(\\pi x)}\\sin{(\\pi y)}\\cos{(\\pi z)}, 0) $$ The initial density is given by $\\rho =1$. The initial thermodynamic pressure is given by $$ p = 100 + \\frac{(\\cos{(2\\pi x)} + \\cos{(2\\pi y))(\\cos{(2\\pi z)+2})-2}}{16} $$ The initial energy is related to the pressure and the density by the equation of state for the ideal gas, $p=(\\gamma-1)\\rho e$, with $\\gamma = 5/3$. The initial mesh is a uniform Cartesian hexahedral mesh, which deforms over time. The visualized solution is given on the right. One can reproduce the numerical result, following the command line options described below: offline : ./laghos -o twp_taylor -m ../data/cube01_hex.mesh -p 0 -rs 2 -cfl 0.1 -tf 0.25 -s 7 -pa -offline -visit -romsvds -ef 0.9999 -writesol -romos -rostype load -romsns -nwinsamp 21 -sdim 1000 -sample-stages hyper-reduction preprocessing : ./laghos -o twp_taylor -m ../data/cube01_hex.mesh -p 0 -rs 2 -cfl 0.1 -tf 0.25 -s 7 -pa -online -romsvds -romos -rostype load -romhrprep -romsns -romgs -nwin 82 -sfacv 2 -sface 2 online : ./laghos -o twp_taylor -m ../data/cube01_hex.mesh -p 0 -rs 2 -cfl 0.1 -tf 0.25 -s 7 -pa -online -romsvds -romos -rostype load -romhr -romsns -romgs -nwin 82 -sfacv 2 -sface 2 restore : ./laghos -o twp_taylor -m ../data/cube01_hex.mesh -p 0 -rs 2 -cfl 0.1 -tf 0.25 -s 7 -pa -restore -soldiff -romsvds -romos -rostype load -romsns -romgs -nwin 82 FOM solution time ROM solution time Speed-up Velocity relative error 170 sec 5.4 sec 31.2 1.1e-6","title":"Taylor-Green vortex"},{"location":"examples.html#triple-point-problem","text":"Triple-point problem is a three-dimensional shock test with two materials in three states. The computational domain is $\\tilde{\\Omega} = [0,7] \\times [0,3 ] \\times [0,1.5]$ with wall boundary conditions on all surfaces, i.e., $v\\cdot n = 0$. The initial velocity is given by $v=0$. The initial density is given by $$\\rho = \\cases{ \\displaystyle 1 & for x $\\leq$ 1 or y $\\leq$ 1.5, \\cr \\displaystyle 1/8 & for x $>$ 1 and y $>$ 1.5 }$$ The initial thermodynamic pressure is given for $$p = \\cases{ \\displaystyle 1 & for x $\\leq$ 1, \\cr \\displaystyle 0.1 & for x $>$ 1 }$$ The initial energy is related to the pressure and the density by the equation of state for the ideal gas, $p=(\\gamma-1)\\rho e$, with $$\\gamma = \\cases{ \\displaystyle 1.5 & for x $\\leq$ 1 or y $>$ 1.5\\cr \\displaystyle 1.4 & for x $>$ 1 and y $\\leq$ 1.5 }$$ The initial mesh is a uniform Cartesian hexahedral mesh, which deforms over time. The visualized solution is given on the right. One can reproduce the numerical result, following the command line options described below: offline : ./laghos -o twp_triple -p 3 -m ../data/box01_hex.mesh -rs 2 -tf 0.8 -s 7 -cfl 0.5 -pa -offline -writesol -visit -romsvds -romos -rostype load -romsns -nwinsamp 21 -ef 0.9999 -sdim 200 -sample-stages hyper-reduction preprocessing : ./laghos -o twp_triple -p 3 -m ../data/box01_hex.mesh -rs 2 -tf 0.8 -s 7 -cfl 0.5 -pa -online -romhrprep -romsvds -romos -rostype load -romgs -romsns -nwin 18 -sfacv 2 -sface 2 online : ./laghos -o twp_triple -p 3 -m ../data/box01_hex.mesh -rs 2 -tf 0.8 -s 7 -cfl 0.5 -pa -online -romhr -romsvds -romos -rostype load -romgs -romsns -nwin 18 -sfacv 2 -sface 2 restore : ./laghos -o twp_triple -p 3 -m ../data/box01_hex.mesh -rs 2 -tf 0.8 -s 7 -cfl 0.5 -pa -restore -soldiff -romsvds -romos -rostype load -romgs -romsns -nwin 18 FOM solution time ROM solution time Speed-up Velocity relative error 122 sec 1.4 sec 87.8 8.1e-4","title":"Triple-point problem"},{"location":"examples.html#rayleigh-taylor-instability-problem","text":"Rayleigh-Taylor instability problem offline : ./laghos -p 7 -m ../data/rt2D.mesh -tf 1.5 -rs 4 -ok 2 -ot 1 -pa -o twp_rt -s 7 -writesol -offline -romsns -sdim 200000 -romsvds -romos -romgs -nwinsamp 21 -ef 0.9999999999 -sample-stages hyper-reduction preprocessing : ./laghos -p 7 -m ../data/rt2D.mesh -tf 1.5 -rs 4 -ok 2 -ot 1 -pa -o twp_rt -s 7 -online -romsns -romos -romgs -nwin 187 -sfacv 2 -sface 2 -romhrprep online : ./laghos -p 7 -m ../data/rt2D.mesh -tf 1.5 -rs 4 -ok 2 -ot 1 -pa -o twp_rt -s 7 -online -romsns -romos -romgs -nwin 187 -sfacv 2 -sface 2 -romhr restore : ./laghos -p 7 -m ../data/rt2D.mesh -tf 1.5 -rs 4 -ok 2 -ot 1 -pa -o twp_rt -s 7 -restore -romsns -romos -romgs -soldiff -nwin 187 FOM solution time ROM solution time Speed-up Velocity relative error 127 sec 8.7 sec 14.6 7.8e-3 This is an external miniapp, available at https://github.com/CEED/Laghos/tree/rom . No examples or miniapps match your criteria. <!-- function showElement(id, show) { //document.getElementById(id).style.display = show ? \"block\" : \"none\"; // workaround because Doxygen splits and duplicates the divs for some reason var divs = document.getElementsByTagName(\"div\"); for (i = 0; i < divs.length; i++) { if (divs.item(i).id == id) { divs.item(i).style.display = show ? \"block\" : \"none\"; } } return show ? 1 : 0; } function getBooleans(comboId) { combo = document.getElementById(comboId); first_selected = false; for (i = 0; i < combo.options.length; i++) { opt = combo.options[i]; selected = opt.selected || first_selected; if (!i) { first_selected = selected; } // create a boolean variable named after the option this[opt.id] = selected; } } function update() { getBooleans(\"group1\"); getBooleans(\"group2\"); getBooleans(\"group3\"); getBooleans(\"group4\"); numShown = 0 // expression continued... // example codes + showElement(\"poisson\", (diffusion) && (prom) && (global) && (no_hr)) + showElement(\"dg_advection\", (advection) && (dmd) && (reproductive) && (no_hr)) + showElement(\"dg_euler\", (euler) && (dmd) && (reproductive) && (no_hr)) + showElement(\"heat_conduction\", (diffusion) && (dmd) && (reproductive) && (no_hr)) + showElement(\"mixed_nonlinear_diffusion\", (diffusion) && (prom) && (global) && (hr)) + showElement(\"nonlinear_elasticity\", (elasticity) && (dmd) && (reproductive) && (no_hr)) + showElement(\"laghos\", (compressibleflow) && (prom) && (global) && (hr)) ; // ...end of expression // show/hide the message \"No examples match your criteria\" showElement(\"nomatch\", numShown == 0); } function initCombos() { var query = location.search.substr(1); query.split(\"&\").forEach(function(id) { if (id) { opt = document.getElementById(id); if (opt) { opt.selected = true; } } }); } // make sure \"no match\" div is not visible after page is loaded window.onload = update; // force vertical scrollbar document.getElementsByTagName(\"body\")[0].style = \"overflow-y: scroll\" // parse URL part after '?', e.g., http://.../index.html?elasticity&nurbs initCombos(); //-->","title":"Rayleigh-Taylor instability problem"},{"location":"features.html","text":"MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}}); Features The goal of libROM is to provide high-performance scalable library for data-driven reduced order modeling. Proper orthogonal decomposition One of the core features in libROM is the ability to extract important modes from given physical simulation data. The proper othogonal decomposition (POD) is a popular method for compressing physical simulation data to obtain optimal \"reduced\" bases in the following sense: $$\\boldsymbol{\\Phi} =\\underset{\\boldsymbol{A}\\in\\mathbb{R}^{n\\times r}, \\boldsymbol{A}^T\\boldsymbol{A} = \\boldsymbol{I}_{r\\times r} }{\\arg\\min} || \\boldsymbol{U} - \\boldsymbol{A}\\boldsymbol{A}^T\\boldsymbol{U} ||_F^2, $$ where $\\boldsymbol{U}\\in\\mathbb{R}^{n\\times m}$ is simulation data and $\\boldsymbol{I}_{r\\times r} \\in \\mathbb{R}^{r\\times r}$ denotes an identity matrix. That is, the POD tries to find the orthogonal matrix, $\\boldsymbol{\\Phi}$, whose span minimizes the projection error in the Frobenius norm. The POD modes can be obtained in two equivalent ways: (i) eigenvalue decomposition and (ii) singular value decomposition (SVD). We take the latter approach, i.e., let's say the thin SVD of $\\boldsymbol{U}$ is given by $$\\boldsymbol{U} = \\boldsymbol{W\\Sigma V}^T.$$ Then the solution of the POD is given by taking the first $r$ columns of the left singular matrix, i.e., $\\boldsymbol{\\Phi} = [\\boldsymbol{w}_{1},\\ldots ,\\boldsymbol{w}_r]$, where $\\boldsymbol{w}_k$ is $k$th left singular vector, assuming that the singular value is written in the decreasing order. Efficient data collection High-fidelity physical simulations generate intensive data in its size, which makes the data collection process daunting. Therefore, the libROM aims to ease the difficulty associated with the intensive data size. The libROM can be directly integrated to the physics solver that generates the intensive simulation data. For example, if the physical simulation is time dependent, then each time step solution data can be feed into the libROM incrementally so that the singular value decomposition is efficiently updated in parallel. This approach is incremental SVD . There are other types of SVDs which exploits efficiency. The libROM provides following four SVDs: Static SVD incremental SVD randomized SVD space-time SVD Static SVD The static SVD waits the libROM to collect all the simulation data. Once the snapshot matrix $\\boldsymbol{U}$ is formed, then the SVD is performed. Therefore, if the data size is big, this approach is not efficient and not recommended. However, because it gives the most accurate SVD results, it is ideal for a small problem. Incremental SVD Unlike the static SVD, the incremental SVD does not wait. Instead, as the data comes in, the SVD is performed right away. Because the incremental SVD only needs to find out the effect of one additional simulation data vector to the previous SVD, the update can be done very efficiently without requiring much memory. Therefore, it is useful for large-scale problems. For the detailed explanation about the incremental SVD, we refer to the following journal papers: M. Brand, Incremental singular value decomposition of uncertain data with missing values , In European Conference on Computer Vision , p707-720, 2002 G. Oxberry, T. Kostova-Vassilevska, W. Arrighi, K. Chand, Limited-memory adaptive snapshot selection for proper orthogonal decomposition , International Journal for Numerical Methods in Engineering , 109(2), p198-217, 2016 H. Fareed, J.R. Singler, Error Analysis of an Incremental Proper Orthogonal Decomposition Algorithm for PDE Simulation Data , Journal of Computational and Applied Mathematics , 368, 112525, 2020 Randomized SVD Randomization can bring computational efficiency in computing SVDs. For example, consider that one needs to extract $p$ dominant modes from $n \\times m$ tall dense matrix, using SVD. The randomized SVD requires $\\mathcal{O}(nm\\log(p))$ floating-point operations, while the static SVD algorithm requires $\\mathcal{O}(nmp)$ flops. The randomized SVD that is implemented in libROM can be found in the following journal paper: N. Halko, P.G. Martinsson, J.A. Tropp, Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions . SIAM review , 53(2), p217-288, 2011 Space-time SVD For time dependent problems, one can reduce not only the spatial degrees of freedom, but also the temporal degrees of freedom by representing the space-time solution as a linear combination of a space-time reduced basis. The space-time reduced basis can be mathematically written as a Kronecker product of temporal and spatial bases. Fortunately, one can extract temporal as well as spatial reduced bases from one single SVD. The procedure is schematically depicted in the figure below: For the detailed explanation about the incremental SVD, we refer to the following three journal papers: Y. Kim, K. Wang, Y. Choi, Efficient space\u2013time reduced order model for linear dynamical systems in Python using less than 120 lines of code . Mathematics , 9(14), 1690, 2021 Y. Choi, P. Brown, W. Arrighi, R. Anderson, K. Huynh, Space\u2013time reduced order model for large-scale linear dynamical systems with application to boltzmann transport problems . Journal of Computational Physics , 424, 109845, 2021 Y. Choi, K. Carlberg, Space-time least-squares Petrov-Galerkin projection for nonlinear model reduction , SIAM Journal on Scientific Computing , 41(1), A26-A58, 2019 Dynamic Mode Decomposition The dynamic mode decomposition (DMD) provides a great way of finding an approximate locally linear dynamical system, $$ \\frac{d\\boldsymbol{u}}{dt} = \\mathcal{A}\\boldsymbol{u},$$ for a given nonlinear dynamical system, $$ \\frac{d\\boldsymbol{u}}{dt} = \\boldsymbol{f}(\\boldsymbol{u},t;\\boldsymbol{\\mu}),$$ with initial condition, $\\boldsymbol{u}_0$. It takes non-intrusive approach, i.e., equation-free method, so it is applicable even if there is only data, but no $\\boldsymbol{f}(\\boldsymbol{u},t;\\boldsymbol{\\mu})$. For example, let's say the discrete-time data are given as: $$\\boldsymbol{U} = [\\boldsymbol{u}_1,\\ldots,\\boldsymbol{u}_m],$$ where $\\boldsymbol{u}_k\\in\\mathbb{R}^n$ denotes solution at $t=k\\Delta t$. The DMD is trying to find the best $\\boldsymbol{A}$ such that $$\\boldsymbol{U}^+ = \\boldsymbol{A}\\boldsymbol{U}^-,$$ where $\\boldsymbol{U}^+ = [\\boldsymbol{u}_2,\\ldots,\\boldsymbol{u}_m]$ and $\\boldsymbol{U}^- = [\\boldsymbol{u}_1, \\ldots, \\boldsymbol{u}_{m-1}]$. The following procedure is taken to find the best $\\boldsymbol{A}$. Take the singular value decomposition (SVD) of $\\boldsymbol{U}^-$ $$\\boldsymbol{U}^- \\approx \\boldsymbol{W}\\boldsymbol{\\Omega}\\boldsymbol{V}^*,$$ where $*$ denotes the conjugate transpose, $\\boldsymbol{W}\\in\\mathbb{C}^{n\\times r}$, $\\boldsymbol{\\Sigma}\\in\\mathbb{C}^{r\\times r}$, $\\boldsymbol{V}\\in\\mathbb{C}^{m\\times r}$, and $r \\leq m$. Because $\\boldsymbol{U}^+ = \\boldsymbol{A}\\boldsymbol{U}^-$, using the pseudo-inverse of the approximate $\\boldsymbol{U}^-$, we have $$\\boldsymbol{A} \\approx \\tilde{\\boldsymbol{A}} = \\boldsymbol{U}^+\\boldsymbol{V}\\boldsymbol{\\Omega}^{-1}\\boldsymbol{W}^*$$ It is easier to deal with the reduced operator $\\tilde{\\boldsymbol{A}}_r$, which relates the discrete-time dynamic of reduced states: $$\\tilde{\\boldsymbol{u}}_{k+1} = \\tilde{\\boldsymbol{A}}_r\\tilde{\\boldsymbol{u}}_k,$$ where $\\boldsymbol{u}_k = \\boldsymbol{W} \\tilde{\\boldsymbol{u}}_k$ and $\\tilde{\\boldsymbol{A}}_r$ is defined as $$\\tilde{\\boldsymbol{A}}_r=\\boldsymbol{W}^*\\tilde{\\boldsymbol{A}}\\boldsymbol{W}$$ $$\\tilde{\\boldsymbol{A}}_r=\\boldsymbol{W}^*\\boldsymbol{U}^+\\boldsymbol{V}\\boldsymbol{\\Omega}^{-1}$$ Let the eigen-decomposition of $\\tilde{\\boldsymbol{A}}_r$ to be $$\\tilde{\\boldsymbol{A}}_r \\boldsymbol{X} = \\boldsymbol{\\Lambda}\\boldsymbol{X}$$ and set either $\\boldsymbol{\\Phi} = \\boldsymbol{W}\\boldsymbol{X}$ or $\\boldsymbol{\\Phi} = \\boldsymbol{U}^+ \\boldsymbol{V} \\boldsymbol{\\Omega}^{-1}\\boldsymbol{X}$, then the DMD solution at time, $t$, can be found as $$\\boldsymbol{u}(t) = \\boldsymbol{\\Phi}\\boldsymbol{\\Lambda}^{t/\\Delta t} \\boldsymbol{b}_0,$$ where $\\boldsymbol{b}_0 = \\boldsymbol{\\Phi}^\\dagger \\boldsymbol{u}_0$. For the detailed explanation about the DMD, we refer to the following book: J.N. Kutz, S.L. Brunton, B.W. Brunton, J.L. Proctor, Dynamic mode decomposition: data-driven modeling of complex systems . Society for Industrial and Applied Mathematics , 2016 Projection-based reduced order model In contrast to the DMD, the projection-based reduced order model (pROM) takes an intrusive approach, that is, it is NOT equation-free. The pROM first represents the solution as a linear combincation of reduced basis. The reduced basis can be obtained by the POD, for example. Let's denote the reduced basis as $\\boldsymbol{\\Phi}\\in\\mathbb{R}^{n\\times r}$ and express the solution, $\\boldsymbol{u}\\in\\mathbb{R}^n$ as $$\\boldsymbol{u} = \\boldsymbol{u}_{\\text{ref}}+\\boldsymbol{\\Phi}\\hat{\\boldsymbol{u}},$$ where $\\hat{\\boldsymbol{u}} \\in \\mathbb{R}^r$ denotes the generalized coordinates with respect to the reduced basis. Then we substitute $\\boldsymbol{u}$ in the governing equation, say a nonlinear dynamical system governed by the following ordinary differential equations, $$\\frac{d\\boldsymbol{u}}{dt} = \\boldsymbol{f}(\\boldsymbol{u},t;\\boldsymbol{\\mu}),$$ to obtain the over-determined system, i.e., $$\\boldsymbol{\\Phi}\\frac{d\\hat{\\boldsymbol{u}}}{dt} = \\boldsymbol{f}(\\boldsymbol{u}_{\\text{ref}}+\\boldsymbol{\\Phi}\\hat{\\boldsymbol{u}},t;\\boldsymbol{\\mu}),$$ which has more equations than unknowns. Therefore, the system needs to be closed by a projection. Galerkin and Petrov-Galerking projections are popular. For example, the Galerkin projection multiplies both sides by $\\boldsymbol{\\Phi}^T$ and the system of equations become $$\\frac{d\\hat{\\boldsymbol{u}}}{dt} = \\boldsymbol{\\Phi}^T \\boldsymbol{f}(\\boldsymbol{u}_{\\text{ref}}+\\boldsymbol{\\Phi}\\hat{\\boldsymbol{u}},t;\\boldsymbol{\\mu})$$ By the way, the nonlinear term $\\boldsymbol{f}$ still scales with the full order model size and it needs to be updated every time its argument changes due to Newton step updates, for example. The hyper-reduction provides an efficient way of computing nonlinear terms by sampling an important subset. By the way, if $\\boldsymbol{f}$ is linear, then $\\boldsymbol{\\Phi}^T\\boldsymbol{f}$ can be pre-computed, so the hyper-reduction is not necessary. Hyper-reduction Hyper-reduction is essential to reduce the complexity of nonlinear terms in pROM. The most popular hyper-reduction technique is the discrete empirical interpolation method (DEIM). The DEIM approximates the nonlinear term with a gappy POD, i.e., it expresses the nonlinear term with a linear combination of the nonlinear term reduced basis, $\\boldsymbol{\\Phi}_{f}\\in\\mathbb{R}^{n\\times f}$: $$\\boldsymbol{f} \\approx \\boldsymbol{\\Phi}_f \\hat{\\boldsymbol{f}},$$ where $\\hat{\\boldsymbol{f}}\\in\\mathbb{R}^{f}$ is a generalized coordinate for the nonlinear term. The usual data for the nonlinear term basis, $\\boldsymbol{\\Phi}_{f}$ is snapshot of nonlinear term itself. Alternatively, it can be replaced by the solution basis (i.e., $\\boldsymbol{\\Phi}$ or slight modification of it) via the SNS method introduced in the following journal paper: Y. Choi, D. Coombs, R. Anderson, SNS: a solution-based nonlinear subspace method for time-dependent model order reduction . SIAM Journal on Scientific Computing , 42(2), A1116\u2013A1146, 2020 Then, we introduce a sampling matrix (in order words, a collocation matrix), $\\boldsymbol{Z}\\in\\mathbb{R}^{n\\times z}$, which selects a subset of the nonliear term, $\\boldsymbol{F}$. That is, each column of $\\boldsymbol{Z}$ is a column of the identity matrix, $\\boldsymbol{I} \\in \\mathbb{R}^{n\\times n}$. Combining the collocation matrix and the nonlinear basis, we solve the following least-squares problem to solve for the generalized coordinate, $\\hat{\\boldsymbol{f}}$: $$\\hat{\\boldsymbol{f}} = \\underset{\\boldsymbol{y}\\in{\\mathbb{R}^{f}}}{\\arg\\min} \\hspace{3pt} || \\boldsymbol{Z}^T\\boldsymbol{f} - \\boldsymbol{Z}^T\\boldsymbol{\\Phi}_f \\boldsymbol{y} ||_2^2$$ The solution to the least-squares problem is known to be $$\\hat{\\boldsymbol{f}} = (\\boldsymbol{Z}^T\\boldsymbol{\\Phi}_{f})^\\dagger \\boldsymbol{Z}^T\\boldsymbol{f}.$$ Note that $(\\boldsymbol{Z}^T\\boldsymbol{\\Phi}_{f})^\\dagger$ can be pre-computed once the indices for $\\boldsymbol{Z}$ and $\\boldsymbol{\\Phi}_f$ are known. Note also that you do not need to construct $\\boldsymbol{Z}$. You only need to sample selected rows of $\\boldsymbol{\\Phi}_f$ and do the pseudo-inversion. This is what we do in libROM. Also note that we only need to evaluate a subset of $\\boldsymbol{f}$ because of $\\boldsymbol{Z}^T$ in front of $\\boldsymbol{f}$. Parametric ROMs Whether it is intrusive or non-intrusive ROM, if the ROM can only reproduce the full order model simulation data with high accuracy, it is useless because the full order model solution is already available. In order for any ROMs to be useful, they must be able to predict the solution which is not generated yet. We call such a ROM parametric because it is able to predict the solution for a new parameter value. Two extreme types of parametric ROMs are global and local ROMs. Global ROMs The global ROMs collect simulation data over several sampled points in a given parameter space and use all of them as a whole, building a global reduced basis. The size of the reduced basis becomes larger as the number of samples increases. Therefore, the global ROM is only effective when a small number of samples are used. Local ROMs A local ROM is built with the simulation data corresponding only to one specific sample. Usually, several local ROMs are built for several sample points and either interpolation or trust-region is used to predict the solution at points which were not sampled. Greedy sampling algorithm The greedy sampling algorithm is a physics-informed sampling strategy to build a parametric ROM . The parametric ROM can be used to predict the solution of a new parameter point that has not been seen in the training phase. The greey algorithms follow the general procedure below: Define a parameter space Pick an initial point in the parameter space to build a ROM there (a good cancidiate initla point is either the centroid or one of end points) Evaluate error indicator of the current ROM (either global or local ROM) at $N$ random points within the parameter space Check if the maximum error indicator value is less than the desirable accuracy threshold If the answer to Step 4 is yes, then terminate the greedy process. If the answer to Step 4 is no, then collect the full order model simulation data at the maximum error indicator point and add them to update the ROM Go to Step 3. The success of the greedy algorithm depends on the error indicator . The error indicator must satisfy the following two criteria: Its value must have positive correlation with the relative error measure The evaluation of the error indicator must be computationally efficient Note that the error indicator plays a role of a proxy for the accuracy of the ROM. The most popular error indicator is residual-based, which we recommend you to use for your physical simulations. The general framework of the greedy algorithm is implemented in libROM. The example of the libROM usage case can be found for the Poisson problem at poisson_greedy.cpp . The corresponding tutorial page can be found here . Several variants of the greedy procedure described above is possible. For more detailed explanation about the greedy algorithm, we refer to the following jounral paper, where the greedy algorithm is described for the interpolated ROM in a matrix manifold: Y. Choi, G. Boncoraglio, S. Anderson, D. Amsallem, C. Farhat, Gradient-based constrained optimization using a database of linear reduced order models . Journal of Computational Physics , 423, 109787, 2020 We recommend another excellent paper for the greedy algorithm: A. Paul-Dubois-Taine, D. Amsallem, An adaptive and efficient greedy procedure for the optimal training of parametric reduced-order models . International Journal for Numerical Methods in Engineering , 102, p1262-1292, 2014 Open Source libROM is an open-source software, and can be freely used under the terms of the MIT and APACHE license.","title":"Features"},{"location":"features.html#features","text":"The goal of libROM is to provide high-performance scalable library for data-driven reduced order modeling.","title":"Features"},{"location":"features.html#proper-orthogonal-decomposition","text":"One of the core features in libROM is the ability to extract important modes from given physical simulation data. The proper othogonal decomposition (POD) is a popular method for compressing physical simulation data to obtain optimal \"reduced\" bases in the following sense: $$\\boldsymbol{\\Phi} =\\underset{\\boldsymbol{A}\\in\\mathbb{R}^{n\\times r}, \\boldsymbol{A}^T\\boldsymbol{A} = \\boldsymbol{I}_{r\\times r} }{\\arg\\min} || \\boldsymbol{U} - \\boldsymbol{A}\\boldsymbol{A}^T\\boldsymbol{U} ||_F^2, $$ where $\\boldsymbol{U}\\in\\mathbb{R}^{n\\times m}$ is simulation data and $\\boldsymbol{I}_{r\\times r} \\in \\mathbb{R}^{r\\times r}$ denotes an identity matrix. That is, the POD tries to find the orthogonal matrix, $\\boldsymbol{\\Phi}$, whose span minimizes the projection error in the Frobenius norm. The POD modes can be obtained in two equivalent ways: (i) eigenvalue decomposition and (ii) singular value decomposition (SVD). We take the latter approach, i.e., let's say the thin SVD of $\\boldsymbol{U}$ is given by $$\\boldsymbol{U} = \\boldsymbol{W\\Sigma V}^T.$$ Then the solution of the POD is given by taking the first $r$ columns of the left singular matrix, i.e., $\\boldsymbol{\\Phi} = [\\boldsymbol{w}_{1},\\ldots ,\\boldsymbol{w}_r]$, where $\\boldsymbol{w}_k$ is $k$th left singular vector, assuming that the singular value is written in the decreasing order.","title":"Proper orthogonal decomposition"},{"location":"features.html#efficient-data-collection","text":"High-fidelity physical simulations generate intensive data in its size, which makes the data collection process daunting. Therefore, the libROM aims to ease the difficulty associated with the intensive data size. The libROM can be directly integrated to the physics solver that generates the intensive simulation data. For example, if the physical simulation is time dependent, then each time step solution data can be feed into the libROM incrementally so that the singular value decomposition is efficiently updated in parallel. This approach is incremental SVD . There are other types of SVDs which exploits efficiency. The libROM provides following four SVDs: Static SVD incremental SVD randomized SVD space-time SVD","title":"Efficient data collection"},{"location":"features.html#static-svd","text":"The static SVD waits the libROM to collect all the simulation data. Once the snapshot matrix $\\boldsymbol{U}$ is formed, then the SVD is performed. Therefore, if the data size is big, this approach is not efficient and not recommended. However, because it gives the most accurate SVD results, it is ideal for a small problem.","title":"Static SVD"},{"location":"features.html#incremental-svd","text":"Unlike the static SVD, the incremental SVD does not wait. Instead, as the data comes in, the SVD is performed right away. Because the incremental SVD only needs to find out the effect of one additional simulation data vector to the previous SVD, the update can be done very efficiently without requiring much memory. Therefore, it is useful for large-scale problems. For the detailed explanation about the incremental SVD, we refer to the following journal papers: M. Brand, Incremental singular value decomposition of uncertain data with missing values , In European Conference on Computer Vision , p707-720, 2002 G. Oxberry, T. Kostova-Vassilevska, W. Arrighi, K. Chand, Limited-memory adaptive snapshot selection for proper orthogonal decomposition , International Journal for Numerical Methods in Engineering , 109(2), p198-217, 2016 H. Fareed, J.R. Singler, Error Analysis of an Incremental Proper Orthogonal Decomposition Algorithm for PDE Simulation Data , Journal of Computational and Applied Mathematics , 368, 112525, 2020","title":"Incremental SVD"},{"location":"features.html#randomized-svd","text":"Randomization can bring computational efficiency in computing SVDs. For example, consider that one needs to extract $p$ dominant modes from $n \\times m$ tall dense matrix, using SVD. The randomized SVD requires $\\mathcal{O}(nm\\log(p))$ floating-point operations, while the static SVD algorithm requires $\\mathcal{O}(nmp)$ flops. The randomized SVD that is implemented in libROM can be found in the following journal paper: N. Halko, P.G. Martinsson, J.A. Tropp, Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions . SIAM review , 53(2), p217-288, 2011","title":"Randomized SVD"},{"location":"features.html#space-time-svd","text":"For time dependent problems, one can reduce not only the spatial degrees of freedom, but also the temporal degrees of freedom by representing the space-time solution as a linear combination of a space-time reduced basis. The space-time reduced basis can be mathematically written as a Kronecker product of temporal and spatial bases. Fortunately, one can extract temporal as well as spatial reduced bases from one single SVD. The procedure is schematically depicted in the figure below: For the detailed explanation about the incremental SVD, we refer to the following three journal papers: Y. Kim, K. Wang, Y. Choi, Efficient space\u2013time reduced order model for linear dynamical systems in Python using less than 120 lines of code . Mathematics , 9(14), 1690, 2021 Y. Choi, P. Brown, W. Arrighi, R. Anderson, K. Huynh, Space\u2013time reduced order model for large-scale linear dynamical systems with application to boltzmann transport problems . Journal of Computational Physics , 424, 109845, 2021 Y. Choi, K. Carlberg, Space-time least-squares Petrov-Galerkin projection for nonlinear model reduction , SIAM Journal on Scientific Computing , 41(1), A26-A58, 2019","title":"Space-time SVD"},{"location":"features.html#dynamic-mode-decomposition","text":"The dynamic mode decomposition (DMD) provides a great way of finding an approximate locally linear dynamical system, $$ \\frac{d\\boldsymbol{u}}{dt} = \\mathcal{A}\\boldsymbol{u},$$ for a given nonlinear dynamical system, $$ \\frac{d\\boldsymbol{u}}{dt} = \\boldsymbol{f}(\\boldsymbol{u},t;\\boldsymbol{\\mu}),$$ with initial condition, $\\boldsymbol{u}_0$. It takes non-intrusive approach, i.e., equation-free method, so it is applicable even if there is only data, but no $\\boldsymbol{f}(\\boldsymbol{u},t;\\boldsymbol{\\mu})$. For example, let's say the discrete-time data are given as: $$\\boldsymbol{U} = [\\boldsymbol{u}_1,\\ldots,\\boldsymbol{u}_m],$$ where $\\boldsymbol{u}_k\\in\\mathbb{R}^n$ denotes solution at $t=k\\Delta t$. The DMD is trying to find the best $\\boldsymbol{A}$ such that $$\\boldsymbol{U}^+ = \\boldsymbol{A}\\boldsymbol{U}^-,$$ where $\\boldsymbol{U}^+ = [\\boldsymbol{u}_2,\\ldots,\\boldsymbol{u}_m]$ and $\\boldsymbol{U}^- = [\\boldsymbol{u}_1, \\ldots, \\boldsymbol{u}_{m-1}]$. The following procedure is taken to find the best $\\boldsymbol{A}$. Take the singular value decomposition (SVD) of $\\boldsymbol{U}^-$ $$\\boldsymbol{U}^- \\approx \\boldsymbol{W}\\boldsymbol{\\Omega}\\boldsymbol{V}^*,$$ where $*$ denotes the conjugate transpose, $\\boldsymbol{W}\\in\\mathbb{C}^{n\\times r}$, $\\boldsymbol{\\Sigma}\\in\\mathbb{C}^{r\\times r}$, $\\boldsymbol{V}\\in\\mathbb{C}^{m\\times r}$, and $r \\leq m$. Because $\\boldsymbol{U}^+ = \\boldsymbol{A}\\boldsymbol{U}^-$, using the pseudo-inverse of the approximate $\\boldsymbol{U}^-$, we have $$\\boldsymbol{A} \\approx \\tilde{\\boldsymbol{A}} = \\boldsymbol{U}^+\\boldsymbol{V}\\boldsymbol{\\Omega}^{-1}\\boldsymbol{W}^*$$ It is easier to deal with the reduced operator $\\tilde{\\boldsymbol{A}}_r$, which relates the discrete-time dynamic of reduced states: $$\\tilde{\\boldsymbol{u}}_{k+1} = \\tilde{\\boldsymbol{A}}_r\\tilde{\\boldsymbol{u}}_k,$$ where $\\boldsymbol{u}_k = \\boldsymbol{W} \\tilde{\\boldsymbol{u}}_k$ and $\\tilde{\\boldsymbol{A}}_r$ is defined as $$\\tilde{\\boldsymbol{A}}_r=\\boldsymbol{W}^*\\tilde{\\boldsymbol{A}}\\boldsymbol{W}$$ $$\\tilde{\\boldsymbol{A}}_r=\\boldsymbol{W}^*\\boldsymbol{U}^+\\boldsymbol{V}\\boldsymbol{\\Omega}^{-1}$$ Let the eigen-decomposition of $\\tilde{\\boldsymbol{A}}_r$ to be $$\\tilde{\\boldsymbol{A}}_r \\boldsymbol{X} = \\boldsymbol{\\Lambda}\\boldsymbol{X}$$ and set either $\\boldsymbol{\\Phi} = \\boldsymbol{W}\\boldsymbol{X}$ or $\\boldsymbol{\\Phi} = \\boldsymbol{U}^+ \\boldsymbol{V} \\boldsymbol{\\Omega}^{-1}\\boldsymbol{X}$, then the DMD solution at time, $t$, can be found as $$\\boldsymbol{u}(t) = \\boldsymbol{\\Phi}\\boldsymbol{\\Lambda}^{t/\\Delta t} \\boldsymbol{b}_0,$$ where $\\boldsymbol{b}_0 = \\boldsymbol{\\Phi}^\\dagger \\boldsymbol{u}_0$. For the detailed explanation about the DMD, we refer to the following book: J.N. Kutz, S.L. Brunton, B.W. Brunton, J.L. Proctor, Dynamic mode decomposition: data-driven modeling of complex systems . Society for Industrial and Applied Mathematics , 2016","title":"Dynamic Mode Decomposition"},{"location":"features.html#projection-based-reduced-order-model","text":"In contrast to the DMD, the projection-based reduced order model (pROM) takes an intrusive approach, that is, it is NOT equation-free. The pROM first represents the solution as a linear combincation of reduced basis. The reduced basis can be obtained by the POD, for example. Let's denote the reduced basis as $\\boldsymbol{\\Phi}\\in\\mathbb{R}^{n\\times r}$ and express the solution, $\\boldsymbol{u}\\in\\mathbb{R}^n$ as $$\\boldsymbol{u} = \\boldsymbol{u}_{\\text{ref}}+\\boldsymbol{\\Phi}\\hat{\\boldsymbol{u}},$$ where $\\hat{\\boldsymbol{u}} \\in \\mathbb{R}^r$ denotes the generalized coordinates with respect to the reduced basis. Then we substitute $\\boldsymbol{u}$ in the governing equation, say a nonlinear dynamical system governed by the following ordinary differential equations, $$\\frac{d\\boldsymbol{u}}{dt} = \\boldsymbol{f}(\\boldsymbol{u},t;\\boldsymbol{\\mu}),$$ to obtain the over-determined system, i.e., $$\\boldsymbol{\\Phi}\\frac{d\\hat{\\boldsymbol{u}}}{dt} = \\boldsymbol{f}(\\boldsymbol{u}_{\\text{ref}}+\\boldsymbol{\\Phi}\\hat{\\boldsymbol{u}},t;\\boldsymbol{\\mu}),$$ which has more equations than unknowns. Therefore, the system needs to be closed by a projection. Galerkin and Petrov-Galerking projections are popular. For example, the Galerkin projection multiplies both sides by $\\boldsymbol{\\Phi}^T$ and the system of equations become $$\\frac{d\\hat{\\boldsymbol{u}}}{dt} = \\boldsymbol{\\Phi}^T \\boldsymbol{f}(\\boldsymbol{u}_{\\text{ref}}+\\boldsymbol{\\Phi}\\hat{\\boldsymbol{u}},t;\\boldsymbol{\\mu})$$ By the way, the nonlinear term $\\boldsymbol{f}$ still scales with the full order model size and it needs to be updated every time its argument changes due to Newton step updates, for example. The hyper-reduction provides an efficient way of computing nonlinear terms by sampling an important subset. By the way, if $\\boldsymbol{f}$ is linear, then $\\boldsymbol{\\Phi}^T\\boldsymbol{f}$ can be pre-computed, so the hyper-reduction is not necessary.","title":"Projection-based reduced order model"},{"location":"features.html#hyper-reduction","text":"Hyper-reduction is essential to reduce the complexity of nonlinear terms in pROM. The most popular hyper-reduction technique is the discrete empirical interpolation method (DEIM). The DEIM approximates the nonlinear term with a gappy POD, i.e., it expresses the nonlinear term with a linear combination of the nonlinear term reduced basis, $\\boldsymbol{\\Phi}_{f}\\in\\mathbb{R}^{n\\times f}$: $$\\boldsymbol{f} \\approx \\boldsymbol{\\Phi}_f \\hat{\\boldsymbol{f}},$$ where $\\hat{\\boldsymbol{f}}\\in\\mathbb{R}^{f}$ is a generalized coordinate for the nonlinear term. The usual data for the nonlinear term basis, $\\boldsymbol{\\Phi}_{f}$ is snapshot of nonlinear term itself. Alternatively, it can be replaced by the solution basis (i.e., $\\boldsymbol{\\Phi}$ or slight modification of it) via the SNS method introduced in the following journal paper: Y. Choi, D. Coombs, R. Anderson, SNS: a solution-based nonlinear subspace method for time-dependent model order reduction . SIAM Journal on Scientific Computing , 42(2), A1116\u2013A1146, 2020 Then, we introduce a sampling matrix (in order words, a collocation matrix), $\\boldsymbol{Z}\\in\\mathbb{R}^{n\\times z}$, which selects a subset of the nonliear term, $\\boldsymbol{F}$. That is, each column of $\\boldsymbol{Z}$ is a column of the identity matrix, $\\boldsymbol{I} \\in \\mathbb{R}^{n\\times n}$. Combining the collocation matrix and the nonlinear basis, we solve the following least-squares problem to solve for the generalized coordinate, $\\hat{\\boldsymbol{f}}$: $$\\hat{\\boldsymbol{f}} = \\underset{\\boldsymbol{y}\\in{\\mathbb{R}^{f}}}{\\arg\\min} \\hspace{3pt} || \\boldsymbol{Z}^T\\boldsymbol{f} - \\boldsymbol{Z}^T\\boldsymbol{\\Phi}_f \\boldsymbol{y} ||_2^2$$ The solution to the least-squares problem is known to be $$\\hat{\\boldsymbol{f}} = (\\boldsymbol{Z}^T\\boldsymbol{\\Phi}_{f})^\\dagger \\boldsymbol{Z}^T\\boldsymbol{f}.$$ Note that $(\\boldsymbol{Z}^T\\boldsymbol{\\Phi}_{f})^\\dagger$ can be pre-computed once the indices for $\\boldsymbol{Z}$ and $\\boldsymbol{\\Phi}_f$ are known. Note also that you do not need to construct $\\boldsymbol{Z}$. You only need to sample selected rows of $\\boldsymbol{\\Phi}_f$ and do the pseudo-inversion. This is what we do in libROM. Also note that we only need to evaluate a subset of $\\boldsymbol{f}$ because of $\\boldsymbol{Z}^T$ in front of $\\boldsymbol{f}$.","title":"Hyper-reduction"},{"location":"features.html#parametric-roms","text":"Whether it is intrusive or non-intrusive ROM, if the ROM can only reproduce the full order model simulation data with high accuracy, it is useless because the full order model solution is already available. In order for any ROMs to be useful, they must be able to predict the solution which is not generated yet. We call such a ROM parametric because it is able to predict the solution for a new parameter value. Two extreme types of parametric ROMs are global and local ROMs.","title":"Parametric ROMs"},{"location":"features.html#global-roms","text":"The global ROMs collect simulation data over several sampled points in a given parameter space and use all of them as a whole, building a global reduced basis. The size of the reduced basis becomes larger as the number of samples increases. Therefore, the global ROM is only effective when a small number of samples are used.","title":"Global ROMs"},{"location":"features.html#local-roms","text":"A local ROM is built with the simulation data corresponding only to one specific sample. Usually, several local ROMs are built for several sample points and either interpolation or trust-region is used to predict the solution at points which were not sampled.","title":"Local ROMs"},{"location":"features.html#greedy-sampling-algorithm","text":"The greedy sampling algorithm is a physics-informed sampling strategy to build a parametric ROM . The parametric ROM can be used to predict the solution of a new parameter point that has not been seen in the training phase. The greey algorithms follow the general procedure below: Define a parameter space Pick an initial point in the parameter space to build a ROM there (a good cancidiate initla point is either the centroid or one of end points) Evaluate error indicator of the current ROM (either global or local ROM) at $N$ random points within the parameter space Check if the maximum error indicator value is less than the desirable accuracy threshold If the answer to Step 4 is yes, then terminate the greedy process. If the answer to Step 4 is no, then collect the full order model simulation data at the maximum error indicator point and add them to update the ROM Go to Step 3. The success of the greedy algorithm depends on the error indicator . The error indicator must satisfy the following two criteria: Its value must have positive correlation with the relative error measure The evaluation of the error indicator must be computationally efficient Note that the error indicator plays a role of a proxy for the accuracy of the ROM. The most popular error indicator is residual-based, which we recommend you to use for your physical simulations. The general framework of the greedy algorithm is implemented in libROM. The example of the libROM usage case can be found for the Poisson problem at poisson_greedy.cpp . The corresponding tutorial page can be found here . Several variants of the greedy procedure described above is possible. For more detailed explanation about the greedy algorithm, we refer to the following jounral paper, where the greedy algorithm is described for the interpolated ROM in a matrix manifold: Y. Choi, G. Boncoraglio, S. Anderson, D. Amsallem, C. Farhat, Gradient-based constrained optimization using a database of linear reduced order models . Journal of Computational Physics , 423, 109787, 2020 We recommend another excellent paper for the greedy algorithm: A. Paul-Dubois-Taine, D. Amsallem, An adaptive and efficient greedy procedure for the optimal training of parametric reduced-order models . International Journal for Numerical Methods in Engineering , 102, p1262-1292, 2014","title":"Greedy sampling algorithm"},{"location":"features.html#open-source","text":"libROM is an open-source software, and can be freely used under the terms of the MIT and APACHE license.","title":"Open Source"},{"location":"gallery.html","text":"Gallery This page collects screenshots from various ROM simulations based on libROM. Sedov blast simulated with Laghos and accelerated by libROM . Visualization with VisIt . 2D Gresho vortex simulated with Laghos and accelerated by libROM . Visualization with VisIt . 2D Nonlinear diffusion problem simulated with MFEM and accelerated by libROM . Visualization with VisIt . 3D Crooked pipe for nonlinear radiation diffusion problem simulated with BLAST and accelerated by libROM . Visualization with VisIt . 2D Rayleigh-Taylor instability problem simulated with Laghos and accelerated by libROM . Visualization with VisIt . Triple-point problem simulated with Laghos and accelerated by libROM . Visualization with VisIt . An optimal design for the wind turbine blade solved with LiDO and accelerated by libROM . Visualization with VisIt . 3D Boltzmann particle transport problem solved with ARDRA and accelerated by libROM . Visualization with VisIt . 3D Boltzmann particle transport problem solved with ARDRA and accelerated by libROM . Visualization with VisIt . Taylor-Green vortex problem simulated with Laghos and accelerated by libROM . Visualization with VisIt . Stress-constrained optimal L-bracket problem solved by LiDO and accelerated by libROM . Visualization with VisIt . 3D cantilever beam problem solved by LiDO and accelerated by libROM . Visualization with VisIt . 2D vortex shedding cylinder problem solved by SU2 and its reduced basis by libROM below. Click image below for zoomed-in picture. Visualization with ParaView . 2D NACA0012 airfoil problem solved by SU2 and its reduced basis by libROM . Click image above for zoomed-in picture. Visualization with MATLAB .","title":"Gallery"},{"location":"gallery.html#gallery","text":"This page collects screenshots from various ROM simulations based on libROM. Sedov blast simulated with Laghos and accelerated by libROM . Visualization with VisIt . 2D Gresho vortex simulated with Laghos and accelerated by libROM . Visualization with VisIt . 2D Nonlinear diffusion problem simulated with MFEM and accelerated by libROM . Visualization with VisIt . 3D Crooked pipe for nonlinear radiation diffusion problem simulated with BLAST and accelerated by libROM . Visualization with VisIt . 2D Rayleigh-Taylor instability problem simulated with Laghos and accelerated by libROM . Visualization with VisIt . Triple-point problem simulated with Laghos and accelerated by libROM . Visualization with VisIt . An optimal design for the wind turbine blade solved with LiDO and accelerated by libROM . Visualization with VisIt . 3D Boltzmann particle transport problem solved with ARDRA and accelerated by libROM . Visualization with VisIt . 3D Boltzmann particle transport problem solved with ARDRA and accelerated by libROM . Visualization with VisIt . Taylor-Green vortex problem simulated with Laghos and accelerated by libROM . Visualization with VisIt . Stress-constrained optimal L-bracket problem solved by LiDO and accelerated by libROM . Visualization with VisIt . 3D cantilever beam problem solved by LiDO and accelerated by libROM . Visualization with VisIt . 2D vortex shedding cylinder problem solved by SU2 and its reduced basis by libROM below. Click image below for zoomed-in picture. Visualization with ParaView . 2D NACA0012 airfoil problem solved by SU2 and its reduced basis by libROM . Click image above for zoomed-in picture. Visualization with MATLAB .","title":"Gallery"},{"location":"news.html","text":"All News Updates Date Message Nov 19, 2021 NM-ROM paper is published in JCP. Free download is available for 50 days. Nov 10, 2021 Laghos ROM is published at CMAME. Free download is available for 50 days. Oct 1, 2021 Domain decomposition ROM paper is published in CMAME Sep XX, 2021 First version of libROM webpage is launched July 19, 2021 spacetimeROM-Python paper is published in Mathematics Apr 23, 2021 LaghosROM arXiv preprint is available Jan 1, 2021 spacetimeROM paper is published in Journal of Computational Physics","title":"_News"},{"location":"news.html#all-news-updates","text":"Date Message Nov 19, 2021 NM-ROM paper is published in JCP. Free download is available for 50 days. Nov 10, 2021 Laghos ROM is published at CMAME. Free download is available for 50 days. Oct 1, 2021 Domain decomposition ROM paper is published in CMAME Sep XX, 2021 First version of libROM webpage is launched July 19, 2021 spacetimeROM-Python paper is published in Mathematics Apr 23, 2021 LaghosROM arXiv preprint is available Jan 1, 2021 spacetimeROM paper is published in Journal of Computational Physics","title":"All News Updates"},{"location":"poisson.html","text":"MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}}); Poisson equation The main code for this tutorial can be found in poisson.cpp , which accelerates the Poisson problem $$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. The numerical results can be found in Poisson Problem . libROM assumes that you have a physics code, such as MFEM , SU2 , and Laghos . Then, libROM can be integrated into the physics code to build ROM to accelerate physics simulation. For example, see numerical results in Examples and Gallery . This tutorial illustrates how various libROM objects and functions can be used to collect simulation data, build reduced basis, and construct reduced order model operator to accelerate and predict a target physics simulation. The following tutorials are available: Tutorial 1 : offline , Take and write simulation data with libROM. Tutorial 2 : merge , Collect simulation data and build a reduced basis. Tutorial 3 : online , Build a ROM operator, solve the ROM system, and restore the full order state. Building Follow the building page to build the libROM library. You must build it with -m option to build MFEM library together. ~/libROM> ./scripts/compile.sh -m Tutorial 1 This tutorial demonstrates how to collect simulation data with libROM. The important object is BasisGenerator , which collects simulation data and computes reduced basis, using various singular value decomposition ( SVD ) algorithms, e.g., incremental SVD and static SVD . The incremental SVD is useful for time-dependent problems. Because the Poisson problem is a time-independent problem, we will focus on the usage of the static SVD. The definition of BasisGenerator class can be found in BasisGenerator.h . You must include BasisGenerator.h in your physics code where the simulation data is generated. For example, BasisGenerator.h is included in Line 32 of poisson.cpp for Poisson Problem . #include \"BasisGenerator.h\" A BasisGenerator pointer is defined in Line 204 and the pointer is initiated in Line 212 The BasisGenerator requires four inputs to initialize, i.e., Options , boolean variable, string, and Database::formats. The object, Options, sets various options for the BasisGenerator, such as the basis dimension and singular value tolerance. The boolean variable determines if the incremental or static SVD will be used. For this tutorial, we choose the static SVD, so the boolean variable must be false. Finally, the string input specifies the name of the basis file and Database::formats specifies the file format for the basis file. The default format is Database::HDF5. The detailed description for inputs for Options and BasisGenerator can be found in Options.h and BasisGenerator.h . The specific inputs used for the Poisson problem can be found in Lines 197--201 . Now, the instantiated BasisGenerator, i.e., generator , collects the simulation data once it is available. The Poisson problem generates the solution, $X$, in Line 296 and it is collected in the generator in Line 301 . The member function, writeSnapshot simply writes the solution data in the specified HDF5 file. Make sure that the pointers, generator and options , are deleted after done with sampling. This completes the libROM data collection implementation, which corresponds to the offline phase in the Poisson problem . If you execute the following command: poisson -offline -f 1.0 -id 0 then you should see the HDF5 snapshot output file, i.e., basis0_snapshot.000000 . The command line options above include -offline that indicates the offline phase, -f 1.0 sets the frequency variable $\\kappa=1.0$ (see the Poisson problem for the description of the frequency variable), and -id 0 labels the snapshot index. The visualization of the solution can be done either with VisIt or GLVis. For example, the VisIt shows the following solution contour for this specific simulation: Please execute the following commands: poisson -offline -f 1.1 -id 1 poisson -offline -f 1.2 -id 2 whose solution contour corresponds, respectively, to: Tutorial 2 Once the simulation data are collected within libROM basis files, they can be merged to form a reduced basis. This process is called the merge phase . It is implemented in Lines 218--236 . As in Tutorial 1 , the objects, Options and BasisGenerator must be defined (see Lines 220--221 . The generator iterates over the individual HDF5 snapshot file and loads them all (see Lines 222--226 ). The member function endSamples in Line 227 computes the reduced basis. Again make sure to delete the pointers, i.e., generator and options . For exammple, the following command line option runs the merge phase: poisson -merge -ns 3 The command line option, -merge , invokes the merges phase and -ns 3 option indicates that there are three different snapshot files. The merge phase reads the three snapshot files, i.e., basis0_snapshot.000000 , basis1_snapshot.000000 , and basis2_snapshot.000000 , which were generated in Tutorial 1 , and forms a reduced basis and stores it in the HDF5 basis file, i.e., basis.000000 . Tutorial 3 The online phase builds ROM operators, solves the ROM system, and restores the full order states for a new parameter value. This tutorial demonstrates these three different actions for the frequency value, $\\kappa = 1.15$. Lines 311--312 implements the step of reading a basis file. The BasisReader object reads the basis file, using member function, getSpatialBasis , which returns a Matrix object in libROM. The number of rows and columns of the reduced basis can be obtained through the member functions of the Matrix class, i.e., numRows and numColumns , respectively. Line 318 defines a MFEM DenseMatrix that holds the transpose of the reduced basis matrix. This must be understood as the transpose because libROM stores the matrix row-wise. The MFEM matrix is defined to form a reduced system operator, whose process is implemented in Lines 321--332 . Then the reduced system operator is inverted at Line 333 . The reduced right-hand-side is formed by multiplying the reduced basis transpose to the full order model right-hand-side vector, $B$ at Line 327 . Line 338 solves the reduced system of equation. Line 342 restores the corresponding full order state by multipling the reduced solution by the reduced basis. The command line options that executes the online phase described above are poisson -online -f 1.15 where -online option invokes the online phase and -f 1.15 sets the frequency value $\\kappa = 1.15$. This particular example ROM accelerates the physics simulation by $7.5$ and achieves the relative error, $6.4e-4$, with respect to the corresponding full order model solution.","title":"Poisson equation"},{"location":"poisson.html#poisson-equation","text":"The main code for this tutorial can be found in poisson.cpp , which accelerates the Poisson problem $$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. The numerical results can be found in Poisson Problem . libROM assumes that you have a physics code, such as MFEM , SU2 , and Laghos . Then, libROM can be integrated into the physics code to build ROM to accelerate physics simulation. For example, see numerical results in Examples and Gallery . This tutorial illustrates how various libROM objects and functions can be used to collect simulation data, build reduced basis, and construct reduced order model operator to accelerate and predict a target physics simulation. The following tutorials are available: Tutorial 1 : offline , Take and write simulation data with libROM. Tutorial 2 : merge , Collect simulation data and build a reduced basis. Tutorial 3 : online , Build a ROM operator, solve the ROM system, and restore the full order state.","title":"Poisson equation"},{"location":"poisson.html#building","text":"Follow the building page to build the libROM library. You must build it with -m option to build MFEM library together. ~/libROM> ./scripts/compile.sh -m","title":"Building"},{"location":"poisson.html#tutorial-1","text":"This tutorial demonstrates how to collect simulation data with libROM. The important object is BasisGenerator , which collects simulation data and computes reduced basis, using various singular value decomposition ( SVD ) algorithms, e.g., incremental SVD and static SVD . The incremental SVD is useful for time-dependent problems. Because the Poisson problem is a time-independent problem, we will focus on the usage of the static SVD. The definition of BasisGenerator class can be found in BasisGenerator.h . You must include BasisGenerator.h in your physics code where the simulation data is generated. For example, BasisGenerator.h is included in Line 32 of poisson.cpp for Poisson Problem . #include \"BasisGenerator.h\" A BasisGenerator pointer is defined in Line 204 and the pointer is initiated in Line 212 The BasisGenerator requires four inputs to initialize, i.e., Options , boolean variable, string, and Database::formats. The object, Options, sets various options for the BasisGenerator, such as the basis dimension and singular value tolerance. The boolean variable determines if the incremental or static SVD will be used. For this tutorial, we choose the static SVD, so the boolean variable must be false. Finally, the string input specifies the name of the basis file and Database::formats specifies the file format for the basis file. The default format is Database::HDF5. The detailed description for inputs for Options and BasisGenerator can be found in Options.h and BasisGenerator.h . The specific inputs used for the Poisson problem can be found in Lines 197--201 . Now, the instantiated BasisGenerator, i.e., generator , collects the simulation data once it is available. The Poisson problem generates the solution, $X$, in Line 296 and it is collected in the generator in Line 301 . The member function, writeSnapshot simply writes the solution data in the specified HDF5 file. Make sure that the pointers, generator and options , are deleted after done with sampling. This completes the libROM data collection implementation, which corresponds to the offline phase in the Poisson problem . If you execute the following command: poisson -offline -f 1.0 -id 0 then you should see the HDF5 snapshot output file, i.e., basis0_snapshot.000000 . The command line options above include -offline that indicates the offline phase, -f 1.0 sets the frequency variable $\\kappa=1.0$ (see the Poisson problem for the description of the frequency variable), and -id 0 labels the snapshot index. The visualization of the solution can be done either with VisIt or GLVis. For example, the VisIt shows the following solution contour for this specific simulation: Please execute the following commands: poisson -offline -f 1.1 -id 1 poisson -offline -f 1.2 -id 2 whose solution contour corresponds, respectively, to:","title":"Tutorial 1"},{"location":"poisson.html#tutorial-2","text":"Once the simulation data are collected within libROM basis files, they can be merged to form a reduced basis. This process is called the merge phase . It is implemented in Lines 218--236 . As in Tutorial 1 , the objects, Options and BasisGenerator must be defined (see Lines 220--221 . The generator iterates over the individual HDF5 snapshot file and loads them all (see Lines 222--226 ). The member function endSamples in Line 227 computes the reduced basis. Again make sure to delete the pointers, i.e., generator and options . For exammple, the following command line option runs the merge phase: poisson -merge -ns 3 The command line option, -merge , invokes the merges phase and -ns 3 option indicates that there are three different snapshot files. The merge phase reads the three snapshot files, i.e., basis0_snapshot.000000 , basis1_snapshot.000000 , and basis2_snapshot.000000 , which were generated in Tutorial 1 , and forms a reduced basis and stores it in the HDF5 basis file, i.e., basis.000000 .","title":"Tutorial 2"},{"location":"poisson.html#tutorial-3","text":"The online phase builds ROM operators, solves the ROM system, and restores the full order states for a new parameter value. This tutorial demonstrates these three different actions for the frequency value, $\\kappa = 1.15$. Lines 311--312 implements the step of reading a basis file. The BasisReader object reads the basis file, using member function, getSpatialBasis , which returns a Matrix object in libROM. The number of rows and columns of the reduced basis can be obtained through the member functions of the Matrix class, i.e., numRows and numColumns , respectively. Line 318 defines a MFEM DenseMatrix that holds the transpose of the reduced basis matrix. This must be understood as the transpose because libROM stores the matrix row-wise. The MFEM matrix is defined to form a reduced system operator, whose process is implemented in Lines 321--332 . Then the reduced system operator is inverted at Line 333 . The reduced right-hand-side is formed by multiplying the reduced basis transpose to the full order model right-hand-side vector, $B$ at Line 327 . Line 338 solves the reduced system of equation. Line 342 restores the corresponding full order state by multipling the reduced solution by the reduced basis. The command line options that executes the online phase described above are poisson -online -f 1.15 where -online option invokes the online phase and -f 1.15 sets the frequency value $\\kappa = 1.15$. This particular example ROM accelerates the physics simulation by $7.5$ and achieves the relative error, $6.4e-4$, with respect to the corresponding full order model solution.","title":"Tutorial 3"},{"location":"poisson_greedy.html","text":"MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}}); Greedy for Poisson equation The main code for this tutorial can be found at poisson_greedy.cpp , which demonstrates how to use libROM to execute greedy procedure for the ROM of the Poisson problem introduced in the Poisson equation tutorial . For the recap, the general procedure of the greedy algorithm follows: Define a parameter space Pick an initial point in the parameter space to build a ROM there (a good cancidiate initla point is either the centroid or one of end points) Evaluate error indicator of the current ROM (either global or local ROM) at $N$ random points within the parameter space Check if the maximum error indicator value is less than the desirable accuracy threshold If the answer to Step 4 is yes, then terminate the greedy process. If the answer to Step 4 is no, then collect the full order model simulation data at the maximum error indicator point and add them to update the ROM Go to Step 3. As in the Poisson equation tutorial , we choose to vary the frequency $\\kappa$ as parameter. First, we define the parameter space to be from $0.5$ to $3$, which is larger than the one used in Poisson equation tutorial . You can try the following command line options to run the greedy procedure: ./poisson_greedy -build_database -greedy-param-min 0.5 -greedy-param-max 3 -greedy-param-size 40 -greedysubsize 10 -greedyconvsize 20 -greedyrelerrortol 0.01 The lower and upper bounds of the parameter are determined by the options, -greedy-param-min and -greedy-param-max , respectively. The option -greedy-param-size specifies the total number of random sample points within the parameter space for the whole greedy procedure. The option -greedysubsize sets the number of sub-sample points, where the error indicator is evaluated at every greedy iterations. The option -greedyconvsize sets the number of convergence-sample points on which the error indicator is checked and the termination of the greedy algorithm is determined if the error indicators are below the convergence threshold after the error indicator tests on the sub-sample points have been passed. Finally, -greedyrelerrortol sets the desirable relative error for the greedy algorithm to achieve. The core class of the libROM for the greedy procedure is GreedyParameterPointSampler , which is defined here in poisson_greedy.cpp . The GreedyParameterPointSampler generates sampling points within a given parameter space. The class has two sub-classes, i.e., GreedyParameterPointPreDefinedSampler and GreedyParameterPointRandomSampler . The GreedyParameterPointPreDefinedSampler generates pre-defined sampling points, e.g., a tensor product sampling points, while the GreedyParameterPointRandomSampler generates random sampling points, e.g., Latin hyper-cube sampling points. The GreedyParameterPointSampler also does book-keeping job of at which sampling point to evaluate the error indicator, when to move onto the next greedy step, and which sampling point has the maximum error indicator value. Just to be clear, the libROM does not do everything for you. For example, the error indicator must be defined in the physics solver. For the Poisson example, the residual-based error indicator is defined at Lines 519-527 . Once the greedy procedure completes, the log file, called poisson_greedy_algorithm_log.txt , is generated to show the progress of the greedy procedure and the final parameter points on which the global ROM was built. For example, you will see the following block at the end of the file, indicating the final parameter points on which the global ROM is built. Sampled Parameter Points [ 0.591166 ] [ 0.844964 ] [ 1.066678 ] [ 1.353370 ] [ 1.710334 ] [ 1.992794 ] [ 2.568171 ] [ 2.985638 ] Because we set the -greedyrelerrortol to be 0.01, the global ROM built through the greedy procedure must be able to predict a solution with a relative error less than 1$\\%$ for any points in the parameter space. Indeed, let's try to predict the solution at $\\kappa = 2.2$, which was not one of the final parameter points. Let's first generate the full order model solution with the following command line option: ./poisson_greedy -offline -f 2.2 This full order model solution will be used to compute the relative error for the ROM solution. The ROM solution can be obtained by the following command line option: ./poisson_greedy -use_database -online -f 2.2 Indeed, the relative error of 0.00167671 is achieved","title":"Greedy for Poisson"},{"location":"poisson_greedy.html#greedy-for-poisson-equation","text":"The main code for this tutorial can be found at poisson_greedy.cpp , which demonstrates how to use libROM to execute greedy procedure for the ROM of the Poisson problem introduced in the Poisson equation tutorial . For the recap, the general procedure of the greedy algorithm follows: Define a parameter space Pick an initial point in the parameter space to build a ROM there (a good cancidiate initla point is either the centroid or one of end points) Evaluate error indicator of the current ROM (either global or local ROM) at $N$ random points within the parameter space Check if the maximum error indicator value is less than the desirable accuracy threshold If the answer to Step 4 is yes, then terminate the greedy process. If the answer to Step 4 is no, then collect the full order model simulation data at the maximum error indicator point and add them to update the ROM Go to Step 3. As in the Poisson equation tutorial , we choose to vary the frequency $\\kappa$ as parameter. First, we define the parameter space to be from $0.5$ to $3$, which is larger than the one used in Poisson equation tutorial . You can try the following command line options to run the greedy procedure: ./poisson_greedy -build_database -greedy-param-min 0.5 -greedy-param-max 3 -greedy-param-size 40 -greedysubsize 10 -greedyconvsize 20 -greedyrelerrortol 0.01 The lower and upper bounds of the parameter are determined by the options, -greedy-param-min and -greedy-param-max , respectively. The option -greedy-param-size specifies the total number of random sample points within the parameter space for the whole greedy procedure. The option -greedysubsize sets the number of sub-sample points, where the error indicator is evaluated at every greedy iterations. The option -greedyconvsize sets the number of convergence-sample points on which the error indicator is checked and the termination of the greedy algorithm is determined if the error indicators are below the convergence threshold after the error indicator tests on the sub-sample points have been passed. Finally, -greedyrelerrortol sets the desirable relative error for the greedy algorithm to achieve. The core class of the libROM for the greedy procedure is GreedyParameterPointSampler , which is defined here in poisson_greedy.cpp . The GreedyParameterPointSampler generates sampling points within a given parameter space. The class has two sub-classes, i.e., GreedyParameterPointPreDefinedSampler and GreedyParameterPointRandomSampler . The GreedyParameterPointPreDefinedSampler generates pre-defined sampling points, e.g., a tensor product sampling points, while the GreedyParameterPointRandomSampler generates random sampling points, e.g., Latin hyper-cube sampling points. The GreedyParameterPointSampler also does book-keeping job of at which sampling point to evaluate the error indicator, when to move onto the next greedy step, and which sampling point has the maximum error indicator value. Just to be clear, the libROM does not do everything for you. For example, the error indicator must be defined in the physics solver. For the Poisson example, the residual-based error indicator is defined at Lines 519-527 . Once the greedy procedure completes, the log file, called poisson_greedy_algorithm_log.txt , is generated to show the progress of the greedy procedure and the final parameter points on which the global ROM was built. For example, you will see the following block at the end of the file, indicating the final parameter points on which the global ROM is built. Sampled Parameter Points [ 0.591166 ] [ 0.844964 ] [ 1.066678 ] [ 1.353370 ] [ 1.710334 ] [ 1.992794 ] [ 2.568171 ] [ 2.985638 ] Because we set the -greedyrelerrortol to be 0.01, the global ROM built through the greedy procedure must be able to predict a solution with a relative error less than 1$\\%$ for any points in the parameter space. Indeed, let's try to predict the solution at $\\kappa = 2.2$, which was not one of the final parameter points. Let's first generate the full order model solution with the following command line option: ./poisson_greedy -offline -f 2.2 This full order model solution will be used to compute the relative error for the ROM solution. The ROM solution can be obtained by the following command line option: ./poisson_greedy -use_database -online -f 2.2 Indeed, the relative error of 0.00167671 is achieved","title":"Greedy for Poisson equation"},{"location":"publications.html","text":"Publications 2021 Y. Kim, Y. Choi, D. Widemann, T. Zohdi, A fast and accurate physics-informed neural network reduced order model with shallow masked autoencoder accepted for publication at Journal of Computational Physics , arXiv:2009.11990, 2021 D. Copeland, S.W. Cheung, K. Huynh, Y. Choi, Reduced order models for Lagrangian hydrodynamics , Computer Methods in Applied Mechanics and Engineering , Volume 388, 114259, 2021 C. Hoang, Y. Choi, K. Carlberg, Domain-decomposition least-squares Petrov-Galerkin (DD-LSPG) nonlinear model reduction , Computer Methods in Applied Mechanics and Engineering , Volume 384, 113997, 2021 S. McBane, Y. Choi, Component-wise reduced order model lattice-type structure design , Computer Methods in Applied Mechanics and Engineering , 381, 113813, 2021 . Y. Kim, K.M. Wang, Y. Choi, Efficient space-time reduced order model for linear dynamical systems in Python using less than 120 lines of code , Mathematics , 9(14), 1690, 2021 Y. Choi, P. Brown, W. Arrighi, R. Anderson, K. Huynh, Space-time reduced order model for large-scale linear dynamical systems with application to Boltzmann transport problems , Journal of Computational Physics , 424, 109845, 2021 . Also available as arXiv:1910.01260 . 2020 Y. Choi, D. Coombs, R. Anderson, SNS: A Solution-based nonlinear subspace method for time-dependent model order reduction , SIAM Journal on Scientific Computing , 42(2), A1116-A1147, 2020 Y. Choi, G. Boncoraglio, S. Anderson, D. Amsallem, C. Farhat Gradient-based constrained optimization using a database of linear reduced order models , Journal of Computational Physics , 423, 109787, 2020 . Also available as arXiv:1506.07849 . Y. Kim, Y. Choi, D. Widemann, T. Zohdi, Efficient nonlinear manifold reduced order model Workshop on machine learning for engineering modeling, simulation and design @ NeurIPS 2020 , 2020 . Also available as arXiv:2011.07727 2019 and earlier Y. Choi, K. Carlberg, Space-time least-squares Petrov-Galerkin projection for nonlinear model reduction , SIAM Journal on Scientific Computing , 41(1), A26-A58, 2019 Y. Choi, G. Oxberry, D. Whit, T. Kirchdoerfer, Accelerating design optimization using reduced order models , arXiv preprint , arXiv:1909.11320, 2019 K. Carlberg, Y. Choi, S. Sargsyan, Conservative model reduction for finite-volume models , Journal of Computational Physics , 371, p280-314, 2018 G. Oxberry, T. Kostova-Vassilevska, W. Arrighi, K. Chand, Limited-memory adaptive snapshot selection for proper orthogonal decomposition , International Journal of Numerical Methods in Engineering , 109(2), p198-217, 2016 D. Amsallem, M. Zahr, Y. Choi, C. Farhat, Design optimization using hyper-reduced-order models , Structural and Multidisciplinary Optimization , 51, p919-940, 2015 MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Publications"},{"location":"publications.html#publications","text":"","title":"Publications"},{"location":"publications.html#2021","text":"Y. Kim, Y. Choi, D. Widemann, T. Zohdi, A fast and accurate physics-informed neural network reduced order model with shallow masked autoencoder accepted for publication at Journal of Computational Physics , arXiv:2009.11990, 2021 D. Copeland, S.W. Cheung, K. Huynh, Y. Choi, Reduced order models for Lagrangian hydrodynamics , Computer Methods in Applied Mechanics and Engineering , Volume 388, 114259, 2021 C. Hoang, Y. Choi, K. Carlberg, Domain-decomposition least-squares Petrov-Galerkin (DD-LSPG) nonlinear model reduction , Computer Methods in Applied Mechanics and Engineering , Volume 384, 113997, 2021 S. McBane, Y. Choi, Component-wise reduced order model lattice-type structure design , Computer Methods in Applied Mechanics and Engineering , 381, 113813, 2021 . Y. Kim, K.M. Wang, Y. Choi, Efficient space-time reduced order model for linear dynamical systems in Python using less than 120 lines of code , Mathematics , 9(14), 1690, 2021 Y. Choi, P. Brown, W. Arrighi, R. Anderson, K. Huynh, Space-time reduced order model for large-scale linear dynamical systems with application to Boltzmann transport problems , Journal of Computational Physics , 424, 109845, 2021 . Also available as arXiv:1910.01260 .","title":"2021"},{"location":"publications.html#2020","text":"Y. Choi, D. Coombs, R. Anderson, SNS: A Solution-based nonlinear subspace method for time-dependent model order reduction , SIAM Journal on Scientific Computing , 42(2), A1116-A1147, 2020 Y. Choi, G. Boncoraglio, S. Anderson, D. Amsallem, C. Farhat Gradient-based constrained optimization using a database of linear reduced order models , Journal of Computational Physics , 423, 109787, 2020 . Also available as arXiv:1506.07849 . Y. Kim, Y. Choi, D. Widemann, T. Zohdi, Efficient nonlinear manifold reduced order model Workshop on machine learning for engineering modeling, simulation and design @ NeurIPS 2020 , 2020 . Also available as arXiv:2011.07727","title":"2020"},{"location":"publications.html#2019-and-earlier","text":"Y. Choi, K. Carlberg, Space-time least-squares Petrov-Galerkin projection for nonlinear model reduction , SIAM Journal on Scientific Computing , 41(1), A26-A58, 2019 Y. Choi, G. Oxberry, D. Whit, T. Kirchdoerfer, Accelerating design optimization using reduced order models , arXiv preprint , arXiv:1909.11320, 2019 K. Carlberg, Y. Choi, S. Sargsyan, Conservative model reduction for finite-volume models , Journal of Computational Physics , 371, p280-314, 2018 G. Oxberry, T. Kostova-Vassilevska, W. Arrighi, K. Chand, Limited-memory adaptive snapshot selection for proper orthogonal decomposition , International Journal of Numerical Methods in Engineering , 109(2), p198-217, 2016 D. Amsallem, M. Zahr, Y. Choi, C. Farhat, Design optimization using hyper-reduced-order models , Structural and Multidisciplinary Optimization , 51, p919-940, 2015 MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"2019 and earlier"},{"location":"rom.html","text":"Projection-based Reduced Order Model The reduced order models are achieved by applying data-driven model order reduction techniques to high-fidelity physics models, typically represented by partial differential equations (PDEs). There is a large body of literature on reduced order models, including the following excellent books: Certified reduced basis methods for parametrized partial differential equations by Jan S. Hesthaven and Gianluigi Rozza and Benjamin Stamm Model reduction of parametrized systems by Peter Benner and Mario Ohlberger and Anthony T. Patera and Gianluigi Rozza and Karsten Urban Reduced-order modeling (ROM) for simulation and optimization by Winfried Keiper and Anja Milde and Stefan Volkwein Approximation of large-scale dynamical systems by Athanasios C. Antoulas Machine learning, low-rank approximations and reduced order modeling in computational mechanics by Felix Fritzen and David Ryckelynck Machine learning for model order reduction by Khaled Salah Mohamed Reduced order methods for modeling and computational reduction by Alfio Quarteroni and Gianluigi Rozza The successful reduced order model development depends on many factors: Good quality and quantity of data Optimal and scalable data reduction schemes Optimal projection methods Efficient hyper-reduction for nonlinear reduction Sampling algorithms The libROM is designed to provide useful and scalable identify the low-rank approximation be lightweight, general and highly scalable reduced order model toolkit that provides the building blocks for developing finite element algorithms in a manner similar to that of MATLAB for linear algebra methods. The success measure for a reduced order model: speed-up accuracy differentiability verifiability predictability Some of the C++ classes for the finite element realizations of these PDE-level concepts in libROM are described below.","title":"Projection-based Reduced Order Model"},{"location":"rom.html#projection-based-reduced-order-model","text":"The reduced order models are achieved by applying data-driven model order reduction techniques to high-fidelity physics models, typically represented by partial differential equations (PDEs). There is a large body of literature on reduced order models, including the following excellent books: Certified reduced basis methods for parametrized partial differential equations by Jan S. Hesthaven and Gianluigi Rozza and Benjamin Stamm Model reduction of parametrized systems by Peter Benner and Mario Ohlberger and Anthony T. Patera and Gianluigi Rozza and Karsten Urban Reduced-order modeling (ROM) for simulation and optimization by Winfried Keiper and Anja Milde and Stefan Volkwein Approximation of large-scale dynamical systems by Athanasios C. Antoulas Machine learning, low-rank approximations and reduced order modeling in computational mechanics by Felix Fritzen and David Ryckelynck Machine learning for model order reduction by Khaled Salah Mohamed Reduced order methods for modeling and computational reduction by Alfio Quarteroni and Gianluigi Rozza The successful reduced order model development depends on many factors: Good quality and quantity of data Optimal and scalable data reduction schemes Optimal projection methods Efficient hyper-reduction for nonlinear reduction Sampling algorithms The libROM is designed to provide useful and scalable identify the low-rank approximation be lightweight, general and highly scalable reduced order model toolkit that provides the building blocks for developing finite element algorithms in a manner similar to that of MATLAB for linear algebra methods. The success measure for a reduced order model: speed-up accuracy differentiability verifiability predictability Some of the C++ classes for the finite element realizations of these PDE-level concepts in libROM are described below.","title":"Projection-based Reduced Order Model"}]}