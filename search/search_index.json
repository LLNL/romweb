{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"libROM is a free , lightweight , scalable C++ library for data-driven physical simulation methods. It is the main tool box that the reduced order modeling team at LLNL uses to develop efficient model order reduction techniques and physics-constrained data-driven methods . We try to collect any useful reduced order model routines, which are separable to the high-fidelity physics solvers, into libROM. Plus, libROM is open source, so anyone is welcome to suggest new ideas or contribute to the development. Let's work together for better data-driven technology! Features Proper Orthogonal Decomposition Dynamic mode decomposition Projection-based reduced order models Hyper-reduction Greedy algorithm Many more features will be available soon. Stay tuned! libROM is used in many projects, including BLAST , ARDRA , Laghos , SU2 , ALE3D and HyPar . Many MFEM -based ROM examples can be found in Examples . See also our Gallery , Publications and News pages. News Date Message June 3, 2023 Youngsoo Choi will present at SIAM OP23 Mar 29, 2023 AAAI Spring Symposium was organized Mar 10, 2023 gLaSDI open source code is available in gitHub. Mar 6, 2023 LaSDI open source code is available in gitHub. Feb 15, 2023 parametric DMD paper is published in JCP. Oct 17, 2022 Rayleigh-Taylor instability ROM paper is published in JCP. Oct 1, 2022 CWROM stress lattice paper is published in CMAME. Mar 29, 2022 S-OPT preprint is available in arXiv. Nov 19, 2021 NM-ROM paper is published in JCP. Nov 10, 2021 Laghos ROM is published at CMAME. libROM tutorials in YouTube Date Title July 22, 2021 Poisson equation & its finite element discretization Sep. 1, 2021 Poisson equation & its reduced order model Sep. 23, 2021 Physics-informed sampling procedure for reduced order models Sep. 11, 2022 Local reduced order models and interpolation-based parameterization Sep. 23, 2022 Projection-based reduced order model for nonlinear system Latest Release Examples \u250a Code documentation \u250a Sources Download libROM-master.zip Documentation Building libROM \u250a Poisson equation \u250a Greedy for Poisson New users should start by examining the example codes and tutorials . We also recommend using GLVis or VisIt for visualization. Contact Use the GitHub issue tracker to report bugs or post questions or comments . See the About page for citation information.","title":"Home"},{"location":"index.html#features","text":"Proper Orthogonal Decomposition Dynamic mode decomposition Projection-based reduced order models Hyper-reduction Greedy algorithm Many more features will be available soon. Stay tuned! libROM is used in many projects, including BLAST , ARDRA , Laghos , SU2 , ALE3D and HyPar . Many MFEM -based ROM examples can be found in Examples . See also our Gallery , Publications and News pages.","title":"Features"},{"location":"index.html#news","text":"Date Message June 3, 2023 Youngsoo Choi will present at SIAM OP23 Mar 29, 2023 AAAI Spring Symposium was organized Mar 10, 2023 gLaSDI open source code is available in gitHub. Mar 6, 2023 LaSDI open source code is available in gitHub. Feb 15, 2023 parametric DMD paper is published in JCP. Oct 17, 2022 Rayleigh-Taylor instability ROM paper is published in JCP. Oct 1, 2022 CWROM stress lattice paper is published in CMAME. Mar 29, 2022 S-OPT preprint is available in arXiv. Nov 19, 2021 NM-ROM paper is published in JCP. Nov 10, 2021 Laghos ROM is published at CMAME.","title":"News"},{"location":"index.html#librom-tutorials-in-youtube","text":"Date Title July 22, 2021 Poisson equation & its finite element discretization Sep. 1, 2021 Poisson equation & its reduced order model Sep. 23, 2021 Physics-informed sampling procedure for reduced order models Sep. 11, 2022 Local reduced order models and interpolation-based parameterization Sep. 23, 2022 Projection-based reduced order model for nonlinear system","title":"libROM tutorials in YouTube"},{"location":"index.html#latest-release","text":"Examples \u250a Code documentation \u250a Sources Download libROM-master.zip","title":"Latest Release"},{"location":"index.html#documentation","text":"Building libROM \u250a Poisson equation \u250a Greedy for Poisson New users should start by examining the example codes and tutorials . We also recommend using GLVis or VisIt for visualization.","title":"Documentation"},{"location":"index.html#contact","text":"Use the GitHub issue tracker to report bugs or post questions or comments . See the About page for citation information.","title":"Contact"},{"location":"about.html","text":"About libROM Please cite with: @misc{ doecode_24508, title = {libROM}, author = {Choi, Youngsoo and Arrighi, William J. and Copeland, Dylan M. and Anderson, Robert W. and Oxberry, Geoffrey M.}, abstractNote = {libROM is a collection of C++ classes that compute reduced order models and hyperreduced order models for systems of ordinary differential equations. libROM includes parallel, adaptive methods for proper orthogonal decomposition, and parallel, non-adaptive methods for hyperreduction using the discrete empirical interpolation method.}, doi = {10.11578/dc.20190408.3}, url = {https://doi.org/10.11578/dc.20190408.3}, howpublished = {[Computer Software] \\url{https://doi.org/10.11578/dc.20190408.3}}, year = {2019}, month = {oct} } Contributors Bob Anderson William Arrighi Kyle Chand Siu Wun Cheung Eric Chin Youngsoo Choi Dylan Copeland William Fries Debojyoti Ghosh Xiaolong He Kevin Huynh Tanya Kostova-Vassilevska Jessica Lauzon Sean McBane Yeonjong Shin Geoffrey Oxberry License MIT license Apache license This work performed under the auspices of the U.S. Department of Energy by Lawrence Livermore Laboratory under Contract DE-AC52-07NA27344. Software release number: LLNL-CODE-766763. DOI: 10.11578/dc.20190408.3 . Disclaimer This document was prepared as an account of work sponsored by an agency of the United States government. Neither the United States government nor Lawrence Livermore National Security, LLC, nor any of their employees makes any warranty, expressed or implied, or assumes any legal liability or responsibility for the accuracy, completeness, or usefulness of any information, apparatus, product, or process disclosed, or represents that its use would not infringe privately owned rights. Reference herein to any specific commercial product, process, or service by trade name, trademark, manufacturer, or otherwise does not necessarily constitute or imply its endorsement, recommendation, or favoring by the United States government or Lawrence Livermore National Security, LLC. The views and opinions of authors expressed herein do not necessarily state or reflect those of the United States government or Lawrence Livermore National Security, LLC, and shall not be used for advertising or product endorsement purposes. Website built with MkDocs , Bootstrap and Bootswatch . Hosted on GitHub .","title":"About"},{"location":"about.html#about-librom","text":"Please cite with: @misc{ doecode_24508, title = {libROM}, author = {Choi, Youngsoo and Arrighi, William J. and Copeland, Dylan M. and Anderson, Robert W. and Oxberry, Geoffrey M.}, abstractNote = {libROM is a collection of C++ classes that compute reduced order models and hyperreduced order models for systems of ordinary differential equations. libROM includes parallel, adaptive methods for proper orthogonal decomposition, and parallel, non-adaptive methods for hyperreduction using the discrete empirical interpolation method.}, doi = {10.11578/dc.20190408.3}, url = {https://doi.org/10.11578/dc.20190408.3}, howpublished = {[Computer Software] \\url{https://doi.org/10.11578/dc.20190408.3}}, year = {2019}, month = {oct} }","title":"About libROM"},{"location":"about.html#contributors","text":"Bob Anderson William Arrighi Kyle Chand Siu Wun Cheung Eric Chin Youngsoo Choi Dylan Copeland William Fries Debojyoti Ghosh Xiaolong He Kevin Huynh Tanya Kostova-Vassilevska Jessica Lauzon Sean McBane Yeonjong Shin Geoffrey Oxberry","title":"Contributors"},{"location":"about.html#license","text":"MIT license Apache license This work performed under the auspices of the U.S. Department of Energy by Lawrence Livermore Laboratory under Contract DE-AC52-07NA27344. Software release number: LLNL-CODE-766763. DOI: 10.11578/dc.20190408.3 .","title":"License"},{"location":"about.html#disclaimer","text":"This document was prepared as an account of work sponsored by an agency of the United States government. Neither the United States government nor Lawrence Livermore National Security, LLC, nor any of their employees makes any warranty, expressed or implied, or assumes any legal liability or responsibility for the accuracy, completeness, or usefulness of any information, apparatus, product, or process disclosed, or represents that its use would not infringe privately owned rights. Reference herein to any specific commercial product, process, or service by trade name, trademark, manufacturer, or otherwise does not necessarily constitute or imply its endorsement, recommendation, or favoring by the United States government or Lawrence Livermore National Security, LLC. The views and opinions of authors expressed herein do not necessarily state or reflect those of the United States government or Lawrence Livermore National Security, LLC, and shall not be used for advertising or product endorsement purposes. Website built with MkDocs , Bootstrap and Bootswatch . Hosted on GitHub .","title":"Disclaimer"},{"location":"building.html","text":"Building libROM A simple tutorial on how to build and run libROM. For more details, see the README file. In addition to the native build system described below, libROM packages are also available in Spack: Spack Instructions Clone libROM https://github.com/LLNL/libROM Installation To compile libROM with default build settings (Mac and LLNL LC Machines): ./scripts/compile.sh To compile libROM for Ardra (LLNL LC Machines only): ./scripts/ardra_compile.sh To compile libROM using a different toolchain within cmake/toolchains (Mac and LLNL LC Machines): ./scripts/toolchain_compile.sh toolchain.cmake Compilation options: -a: Compile a special build for the LLNL codebase: Ardra -d: Compile in debug mode. -m: Compile with MFEM (required to run the libROM examples) -t: Use your own cmake/toolchain -u: Update all of libROM's dependencies.","title":"Building libROM"},{"location":"building.html#building-librom","text":"A simple tutorial on how to build and run libROM. For more details, see the README file. In addition to the native build system described below, libROM packages are also available in Spack: Spack","title":"Building libROM"},{"location":"building.html#instructions","text":"Clone libROM https://github.com/LLNL/libROM","title":"Instructions"},{"location":"building.html#installation","text":"To compile libROM with default build settings (Mac and LLNL LC Machines): ./scripts/compile.sh To compile libROM for Ardra (LLNL LC Machines only): ./scripts/ardra_compile.sh To compile libROM using a different toolchain within cmake/toolchains (Mac and LLNL LC Machines): ./scripts/toolchain_compile.sh toolchain.cmake Compilation options: -a: Compile a special build for the LLNL codebase: Ardra -d: Compile in debug mode. -m: Compile with MFEM (required to run the libROM examples) -t: Use your own cmake/toolchain -u: Update all of libROM's dependencies.","title":"Installation"},{"location":"ddps.html","text":"MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}}); DDPS Webinar ( in California time ) DDPS stands for data-driven physical simulation. We hold weekly webinar, in average, either on Thursday or Friday at Lawrence Livermore National Laboratory. If you are interested in giving a webinar talk or would like to recommend a speaker, please send an email to choi15@llnl.gov. If you are interested in being included in DDPS email list, please also send an email to choi15@llnl.gov. Scheduled Talks in 2023 When Speaker Institution Title WebEx Apr. 27th, 10 AM Paul Atzberger UC Santa Barbara Generative Machine Learning Approaches for Data-Driven Modeling and Reductions of Non-Linear Dynamics in Scientific Simulation link May 4th, 10 AM Anima Anandkumar CalTech TBD link May 5th, 10 AM Lori Brady Johns Hopkins University ML-driven Models for Material Microstructure and Mechanical Behavior link May 12th, 10 AM Ying Liang Purdue University Deep generative models for Inverse Random Source Scattering Problems link May 19th, 10 AM Eduardo Gildin TAMU TBD link May 26th, 10 AM Yexiang Xue Purdue University TBD link Past Talks in 2023 Date Speaker Institution Title YouTube Apr. 14th Ameya Jagtap Brown University Scientific Machine Learning through the Lens of Physics-Informed Neural Networks link Apr. 7th Matthias Chung Emory University Big Data Inverse Problems \u2014 Promoting Sparsity and Learning to Regularize link Mar. 31st Jian Cao Northwestern University Physics-based AI-assisted Design and Control in Flexible Manufacturing link Mar. 10th Hessam Babaee University of Pittsburgh CUR Matrix Decomposition for Scalable Reduced-Order Modeling of Nonlinear Partial Differential Equations using Time-Dependent Bases link Feb. 24th Victor M. Zavala University of Wisconsin-Madison Bayesian Optimization: Exploiting Machine Learning Models, Physics, and High-Throughput Experiments link Feb. 10th Soledad Villar Johns Hopkins University The Passive Symmetries of Machine Learning link Jan. 27th Spencer H. Bryngelson GeorgiaTech Competitive Physics Informed Networks link Jan. 20th Ajay B. Harish University of Manchester Uncertainty quantification and deep learning for storm-surge prediction link Past Talks in 2022 Date Speaker Institution Title YouTube Dec. 16th Ralph Smith North Carolina State University Parameter Subset Selection and Active Subspace Techniques for Engineering and Biological Models link Nov. 17th Andrea Manzoni Politecnico di Milano Deep learning for reduced order modeling link Nov. 11th Michael Brenner Harvard University Scientific Uses of Automatic Differentiation link Nov. 4th, 12 PM Sorin Mitran University of North Carolina Data-driven information geometry approach to stochastic model reduction link Oct. 21st Eric de Sturler Virginia Tech Cheap and robust adaptive reduced order models for nonlinear inversion and design link Oct. 7th Jan Drgona PNNL Differentiable Programming for Modeling and Control of Dynamical Systems link Sept. 16 Benjamin Sanderse CWI Amsterdam Structure-preserving learning of embedded, discrete closure models link Aug. 25 Benjamin Erichson University of Pittsburgh Continuous Networks for Sequential Predictions link Aug. 18 Santi Adavani RocketML Industrial Grade Scientific Machine Learning: Challenges and Opportunities link July 21 Ricardo Vinuesa KTH Modeling and controlling turbulent flows through deep learning link July 1 Dirk Hartmann Siemens Machine Learning and Physics-based Simulations \u2013 Yin and Yang of Industrial Digital Twins link June 23 Molei Tao Georgia Institute of Technology Trustworthy learning of mechanical systems, and Stiefel optimization with applications to transformer and optimal transport link June 3 Tailin Wu Stanford University Learning to accelerate large-scale physical simulations in fluid and plasma physics link May 13 Ishan Khurjekar University of Florida Uncertainty-aware guided wave structural health monitoring using ensemble learning link Apr. 28 Benjamin Peherstorfer New York University Neural Galerkin schemes with active learning for high-dimensional evolution equations link Apr. 22 Petros Koumoutsakos Harvard University Artificial Intelligence and Scientific Computing for Fluid Mechanics link Apr. 8 Daniel Floryan University of Houston Charting dynamics from data link Mar. 25 Weinan E Princeton University Machine Learning and Multi-scale Modeling link Mar. 17 Yannis Kevrekidis Johns Hopkins University No equations, no variables, no space, no time: Old and new results on data and the modeling of complex systems link Mar. 11 Alice Cicirello TU Delft Interpretable, explainable and non-intrusive uncertainty propagation through expensive-to-evaluate models via ML-optimization link Mar. 3 Ming Zhong TAMU Machine Learning of Self Organization from Observation link Feb. 25 Lexing Ying Stanford Prony's method, analytic continuation, and quantum signal processing link Feb. 18 Kaushik Bhattacharya Caltech Multi-scale modeling and neural operators link Feb. 11 Sergei Tretiak LANL Machine Learning for materials and chemical dynamics link Feb. 4 Serkan Gugercin Virginia Tech Data-driven modeling of dynamical systems: A systems theoretic perspective link Jan. 28 Ashesh Chattopadhyay Rice University Deep learning meets data assimilation: On physically-consistent architectures and hybrid ensemble Kalman filters for weather forecasting link Jan. 20 Pat Langley Stanford University Computational Scientific Discovery: Heuristic Search for Communicable Laws and Models link Jan. 14 Greg Beroza Stanford University Towards Complete Machine-Learning-Based Earthquake Monitoring Workflows link Jan. 6 Miles Cranmer Princeton University The Problem with Deep Learning in Physics (and how to fix it) link Past Talks in 2021 Date Speaker Institution Title YouTube Dec. 3rd Igor Mezic UC Santa Barbara Koopman operator theory for dynamical systems, control and data analytics link Nov. 18th Michael Mahoney UC Berkeley Toward combining principled scientific models and principled machine learning models link Nov. 12th WaiChing Sun Columbia University Data-driven constitutive updates: from model-free poroelasticity to level set plasticity trained by neural networks link Nov. 4th Misha Khodak CMU Towards automatic architecture design for emerging machine learning tasks link Oct. 28th Masayuki Yano U. of Toronto Towards reliable, efficient, and automated model reduction of parametrized nonlinear PDEs: error estimation, adaptivity, and application to aerodynamics link Oct. 7th Youngsoo Choi LLNL libROM: Library for physics-constrained data-driven physical simulations link Sep. 30th Peter Benner Max Planck Identification of Nonlinear Dynamical Systems from Noisy Measurements link Sep. 2nd Ionut-Gabriel Farcas Oden Institute Learning hierarchies of reduced-dimension and context-aware low-fidelity models for multi-fidelity Monte Carlo sampling link Aug. 26th Jesse Capecelatro U. of Michagan Turbulent disperse two-phase flows: simulations and data-driven modeling link Aug. 19th Christopher J. Earls Cornell U. Gaining mechanistic insight through learning Green's functions: Uncovering the solutions to hidden PDEs link Aug. 13th Dmitriy Anistratov North Carolina State U. Reduced order models for thermal radiative transfer problems based on moment equations and POD/DMD of Eddington tensor link Aug. 5th Luca Magri Imperial College, London Physics-aware reservoir-computing for turbulence and chaotic learning NA Jul. 30th Marta D'Elia Sandia Data-driven learning of nonlocal models: bridging scales and design of new neural networks link Jul. 22nd Hannah Lu Stanford U. Dynamic model decomposition for reduced order modeling in flow and transport problems NA Jul. 15th Yeonjong Shin KAIST Towards a mathematical understanding of modern machine learning: theory, algorithms, and applications link Jul. 9th Rui Wang UC, San Diego Physics-guided deep learning for dynamics for forecasting link Jul. 1st Tan Bui UT, Austin Model-constrained deep learning approaches for inference, control, and uncertainty quantification link Jun. 24th Matthew Zahr U. of Notre Dame Model reduction of convection-dominated partial differential equations via optimization-based implicit feature tracking link Jun. 10th David Ryckelynck Mines ParisTech Model order reduction assisted by deep neural networks (ROM-net) link Jun. 3rd Harbir Antil George Mason U. Applications of Fractional Operators from Optimal Control to Machine Learning link May 27th Romit Maulik Argonne Neural architecture search for surrogate modeling link May 20th Tobias Pfaff , Alvaro Sanchez-Gonzalez DeepMind Learning physical simulation with Graph Network link May 14th George Karniadakis Brown U. Approximating functions, functionals, and operators using deep neural networks for diverse applications link Apr. 29th Traian Iliescu Virginia Tech. Large Eddy Simulation Reduced Order Models (LES-ROMs) link Apr. 15th Tommaso Taddei Inria Registration-based model reduction of parameterized advection-dominated PDEs link Apr. 7th Francisco Chinesta ENSAM ParisTech Empowering Hybrid Twins from Physics-Informed Artificial Intelligence link Apr. 1st Priya Donti Carnegie Mellon U. Incorporating power system physics into deep learning via implicit layers link Mar. 25th Mario Ohlberger U. Munster Model reduction with adaptive enrichment for large scale PDE-constrained optimization link Mar. 18th Karthik Duraisamy U. of Michigan Towards Robust, Accurate and Tractable Reduced Order Models for Multi-scale, Multi-physics Problems link Mar. 10th Pawan Goyal Max Planck Physics-informed learning for nonlinear dynamical systems: a deep learning approach to operator inference link Feb. 18th Nils Thuerey Technische Universitat Munchen Differentiable Physics Simulations for Deep Learning link Jan. 27th Alfio Quarteroni EPFL The mathematical heart: a computational model for the simulation of the heart function link Jan. 21th Steven Brunton U. of Washington Interpretable and Generalizable Machine Learning for Fluid Mechanics link Jan. 7th Irina Tezaur Sandia The Schwarz alternating methods as a means for concurrent multiscale coupling in solid mechanics link Past Talks in 2020 Date Speaker Institution Title YouTube Dec. 17th Jan Hesthaven EPFL Non-intrusive reduced order models using physics informed neural networks link Dec. 10th Jesse Chan Rice U. Entropy stable schemes for nonlinear conservation laws: high order discontinuous Galerkin methods and reduced order modeling link Nov. 18th Paris Perdikaris UPenn When and why physics-informed neural networks fail to train: A neural tangent kernel perspective link Nov. 12th Donsub Rim Courant Institute Distilling nonlinear shock waves: Nonlinear model reduction for transport dominated problems using deep neural networks link Oct. 29th Byungsoo Kim ETH Zurich Data-Driven Methods for Fluid Simulations in Computer Graphics link Oct. 15th Youngkyu Kim UC Berkeley A fast and accurate physics-informed neural network reduced order model with shallow masked autoencoder link","title":"DDPS"},{"location":"ddps.html#ddps-webinar-in-california-time","text":"DDPS stands for data-driven physical simulation. We hold weekly webinar, in average, either on Thursday or Friday at Lawrence Livermore National Laboratory. If you are interested in giving a webinar talk or would like to recommend a speaker, please send an email to choi15@llnl.gov. If you are interested in being included in DDPS email list, please also send an email to choi15@llnl.gov.","title":"DDPS Webinar (in California time)"},{"location":"ddps.html#scheduled-talks-in-2023","text":"When Speaker Institution Title WebEx Apr. 27th, 10 AM Paul Atzberger UC Santa Barbara Generative Machine Learning Approaches for Data-Driven Modeling and Reductions of Non-Linear Dynamics in Scientific Simulation link May 4th, 10 AM Anima Anandkumar CalTech TBD link May 5th, 10 AM Lori Brady Johns Hopkins University ML-driven Models for Material Microstructure and Mechanical Behavior link May 12th, 10 AM Ying Liang Purdue University Deep generative models for Inverse Random Source Scattering Problems link May 19th, 10 AM Eduardo Gildin TAMU TBD link May 26th, 10 AM Yexiang Xue Purdue University TBD link","title":"Scheduled Talks in 2023"},{"location":"ddps.html#past-talks-in-2023","text":"Date Speaker Institution Title YouTube Apr. 14th Ameya Jagtap Brown University Scientific Machine Learning through the Lens of Physics-Informed Neural Networks link Apr. 7th Matthias Chung Emory University Big Data Inverse Problems \u2014 Promoting Sparsity and Learning to Regularize link Mar. 31st Jian Cao Northwestern University Physics-based AI-assisted Design and Control in Flexible Manufacturing link Mar. 10th Hessam Babaee University of Pittsburgh CUR Matrix Decomposition for Scalable Reduced-Order Modeling of Nonlinear Partial Differential Equations using Time-Dependent Bases link Feb. 24th Victor M. Zavala University of Wisconsin-Madison Bayesian Optimization: Exploiting Machine Learning Models, Physics, and High-Throughput Experiments link Feb. 10th Soledad Villar Johns Hopkins University The Passive Symmetries of Machine Learning link Jan. 27th Spencer H. Bryngelson GeorgiaTech Competitive Physics Informed Networks link Jan. 20th Ajay B. Harish University of Manchester Uncertainty quantification and deep learning for storm-surge prediction link","title":"Past Talks in 2023"},{"location":"ddps.html#past-talks-in-2022","text":"Date Speaker Institution Title YouTube Dec. 16th Ralph Smith North Carolina State University Parameter Subset Selection and Active Subspace Techniques for Engineering and Biological Models link Nov. 17th Andrea Manzoni Politecnico di Milano Deep learning for reduced order modeling link Nov. 11th Michael Brenner Harvard University Scientific Uses of Automatic Differentiation link Nov. 4th, 12 PM Sorin Mitran University of North Carolina Data-driven information geometry approach to stochastic model reduction link Oct. 21st Eric de Sturler Virginia Tech Cheap and robust adaptive reduced order models for nonlinear inversion and design link Oct. 7th Jan Drgona PNNL Differentiable Programming for Modeling and Control of Dynamical Systems link Sept. 16 Benjamin Sanderse CWI Amsterdam Structure-preserving learning of embedded, discrete closure models link Aug. 25 Benjamin Erichson University of Pittsburgh Continuous Networks for Sequential Predictions link Aug. 18 Santi Adavani RocketML Industrial Grade Scientific Machine Learning: Challenges and Opportunities link July 21 Ricardo Vinuesa KTH Modeling and controlling turbulent flows through deep learning link July 1 Dirk Hartmann Siemens Machine Learning and Physics-based Simulations \u2013 Yin and Yang of Industrial Digital Twins link June 23 Molei Tao Georgia Institute of Technology Trustworthy learning of mechanical systems, and Stiefel optimization with applications to transformer and optimal transport link June 3 Tailin Wu Stanford University Learning to accelerate large-scale physical simulations in fluid and plasma physics link May 13 Ishan Khurjekar University of Florida Uncertainty-aware guided wave structural health monitoring using ensemble learning link Apr. 28 Benjamin Peherstorfer New York University Neural Galerkin schemes with active learning for high-dimensional evolution equations link Apr. 22 Petros Koumoutsakos Harvard University Artificial Intelligence and Scientific Computing for Fluid Mechanics link Apr. 8 Daniel Floryan University of Houston Charting dynamics from data link Mar. 25 Weinan E Princeton University Machine Learning and Multi-scale Modeling link Mar. 17 Yannis Kevrekidis Johns Hopkins University No equations, no variables, no space, no time: Old and new results on data and the modeling of complex systems link Mar. 11 Alice Cicirello TU Delft Interpretable, explainable and non-intrusive uncertainty propagation through expensive-to-evaluate models via ML-optimization link Mar. 3 Ming Zhong TAMU Machine Learning of Self Organization from Observation link Feb. 25 Lexing Ying Stanford Prony's method, analytic continuation, and quantum signal processing link Feb. 18 Kaushik Bhattacharya Caltech Multi-scale modeling and neural operators link Feb. 11 Sergei Tretiak LANL Machine Learning for materials and chemical dynamics link Feb. 4 Serkan Gugercin Virginia Tech Data-driven modeling of dynamical systems: A systems theoretic perspective link Jan. 28 Ashesh Chattopadhyay Rice University Deep learning meets data assimilation: On physically-consistent architectures and hybrid ensemble Kalman filters for weather forecasting link Jan. 20 Pat Langley Stanford University Computational Scientific Discovery: Heuristic Search for Communicable Laws and Models link Jan. 14 Greg Beroza Stanford University Towards Complete Machine-Learning-Based Earthquake Monitoring Workflows link Jan. 6 Miles Cranmer Princeton University The Problem with Deep Learning in Physics (and how to fix it) link","title":"Past Talks in 2022"},{"location":"ddps.html#past-talks-in-2021","text":"Date Speaker Institution Title YouTube Dec. 3rd Igor Mezic UC Santa Barbara Koopman operator theory for dynamical systems, control and data analytics link Nov. 18th Michael Mahoney UC Berkeley Toward combining principled scientific models and principled machine learning models link Nov. 12th WaiChing Sun Columbia University Data-driven constitutive updates: from model-free poroelasticity to level set plasticity trained by neural networks link Nov. 4th Misha Khodak CMU Towards automatic architecture design for emerging machine learning tasks link Oct. 28th Masayuki Yano U. of Toronto Towards reliable, efficient, and automated model reduction of parametrized nonlinear PDEs: error estimation, adaptivity, and application to aerodynamics link Oct. 7th Youngsoo Choi LLNL libROM: Library for physics-constrained data-driven physical simulations link Sep. 30th Peter Benner Max Planck Identification of Nonlinear Dynamical Systems from Noisy Measurements link Sep. 2nd Ionut-Gabriel Farcas Oden Institute Learning hierarchies of reduced-dimension and context-aware low-fidelity models for multi-fidelity Monte Carlo sampling link Aug. 26th Jesse Capecelatro U. of Michagan Turbulent disperse two-phase flows: simulations and data-driven modeling link Aug. 19th Christopher J. Earls Cornell U. Gaining mechanistic insight through learning Green's functions: Uncovering the solutions to hidden PDEs link Aug. 13th Dmitriy Anistratov North Carolina State U. Reduced order models for thermal radiative transfer problems based on moment equations and POD/DMD of Eddington tensor link Aug. 5th Luca Magri Imperial College, London Physics-aware reservoir-computing for turbulence and chaotic learning NA Jul. 30th Marta D'Elia Sandia Data-driven learning of nonlocal models: bridging scales and design of new neural networks link Jul. 22nd Hannah Lu Stanford U. Dynamic model decomposition for reduced order modeling in flow and transport problems NA Jul. 15th Yeonjong Shin KAIST Towards a mathematical understanding of modern machine learning: theory, algorithms, and applications link Jul. 9th Rui Wang UC, San Diego Physics-guided deep learning for dynamics for forecasting link Jul. 1st Tan Bui UT, Austin Model-constrained deep learning approaches for inference, control, and uncertainty quantification link Jun. 24th Matthew Zahr U. of Notre Dame Model reduction of convection-dominated partial differential equations via optimization-based implicit feature tracking link Jun. 10th David Ryckelynck Mines ParisTech Model order reduction assisted by deep neural networks (ROM-net) link Jun. 3rd Harbir Antil George Mason U. Applications of Fractional Operators from Optimal Control to Machine Learning link May 27th Romit Maulik Argonne Neural architecture search for surrogate modeling link May 20th Tobias Pfaff , Alvaro Sanchez-Gonzalez DeepMind Learning physical simulation with Graph Network link May 14th George Karniadakis Brown U. Approximating functions, functionals, and operators using deep neural networks for diverse applications link Apr. 29th Traian Iliescu Virginia Tech. Large Eddy Simulation Reduced Order Models (LES-ROMs) link Apr. 15th Tommaso Taddei Inria Registration-based model reduction of parameterized advection-dominated PDEs link Apr. 7th Francisco Chinesta ENSAM ParisTech Empowering Hybrid Twins from Physics-Informed Artificial Intelligence link Apr. 1st Priya Donti Carnegie Mellon U. Incorporating power system physics into deep learning via implicit layers link Mar. 25th Mario Ohlberger U. Munster Model reduction with adaptive enrichment for large scale PDE-constrained optimization link Mar. 18th Karthik Duraisamy U. of Michigan Towards Robust, Accurate and Tractable Reduced Order Models for Multi-scale, Multi-physics Problems link Mar. 10th Pawan Goyal Max Planck Physics-informed learning for nonlinear dynamical systems: a deep learning approach to operator inference link Feb. 18th Nils Thuerey Technische Universitat Munchen Differentiable Physics Simulations for Deep Learning link Jan. 27th Alfio Quarteroni EPFL The mathematical heart: a computational model for the simulation of the heart function link Jan. 21th Steven Brunton U. of Washington Interpretable and Generalizable Machine Learning for Fluid Mechanics link Jan. 7th Irina Tezaur Sandia The Schwarz alternating methods as a means for concurrent multiscale coupling in solid mechanics link","title":"Past Talks in 2021"},{"location":"ddps.html#past-talks-in-2020","text":"Date Speaker Institution Title YouTube Dec. 17th Jan Hesthaven EPFL Non-intrusive reduced order models using physics informed neural networks link Dec. 10th Jesse Chan Rice U. Entropy stable schemes for nonlinear conservation laws: high order discontinuous Galerkin methods and reduced order modeling link Nov. 18th Paris Perdikaris UPenn When and why physics-informed neural networks fail to train: A neural tangent kernel perspective link Nov. 12th Donsub Rim Courant Institute Distilling nonlinear shock waves: Nonlinear model reduction for transport dominated problems using deep neural networks link Oct. 29th Byungsoo Kim ETH Zurich Data-Driven Methods for Fluid Simulations in Computer Graphics link Oct. 15th Youngkyu Kim UC Berkeley A fast and accurate physics-informed neural network reduced order model with shallow masked autoencoder link","title":"Past Talks in 2020"},{"location":"download.html","text":"Latest Release Code documentation \u250a Sources Download libROM-master.zip Please use the GitHub issue tracker to report bugs or post questions or comments . All Releases Filename Version Release Date Size CLOC Notes libROM-master.zip v1.0 Sep 2021 160K 22K initial release","title":"Download"},{"location":"download.html#latest-release","text":"Code documentation \u250a Sources Download libROM-master.zip Please use the GitHub issue tracker to report bugs or post questions or comments .","title":"Latest Release"},{"location":"download.html#all-releases","text":"Filename Version Release Date Size CLOC Notes libROM-master.zip v1.0 Sep 2021 160K 22K initial release","title":"All Releases"},{"location":"examples.html","text":"MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}}); Example Applications This page provides a list of libROM example applications. For detailed documentation of the libROM sources, including the examples, see the online Doxygen documentation or the doc directory in the distribution. The goal of the example codes is to provide a step-by-step introduction to libROM in simple model settings. Select from the categories below to display examples and miniapps that contain the respective feature. All examples support (arbitrarily) high-order meshes and finite element spaces . The numerical results from the example codes can be visualized using the GLVis or VisIt visualization tools. See the GLVis and VisIt websites for more details. Users are encouraged to submit any example codes and miniapps that they have created and would like to share. Contact a member of the libROM team to report bugs or post questions or comments . **Application (PDE)** All Diffusion Elasticity Euler Navier-Stokes Advection Hydro-dynamics Vlasov **Reduced order models type** All pROM DMD **Parameterization type** All Trust region Interpolation Global Reproductive **hyper-reduction** All Hyper-reduction No hyper-reduction **Physics code** All MFEM Laghos HyPar **Optimization solver** All No optimizer Differential evolution Poisson Problem This example code demonstrates the use of libROM and MFEM to define a reduced order model for a simple isoparametric finite element discretization of the Poisson problem $$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. The related tutorial YouTube video can be found here . The example parameterizes the righthand side with frequency variable, $\\kappa$: $$f = \\cases{ \\displaystyle \\sin(\\kappa (x_0+x_1+x_2)) & for 3D \\cr \\displaystyle \\sin(\\kappa (x_0+x_1)) & for 2D }$$ The 2D solution contour plot for $\\kappa=\\pi$ is shown in the figure on the right to show the effect of $\\kappa$. For demonstration, we sample solutions at $\\kappa=\\pi$, $1.1\\pi$, and $1.2\\pi$. Then a ROM is build with basis size of 3, which is used to predict the solution for $\\kappa = 1.15\\pi$. The ROM is able to achieve a speedup of $7.5$ with a relative error of $6.4\\times10^{-4}$. One can follow the command line options below to reproduce the numerical results summarized in the table below: offline1 : poisson_global_rom -offline -f 1.0 -id 0 offline2 : poisson_global_rom -offline -f 1.1 -id 1 offline3 : poisson_global_rom -offline -f 1.2 -id 2 merge : poisson_global_rom -merge -ns 3 reference FOM solution : poisson_global_rom -fom -f 1.15 online : poisson_global_rom -online -f 1.15 The command line option -f defines a frequency of the sinusoidal right hand side function. The relation between $kappa$ and f is defined as $\\kappa = \\pi f$. FOM solution time ROM solution time Speed-up Solution relative error 0.22 sec 0.029 sec 7.5 6.4e-4 The code that generates the numerical results above can be found in ( poisson_global_rom.cpp ) and the explanation of codes is provided in here . The poisson_global_rom.cpp is based on ex1p.cpp from MFEM with a modification on the right hand side function. Greedy PROM Poisson Problem This example code demonstrates physics-informed greedy sampling procedure of building local PROMs for the Poisson problem. $$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. The example parameterizes the righthand side with frequency variable, $\\kappa$: $$f = \\cases{ \\displaystyle \\sin(\\kappa (x_0+x_1+x_2)) & for 3D \\cr \\displaystyle \\sin(\\kappa (x_0+x_1)) & for 2D }$$ A set of local ROMs are built for chosen parameter sample points. The parameter sample points are chosen through physics-informed greedy procedure, which is explained in detail by the tutorial YouTube video . Then the local ROMs are interpolated to build a tailored local ROM for a predictive case. Unlike the global ROM, the interpolated ROM has dimension that is the same as the individual local ROM. For example, one can follow the command line options below to reproduce the numerical results summarized in the table below: greedy step : ./poisson_local_rom_greedy -build_database -greedy-param-min 0.5 -greedy-param-max 3.0 -greedy-param-size 15 -greedysubsize 4 -greedyconvsize 6 -greedyrelerrortol 0.01 --mesh \"../../../dependencies/mfem/data/square-disc-nurbs.mesh\" This particular greedy step generates local PROMs at the following 8 parameter points, i.e., 0.521923, 0.743108, 1.322449, 1.754950, 2.011140, 2.281129, 2.587821, 2.950198. reference FOM solution : ./poisson_local_rom_greedy -fom --mesh \"../../../dependencies/mfem/data/square-disc-nurbs.mesh\" -f X.XX online : ./poisson_local_rom_greedy -use_database -online --mesh \"../../../dependencies/mfem/data/square-disc-nurbs.mesh\" -f X.XX You can replace X.XX with any value between 0.5 and 3.0. The table below shows the performance results for three different parameter points. X.XX FOM solution time ROM solution time Speed-up Solution relative error 1.0 0.0135 sec 2.38e-6 sec 5.7e3 9.99593e-5 2.4 0.0137 sec 2.48e-6 sec 5.5e3 0.0001269 2.8 0.0159 sec 2.92e-6 sec 5.4e3 0.00126 The code that generates the numerical results above can be found in ( poisson_local_rom_greedy.cpp ). The poisson_local_rom_greedy.cpp is based on ex1p.cpp from MFEM with a modification on the right hand side function. Heat conduction problem For a given initial condition, i.e., $u_0(x) = u(0,x)$, heat conduction solves a simple 2D/3D time dependent nonlinear heat conduction problem $$\\frac{\\partial u}{\\partial t} = \\nabla\\cdot (\\kappa + \\alpha u)\\nabla u,$$ with a natural insulating boundary condition $\\frac{du}{dn}=0$. We linearize the problem by using the temperature field $u$ from the previous time step to compute the conductivity coefficient. One can run the following command line options to reproduce the DMD results summarized in the table below: mpirun -np 8 ./heat_conduction -s 3 -a 0.5 -k 0.5 -o 4 -tf 0.7 -vs 1 -visit FOM solution time DMD setup time DMD query time DMD relative error 4.8 sec 0.34 sec 1.4e-3 sec 8.2e-4 The code that generates the numerical results above can be found in ( heat_conduction.cpp ). The heat_conduction.cpp is based on ex16p.cpp from MFEM. Parametric DMD heat conduction problem This example demonstrates the parametric DMD on the heat conduction problem . The initial condition, $u_0(x)$, is parameterized by the center of circle and the radius, i.e., $$u_0(x) = \\cases{ \\displaystyle 2 & for |x-c| < r \\cr \\displaystyle 1 & for |x-c| $\\ge$ r }$$ One can run the following command line options to reproduce the parametric DMD results summarized in the table below: rm -rf parameters.txt mpirun -np 8 parametric_heat_conduction -r 0.1 -cx 0.1 -cy 0.1 -o 4 -visit -offline -rdim 16 mpirun -np 8 parametric_heat_conduction -r 0.1 -cx 0.1 -cy 0.5 -o 4 -visit -offline -rdim 16 mpirun -np 8 parametric_heat_conduction -r 0.1 -cx 0.5 -cy 0.1 -o 4 -visit -offline -rdim 16 mpirun -np 8 parametric_heat_conduction -r 0.1 -cx 0.5 -cy 0.5 -o 4 -visit -offline -rdim 16 mpirun -np 8 parametric_heat_conduction -r 0.5 -cx 0.1 -cy 0.1 -o 4 -visit -offline -rdim 16 mpirun -np 8 parametric_heat_conduction -r 0.25 -cx 0.2 -cy 0.4 -o 4 -visit -online -predict mpirun -np 8 parametric_heat_conduction -r 0.4 -cx 0.2 -cy 0.3 -o 4 -visit -online -predict where r, cx, and cy specify the radius, the x and y coordinates of circular initial conditions. r cx cy FOM solution time DMD setup time DMD query time DMD relative error 0.25 0.2 0.4 13.3 sec 0.34 sec 1.2 sec 7.0e-3 0.2 0.4 0.2 13.8 sec 0.32 sec 1.2 sec 3.9e-3 0.3 0.3 0.3 13.6 sec 0.33 sec 1.1 sec 1.3e-2 0.3 0.4 0.2 14.1 sec 0.34 sec 1.3 sec 8.4e-3 0.2 0.3 0.4 14.2 sec 0.34 sec 1.3 sec 7.9e-3 0.4 0.2 0.3 13.9 sec 0.36 sec 1.5 sec 9.0e-3 The code that generates the numerical results above can be found in ( parametric_heat_conduction.cpp ). The parametric_heat_conduction.cpp is based on ex16p.cpp from MFEM. Optimal Control DMD heat conduction with Differential Evolution This example demonstrates the optimal control heat conduction problem with greedy parametric DMD and differential evolution. The initial condition, $u_0(x)$, is parameterized by the center of circle and the radius, i.e., $$u_0(x) = \\cases{ \\displaystyle 2 & for |x-c| < r \\cr \\displaystyle 1 & for |x-c| $\\ge$ r }$$ The goal of the optimal control problem is to find an initial condition that achieves the target last time step temperature distribution. If it does not achieve the target, then it should be closest, given the initial condition parameterization. It is formulated mathematically as an optimization problem: $$ \\underset{c,r}{minimize} \\ || u_T(c,r) - u_{target} ||_2^2,$$ where $u_T$ denotes the last time step temperature and $u_{target}$ denotes the target temperature. Note that $u_T$ depends on the initial condition parameters, i.e., $c$ and $r$. It means that we obtain $u_T$ by solving a forward heat conduction problem. As you can imagine, it needs to explore the parameter space and try to find $c$ and $r$ that produces $u_T$ that best matches $u_{target}$. If each solution process of heat conduction problem is computationally expensive, the search for the optimal parameter can take a while. Therefore, we use our parametric DMD to expedite the process and the search algorithm is done by the differential evolution . Here are the steps to solve the optimal control problem. First, you must delete any post-processed files from the previous differential evolution run. For example, rm -rf parameters.txt rm -rf de_parametric_heat_conduction_greedy_* Then create parametric DMD using a greedy approach with physics-informed error indicator: de_parametric_heat_conduction_greedy -build_database -rdim 16 -greedy-param-size 20 -greedysubsize 10 -greedyconvsize 15 -greedyreldifftol 0.0001 Then you can generate target temperature field with a specific $r$ and $c$ values. Here we used $r=0.2$, $cx=0.2$, and $cy=0.2$ to generate a target temperature field. The target temperature field is shown in the picture above (the one on the left). Therefore, if DMD is good enough, the differential evolution should be able to find $c$ and $r$ values that are closed to these: de_parametric_heat_conduction_greedy -r 0.2 -cx 0.2 -cy 0.2 -visit (Compute target FOM) where r, cx, and cy specify the radius, the x and y coordinates of circular initial conditions. Now you can run the differential evolution using the parametric DMD: de_parametric_heat_conduction_greedy -r 0.2 -cx 0.2 -cy 0.2 -visit -de -de_f 0.9 -de_cr 0.9 -de_ps 50 -de_min_iter 10 -de_max_iter 100 -de_ct 0.001 (Run interpolative differential evolution to see if target FOM can be matched) The differential evolution should be able to find the following optimal control parameters, e.g., in Quartz: $r=0.2002090156652667$, $cx=0.2000936529076073$, and $cy=0.2316380936755735$, which are close to the true parameters that were used to generate the targer temperature field. The DMD temperature field at the last time step on this control parameters is shown in the picture above (the one on the right). The code that generates the numerical results above can be found in ( de_parametric_heat_conduction_greedy.cpp ). The de_parametric_heat_conduction_greedy.cpp is based on ex16p.cpp from MFEM. Mixed nonlinear diffusion For a given initial condition, i.e., $p_0(x) = p(0,x)$, mixed nonlinear diffusion problem solves a simple 2D/3D time dependent nonlinear problem: $$\\frac{\\partial p}{\\partial t} + \\nabla\\cdot \\boldsymbol{v} = f\\,, \\qquad \\nabla p = -a(p)\\boldsymbol{v},$$ with a natural insulating boundary condition $\\frac{\\partial v}{\\partial n}=0$. The $H(div)$-conforming Raviart-Thomas finite element space is used for the velocity function $\\boldsymbol{v}$, and the $L^2$ finite element space is used for pressure function, $p$. This example introduces how the hyper-reduction is implemented and how the reduced bases for two field varibles, $p$ and $\\boldsymbol{v}$. One can run the following command line options to reproduce the DMD results summarized in the table below: offline1 : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -offline -id 0 -sh 0.25 offline2 : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -offline -id 1 -sh 0.15 merge : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -merge -ns 2 offline3 : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -offline -id 2 -sh 0.2 online : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -online -rrdim 8 -rwdim 8 -sh 0.2 -id 2 FOM solution time ROM solution time Speed-up Solution relative error 41.68 sec 1.7 sec 24.5 1.6e-3 The code that generates the numerical results above can be found in ( mixed_nonlinear_diffusion.cpp ). The mixed_nonlinear_diffusion.cpp is based on ex16p.cpp from MFEM and modified to support mixed finite element approach. 1D linear advection - Discontinuous pulses For a given initial condition, i.e., $u_0(x) = u(0,x)$, 1D linear advection of the form $$\\frac{\\partial u}{\\partial t} + c\\frac{\\partial x}{\\partial t} = 0,$$ where $c$ is advection velocity. The initial condition, $u_0(x)$, is given by $$u_0(x) = \\cases{ \\displaystyle exp\\left (-log(2)\\frac{(x+7)^2}{0.0009}\\right ) & for -0.8 $\\le$ x $\\le$ -0.6 \\cr \\displaystyle 1 & for -0.4 $\\le$ x $\\le$ -0.2 \\cr \\displaystyle 1-|10(x-0.1)| & for 0 $\\le$ x $\\le$ 0.2 \\cr \\displaystyle \\sqrt{1-100(x-0.5)^2} & for 0.4 $\\le$ x $\\le$ 0.6 \\cr \\displaystyle 0 & \\text{otherwise} }$$ The DMD is applied to accelerate the advection simulation: FOM solution time DMD setup time DMD query time 3.85 sec 0.18 sec 0.027 sec The instruction of running this simulation can be found at the HyPar page, e.g., go to Examples -> libROM Examples -> 1D Linear Advection-Discontinuous Waves. Advection For a given initial condition, i.e., $u_0(x) = u(0,x)$, DG advection solves the time-dependent advection problem: $$\\frac{\\partial u}{\\partial t} + v\\cdot\\nabla u = 0,$$ where $v$ is a given advection velocity. We choose velocity function so that the dynamics form a spiral advection. One can run the following command line options to reproduce the DMD results summarized in the table below: dg_advection -p 3 -rp 1 -dt 0.005 -tf 4 FOM solution time DMD setup time DMD query time DMD relative error 5.2 sec 30.6 sec 1.9e-2 sec 1.9e-4 The code that generates the numerical results above can be found in ( dg_advection.cpp ). The dg_advection.cpp is based on ex9p.cpp from MFEM. Local PROM Advection For a given initial condition, i.e., $u_0(x) = u(0,x)$, DG advection solves the time-dependent advection problem: $$\\frac{\\partial u}{\\partial t} + v\\cdot\\nabla u = 0,$$ where $v$ is a given advection velocity. We choose velocity function so that the dynamics form a spiral advection. This example illustrates how a parametric PROM can be built through local ROM interpolation techniques. The following sequence of command lines will let you build such a parametric PROM, where the frequency of sinusoidal initial condition function is used as a parameter (its value is passed by a user through -ff command line option). Two local PROMs are constructed through -offline option with parameter values of 1.02 and 1.08, then the local PROM operators are interpolated to build a tailored local PROM at the frequency value of 1.05. Unlike the global ROM, the interpolated PROM has dimension that is the same as the individual PROM, i.e., 40 for this particular problem. rm -rf frequencies.txt ./dg_advection_local_rom_matrix_interp --mesh \"../data/periodic-square.mesh\" -offline -rs 4 -ff 1.02 ./dg_advection_local_rom_matrix_interp --mesh \"../data/periodic-square.mesh\" -interp_prep -rs 4 -ff 1.02 -rdim 40 ./dg_advection_local_rom_matrix_interp --mesh \"../data/periodic-square.mesh\" -offline -rs 4 -ff 1.08 ./dg_advection_local_rom_matrix_interp --mesh \"../data/periodic-square.mesh\" -interp_prep -rs 4 -ff 1.08 -rdim 40 ./dg_advection_local_rom_matrix_interp --mesh \"../data/periodic-square.mesh\" -fom -rs 4 -ff 1.05 -visit ./dg_advection_local_rom_matrix_interp --mesh \"../data/periodic-square.mesh\" -online_interp -rs 4 -ff 1.05 -rdim 40 FOM solution time PROM solution time PROM speed-up PROM relative error 39.38 sec 0.63 sec 62.5 1.19e-2 The code that generates the numerical results above can be found in ( dg_advection_local_rom_matrix_interp.cpp ). The dg_advection_local_rom_matrix_interp.cpp is based on ex9p.cpp from MFEM. 1D Euler Equation, Sod Shock Tube 1D Euler equations of the form $$ \\frac{\\partial \\rho}{\\partial t} + \\frac{\\partial \\rho u}{\\partial x} = 0$$ $$ \\frac{\\partial \\rho u}{\\partial t} + \\frac{\\partial \\rho u^2 + p}{\\partial x} = 0$$ $$ \\frac{\\partial e}{\\partial t} + \\frac{\\partial (e+p)u}{\\partial x} = 0$$ is solved with the initial condition given by $$ \\rho = 1, u = 0, p = 1 \\text{ for } 0 \\le x < 0.5$$ $$ \\rho = 0.125, u = 0, p = 0.1 \\text{ for } 0.5 \\le x \\le 1$$. The DMD is applied to accelerate the 1D Sod shock tube simulation: FOM solution time DMD setup time DMD query time 0.86 sec 0.13 sec 0.0027 sec The instruction of running this simulation can be found at the HyPar page, e.g., go to Examples -> libROM Examples -> 1D Sod Shock Tube. 2D Euler Equation, Isentropic Vortex Convection 2D Compressible Euler equations of the form $$ \\frac{\\partial \\rho}{\\partial t} + \\frac{\\partial \\rho u}{\\partial x} + \\frac{\\partial \\rho v}{\\partial y}= 0$$ $$ \\frac{\\partial \\rho u}{\\partial t} + \\frac{\\partial \\rho u^2 + p}{\\partial x} + \\frac{\\partial \\rho uv}{\\partial y} = 0$$ $$ \\frac{\\partial \\rho v}{\\partial t} + \\frac{\\partial \\rho uv}{\\partial x} + \\frac{\\partial \\rho v^2 + p}{\\partial y} = 0$$ $$ \\frac{\\partial e}{\\partial t} + \\frac{\\partial (e+p)u}{\\partial x} + \\frac{\\partial (e+v)p}{\\partial y} = 0$$ is solved with the free-stream condition given by $$ \\rho_\\infty = 1, u_\\infty = 0.1, v_\\infty = 0, p_\\infty = 1 $$ and a vortex is introduced by $$ \\rho = \\left ( 1-\\frac{(\\gamma-1)b^2}{8\\gamma \\pi^2} e^{1-r^2} \\right )^{\\frac{1}{r-1}}, p = \\rho^\\gamma$$ $$ u = u_\\infty - \\frac{b}{2\\pi} e^{\\frac{1}{2}(1-r^2)}(y-y_c)$$ $$ v = v_\\infty + \\frac{b}{2\\pi} e^{\\frac{1}{2}(1-r^2)}(x-x_c),$$ where $b=0.5$ is the vortex strength and $r = \\left ( (x-x_c)^2 + (y-y_c)^2 \\right )^{\\frac{1}{2}}$ is the distance from the vortex center $(x_c,y_c) = (5,5)$. The DMD is applied to accelerate the vortex convection simulation: FOM solution time DMD setup time DMD query time 5.85 sec 5.25 sec 0.28 sec The instruction of running this simulation can be found at the HyPar page, e.g., go to Examples -> libROM Examples -> 2D Euler Equations - Isentropic Vortex Convection. 2D Euler Equation, Riemann Problem 2D Compressible Euler equations of the form $$ \\frac{\\partial \\rho}{\\partial t} + \\frac{\\partial \\rho u}{\\partial x} + \\frac{\\partial \\rho v}{\\partial y}= 0$$ $$ \\frac{\\partial \\rho u}{\\partial t} + \\frac{\\partial \\rho u^2 + p}{\\partial x} + \\frac{\\partial \\rho uv}{\\partial y} = 0$$ $$ \\frac{\\partial \\rho v}{\\partial t} + \\frac{\\partial \\rho uv}{\\partial x} + \\frac{\\partial \\rho v^2 + p}{\\partial y} = 0$$ $$ \\frac{\\partial e}{\\partial t} + \\frac{\\partial (e+p)u}{\\partial x} + \\frac{\\partial (e+v)p}{\\partial y} = 0$$ is solved. The DMD is applied to accelerate the Riemann problem: FOM solution time DMD setup time DMD query time 111.1 sec 17.6 sec 1.4 sec The instruction of running this simulation can be found at the HyPar page, e.g., go to Examples -> libROM Examples -> 2D Euler Equations - Riemann Problem Case 4 Euler equation For a given initial condition, i.e., $u_0(x) = u(0,x)$, DG Euler solves the compressible Euler system of equation, i.e., a model nonlinear hyperbolic PDE: $$\\frac{\\partial u}{\\partial t} + \\nabla\\cdot \\boldsymbol{F}(u) = 0,$$ with a state vector $\\boldsymbol{u} = [\\rho,\\rho v_0, \\rho v_1, \\rho E]$, where $\\rho$ is the density, $v_i$ is the velocity in the $i$th direction, $E$ is the total specific energy, and $H = E + p/\\rho$ is the total specific enthalpy. The pressure, $p$ is computed through a simple equation of state (EOS) call. The conservative hydrodynamic flux $\\boldsymbol{F}$ in each direction $i$ is $$\\boldsymbol{F}_i = [\\rho v_i, \\rho v_0 v_i + p \\delta_{i,0}, \\rho v_1 v_{i,1} + p\\delta_{i,1}, \\rho v_i H]$$ One can run the following command line options to reproduce the DMD results summarized in the table below: mpirun -n 8 ./dg_euler -p 2 -rs 2 -rp 1 -o 1 -s 3 -visit DMD rel.error FOM solution time DMD setup time DMD query time $\\rho$ $\\rho v_0$ $\\rho v_1$ $E$ 5.65 sec 38.9 sec 1.4e-3 sec 8.0e-7 1.2e-4 1.6e-3 2.6e-6 The code that generates the numerical results above can be found in ( dg_euler.cpp ). The dg_euler.cpp is based on ex18p.cpp from MFEM. 2D Navier\u2013Stokes Equations, Lid-driven square cavity problem A lid-driven square cavity problem is solved. The two references for this problem are Erturk, E., Corke, T.C., and Gokcol, C., `` Numerical Solutions of 2-D Steady Incompressible Driven Cavity Flow at High Reynolds Numbers \", International Journal for Numerical Methods in Fluids, 48, 2005 Ghia, U., Ghia, K.N., Shin, C.T., `` High-Re Solutions for Incompressible Flow using the Navier-Stokes Equations and a Multigrid Method \", Journal of Computational Physics, 48, 1982 The DMD is applied to accelerate the cavity flow simulation: FOM solution time DMD setup time DMD query time 554.6 sec 58.6 sec 0.3 sec The instruction of running this simulation can be found at the HyPar page, e.g., go to Examples -> libROM Examples -> 2D Navier-Stokes Equations - Lid-Driven Square Cavity 1D-1V Vlasov Equation, Two-Stream Instability The 1D-1V Vlasov equatoin is solved with the initial condition given by $$ f(x,v) = \\frac{4}{\\pi T} \\left ( 1+\\frac{1}{10} cos(2k\\pi\\frac{x}{L}) \\right ) \\left ( \\exp\\left( -\\frac{(v-2)^2}{2T} \\right) + \\exp\\left( -\\frac{(v+2)^2}{2T} \\right ) \\right ), k=1, T=1, L=2\\pi. $$ The DMD is applied to accelerate the cavity flow simulation: FOM solution time DMD setup time DMD query time 11.34 sec 2.30 sec 0.34 sec The instruction of running this simulation can be found at the HyPar page, e.g., go to Examples -> libROM Examples -> 2D (1D-1V) Vlasov Equation. Linear elasticity This example demonstrates how to apply projection-based ROM to a linear elasticity problem. The linear elasiticity problem describes a multi-material cantilever beam. Specifically, the following weak form is solved: $$-\\text{div}(\\sigma(\\boldsymbol{u})) = 0$$ where $$\\sigma(\\boldsymbol{u}) = \\lambda \\text{div}(\\boldsymbol{u}) \\boldsymbol{I} + \\mu (\\nabla \\boldsymbol{u} + \\nabla \\boldsymbol{u}^T)$$ is the stress tensor corresponding to displacement field $\\boldsymbol{u}$, and $\\lambda$ and $\\mu$ are the material Lame constants. The Lame constants are related to Young's modulus ($E$) and Poisson's ratio ($\\nu$) as $$\\lambda = \\frac{E\\nu}{(1+\\nu)(1-2\\nu)}$$ $$\\mu = \\frac{E}{2(1+\\nu)}$$ The boundary condition are $\\boldsymbol{u}=\\boldsymbol{0}$ on the fixed part of the boundary with attribute 1, and $\\sigma(\\boldsymbol{u})\\cdot n = f$ on the remainder with f being a constant pull down vector on boundary elements with attribute 2, and zero otherwise. The geometry of the domain is assumed to be as follows: Three distinct steps are required, i.e., offline, merge, and online steps, to build global ROM for the linear elasticity problem. The general description of building a global ROM is explained in this YouTube tutorial video . We parameterized Poisson's ratio ($\\nu$) from 0.2 to 0.4. One can run the following command line options to reproduce the DMD results summarized in the table below: offline phase : ./linear_elasticity_global_rom --mesh \"../../../dependencies/mfem/data/beam-hex-nurbs.mesh\" -offline -id 0 -nu 0.2 offline phase : ./linear_elasticity_global_rom --mesh \"../../../dependencies/mfem/data/beam-hex-nurbs.mesh\" -offline -id 1 -nu 0.4 merge phase : ./linear_elasticity_global_rom --mesh \"../../../dependencies/mfem/data/beam-hex-nurbs.mesh\" -merge -ns 2 fom phase : ./linear_elasticity_global_rom --mesh \"../../../dependencies/mfem/data/beam-hex-nurbs.mesh\" -offline -id 2 -nu 0.XX online phase : ./linear_elasticity_global_rom --mesh \"../../../dependencies/mfem/data/beam-hex-nurbs.mesh\" -online -id 3 -nu 0.XX You can replace 0.XX with any value between 0.2 and 0.5. It must be strictly less than 0.5. Note that the global ROM is able to predict the point outside of the training region with high accuracy, i.e., $\\nu=0.45$. The table below shows the performance results for three different parameter points. Poisson's ratio ($\\nu$) FOM solution time ROM solving time Position relative error 0.25 4.96e-2 sec 3.54e-6 sec 0.00081 0.3 4.93e-2 sec 4.37e-6 sec 0.00133 0.35 5.96e-2 sec 4.60e-6 sec 0.00121 0.45 5.22e-2 sec 4.36e-6 sec 0.00321 The code that generates the numerical results above can be found in ( linear_elasticity_global_rom.cpp ). The linear_elasticity_global_rom.cpp is based on ex2p.cpp from MFEM. Nonlinear elasticity, PROM For a given initial condition, i.e., $v_0(x) = v(0,x)$, nonlinear elasticity solves a time dependent nonlinear elasticity problem of the form $$\\frac{\\partial v}{\\partial t} = H(x) + Sv\\,, \\qquad \\frac{\\partial x}{\\partial t} = v,$$ where $H$ is a hyperelastic model and $S$ is a viscosity operator of Laplacian type. The initial displacement is set zero and the initial velocity is set as zero except the third component which is defined: $$v_3(0,x) = -\\frac{\\mu}{80}\\sin(\\mu x_1)$$ One can run the following command line options to build global ROM and reproduce the results summarizedin the table below. You can replace XXX in the fom and online phase to take any $\\mu$ value between 3.9 and 4.1: offline phase : ./nonlinear_elasticity_global_rom --mesh \"../../../dependencies/mfem/data/beam-hex-nurbs.mesh\" --offline -dt 0.01 -tf 5.0 -s 14 -vs 10 -sc 3.9 -id 0 offline phase : ./nonlinear_elasticity_global_rom --mesh \"../../../dependencies/mfem/data/beam-hex-nurbs.mesh\" --offline -dt 0.01 -tf 5.0 -s 14 -vs 10 -sc 4.1 -id 1 merge phase : ./nonlinear_elasticity_global_rom --mesh \"../../../dependencies/mfem/data/beam-hex-nurbs.mesh\" --merge -ns 2 -dt 0.01 -tf 5.0 fom phase : ./nonlinear_elasticity_global_rom --mesh \"../../../dependencies/mfem/data/beam-hex-nurbs.mesh\" --offline -dt 0.01 -tf 5.0 -s 14 -vs 5 -sc XXX -id 2 online phase : ./nonlinear_elasticity_global_rom --mesh \"../../../dependencies/mfem/data/beam-hex-nurbs.mesh\" --online -dt 0.01 -tf 5.0 -s 14 -vs 5 -hyp -rvdim 40 -rxdim 10 -hdim 71 -nsr 200 -sc XXX $\\mu$ FOM solution time PROM online time Speed-up Position relative error 3.92 164.9 sec 20.5 sec 8.0 0.0053 3.94 169.2 sec 20.8 sec 8.1 0.0053 3.96 167.8 sec 20.9 sec 8.0 0.0057 3.98 162.7 sec 22.1 sec 7.4 0.0062 4.0 169.4 sec 21.1 sec 8.0 0.0067 4.02 168.4 sec 20.8 sec 8.1 0.0071 4.04 160.6 sec 22.8 sec 7.0 0.0073 4.06 173.4 sec 22.7 sec 7.6 0.0071 4.08 169.2 sec 20.0 sec 8.5 0.0066 The code that generates the numerical results above can be found in ( nonlinear_elasticity_global_rom.cpp ). The nonlinear_elasticity_global_rom.cpp is based on ex10p.cpp from MFEM. Nonlinear elasticity, DMD For a given initial condition, i.e., $v_0(x) = v(0,x)$, nonlinear elasticity solves a time dependent nonlinear elasticity problem of the form $$\\frac{\\partial v}{\\partial t} = H(x) + Sv\\,, \\qquad \\frac{\\partial x}{\\partial t} = v,$$ where $H$ is a hyperelastic model and $S$ is a viscosity operator of Laplacian type. One can run the following command line options to reproduce the DMD results summarized in the table below: mpirun -np 8 ./nonlinear_elasticity -s 2 -rs 1 -dt 0.01 -tf 5 -visit FOM solution time DMD setup time DMD query time Position relative error Velocity relative error 10.4 sec 2.9e-1 sec 1.1 sec 7.0e-5 1.4e-3 The code that generates the numerical results above can be found in ( nonlinear_elasticity.cpp ). The nonlinear_elasticity.cpp is based on ex10p.cpp from MFEM. Laghos ROM Miniapp Laghos (LAGrangian High-Order Solver) is a miniapp that solves the time-dependent Euler equations of compressible gas dynamics in a moving Lagrangian frame using unstructured high-order finite element spatial discretization and explicit high-order time-stepping. LaghosROM introduces reduced order models of Laghos simulations. A list of example problems that you can solve with LaghosROM includes Sedov blast, Gresho vortex, Taylor-Green vortex, triple-point, and Rayleigh-Taylor instability problems. Below are command line options for each problems and some numerical results. For each problem, four different phases need to be taken, i.e., the offline, hyper-reduction preprocessing, online, and restore phase. The online phase runs necessary full order model (FOM) to generate simulation data. libROM dynamically collects the data as the FOM simulation marches in time domain. In the hyper-reduction preprocessing phase, the libROM builds a library of reduced basis as well as hyper-reduction operators. The online phase runs the ROM and the restore phase projects the ROM solutions to the full order model dimension. Sedov blast problem Sedov blast problem is a three-dimensional standard shock hydrodynamic benchmark test. An initial delta source of internal energy deposited at the origin of a three-dimensional cube is considered. The computational domain is the unit cube $\\tilde{\\Omega} = [0,1]^3$ with wall boundary conditions on all surfaces, i.e., $v\\cdot n = 0$. The initial velocity is given by $v=0$. The initial density is given by $\\rho = 1$. The initial energy is given by a delta function at the origin. The adiabatic index in the ideal gas equations of state is set $\\gamma = 1.4$. The initial mesh is a uniform Catesian hexahedral mesh, which deforms over time. It can be seen that the radial symmetry is maintained in the shock wave propagation in both FOM and PROM simulations. One can reproduce the PROM numerical result, following the command line options described below: offline : ./laghos -o twp_sedov -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -offline -visit -romsvds -ef 0.9999 -writesol -romos -rostype load -romsns -nwinsamp 21 -sample-stages hyper-reduction preprocessing : ./laghos -o twp_sedov -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -online -romsvds -romos -rostype load -romhrprep -romsns -romgs -nwin 66 -sfacv 2 -sface 2 (-sopt) online : ./laghos -o twp_sedov -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -online -romsvds -romos -rostype load -romhr -romsns -romgs -nwin 66 -sfacv 2 -sface 2 restore : ./laghos -o twp_sedov -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -restore -soldiff -romsvds -romos -rostype load -romsns -romgs -nwin 66 FOM solution time ROM solution time Speed-up Velocity relative error (DEIM) Velocity relative error (SOPT) 191 sec 8.3 sec 22.8 2.2e-4 1.1e-4 One can also easily apply time-windowing DMD to Sedov blast problem easily. First, prepare tw_sedov3.csv file, which contains a sequence of time steps, {0.01, 0.02, $\\ldots$, 0.79, 0.8 } in a column. Then you can follow the command line options described below: offline : mpirun -np 8 ./laghos -o dmd_sedov -p 4 -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -offline -visit -romsvds -ef 0.9999 -writesol -nwin 80 -tw tw_sedov3.csv -dmd -dmdnuf -met -no-romoffset online : mpirun -np 8 ./laghos -o dmd_sedov -p 4 -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -restore -soldiff -romsvds -dmd -dmdnuf -no-romoffset FOM solution time DMD restoration time Speed-up Velocity relative error 30.4 sec 15.0. sec 2.0 0.0382461 Gresho vortex problem Gresho vortex problem is a two-dimensional benchmark test for the incompressible inviscid Navier-Stokes equations. The computational domain is the unit square $\\tilde\\Omega = [-0.5,0.5]^2$ with wall boundary conditions on all surfaces, i.e., $v\\dot n = 0$. Let $(r,\\phi)$ denote the polar coordinates of a particle $\\tilde{x} \\in \\tilde{\\Omega}$. The initial angular velocity is given by $$v_\\phi = \\cases{ \\displaystyle 5r & for 0 $\\leq$ r < 0.2 \\cr \\displaystyle 2-5r & for 0.2 $\\leq$ r < 0.4 \\cr \\displaystyle 0 i & for r $\\geq$ 0.4. }$$ The initial density if given by $\\rho=1$. The initial thermodynamic pressure is given by $$p = \\cases{ 5 + \\frac{25}{2} r^2 & for 0 $\\leq$ r < 0.2 \\cr 9 - 4 \\log(0.2) + \\frac{25}{2} - 20r + 4 \\log(r) & for 0.2 $\\leq$ r < 0.4 \\cr 3 + 4\\log(2) & for r $\\geq$ 0.4 }$$ offline : ./laghos -o twp_gresho -p 4 -m ../data/square_gresho.mesh -rs 4 -ok 3 -ot 2 -tf 0.62 -s 7 -visit -writesol -offline -ef 0.9999 -romsvds -romos -rostype load -romsns -nwinsamp 21 -sample-stages hyper-reduction preprocessing : ./laghos -o twp_gresho -p 4 -m ../data/square_gresho.mesh -rs 4 -ok 3 -ot 2 -tf 0.62 -s 7 -online -romhrprep -romsvds -romos -rostype load -romsns -romgs -nwin 152 -sfacv 2 -sface 2 online : ./laghos -o twp_gresho -p 4 -m ../data/square_gresho.mesh -rs 4 -ok 3 -ot 2 -tf 0.62 -s 7 -online -romhr -romsvds -romos -rostype load -romsns -romgs -nwin 152 -sfacv 2 -sface 2 restore : ./laghos -o twp_gresho -p 4 -m ../data/square_gresho.mesh -rs 4 -ok 3 -ot 2 -tf 0.62 -s 7 -soldiff -restore -romsvds -romos -rostype load -romsns -romgs -nwin 152 FOM solution time ROM solution time Speed-up Velocity relative error 218 sec 8.4 sec 25.9 2.1e-4 Taylor-Green vortex Taylor-Green vortex problem is a three-dimensional benchmark test for the incompressible Navier-Stokes equasions. A manufactured smooth solution is considered by extending the steady state Taylor-Green vortex solution to the compressible Euler equations. The computational domain is the unit cube $\\tilde{\\Omega}=[0,1]^3$ with wall boundary conditions on all surfaces, i.e., $v\\cdot n = 0$. The initial velocity is given by $$ v = (\\sin{(\\pi x)} \\cos{(\\pi y)} \\cos{(\\pi z)}, -\\cos{(\\pi x)}\\sin{(\\pi y)}\\cos{(\\pi z)}, 0) $$ The initial density is given by $\\rho =1$. The initial thermodynamic pressure is given by $$ p = 100 + \\frac{(\\cos{(2\\pi x)} + \\cos{(2\\pi y))(\\cos{(2\\pi z)+2})-2}}{16} $$ The initial energy is related to the pressure and the density by the equation of state for the ideal gas, $p=(\\gamma-1)\\rho e$, with $\\gamma = 5/3$. The initial mesh is a uniform Cartesian hexahedral mesh, which deforms over time. The visualized solution is given on the right. One can reproduce the numerical result, following the command line options described below: offline : ./laghos -o twp_taylor -m ../data/cube01_hex.mesh -p 0 -rs 2 -cfl 0.1 -tf 0.25 -s 7 -pa -offline -visit -romsvds -ef 0.9999 -writesol -romos -rostype load -romsns -nwinsamp 21 -sdim 1000 -sample-stages hyper-reduction preprocessing : ./laghos -o twp_taylor -m ../data/cube01_hex.mesh -p 0 -rs 2 -cfl 0.1 -tf 0.25 -s 7 -pa -online -romsvds -romos -rostype load -romhrprep -romsns -romgs -nwin 82 -sfacv 2 -sface 2 online : ./laghos -o twp_taylor -m ../data/cube01_hex.mesh -p 0 -rs 2 -cfl 0.1 -tf 0.25 -s 7 -pa -online -romsvds -romos -rostype load -romhr -romsns -romgs -nwin 82 -sfacv 2 -sface 2 restore : ./laghos -o twp_taylor -m ../data/cube01_hex.mesh -p 0 -rs 2 -cfl 0.1 -tf 0.25 -s 7 -pa -restore -soldiff -romsvds -romos -rostype load -romsns -romgs -nwin 82 FOM solution time ROM solution time Speed-up Velocity relative error 170 sec 5.4 sec 31.2 1.1e-6 Triple-point problem Triple-point problem is a three-dimensional shock test with two materials in three states. The computational domain is $\\tilde{\\Omega} = [0,7] \\times [0,3 ] \\times [0,1.5]$ with wall boundary conditions on all surfaces, i.e., $v\\cdot n = 0$. The initial velocity is given by $v=0$. The initial density is given by $$\\rho = \\cases{ \\displaystyle 1 & for x $\\leq$ 1 or y $\\leq$ 1.5, \\cr \\displaystyle 1/8 & for x $>$ 1 and y $>$ 1.5 }$$ The initial thermodynamic pressure is given for $$p = \\cases{ \\displaystyle 1 & for x $\\leq$ 1, \\cr \\displaystyle 0.1 & for x $>$ 1 }$$ The initial energy is related to the pressure and the density by the equation of state for the ideal gas, $p=(\\gamma-1)\\rho e$, with $$\\gamma = \\cases{ \\displaystyle 1.5 & for x $\\leq$ 1 or y $>$ 1.5\\cr \\displaystyle 1.4 & for x $>$ 1 and y $\\leq$ 1.5 }$$ The initial mesh is a uniform Cartesian hexahedral mesh, which deforms over time. The visualized solution is given on the right. One can reproduce the numerical result, following the command line options described below: offline : ./laghos -o twp_triple -p 3 -m ../data/box01_hex.mesh -rs 2 -tf 0.8 -s 7 -cfl 0.5 -pa -offline -writesol -visit -romsvds -romos -rostype load -romsns -nwinsamp 21 -ef 0.9999 -sdim 200 -sample-stages hyper-reduction preprocessing : ./laghos -o twp_triple -p 3 -m ../data/box01_hex.mesh -rs 2 -tf 0.8 -s 7 -cfl 0.5 -pa -online -romhrprep -romsvds -romos -rostype load -romgs -romsns -nwin 18 -sfacv 2 -sface 2 online : ./laghos -o twp_triple -p 3 -m ../data/box01_hex.mesh -rs 2 -tf 0.8 -s 7 -cfl 0.5 -pa -online -romhr -romsvds -romos -rostype load -romgs -romsns -nwin 18 -sfacv 2 -sface 2 restore : ./laghos -o twp_triple -p 3 -m ../data/box01_hex.mesh -rs 2 -tf 0.8 -s 7 -cfl 0.5 -pa -restore -soldiff -romsvds -romos -rostype load -romgs -romsns -nwin 18 FOM solution time ROM solution time Speed-up Velocity relative error 122 sec 1.4 sec 87.8 8.1e-4 Rayleigh-Taylor instability problem Rayleigh-Taylor instability problem offline : ./laghos -p 7 -m ../data/rt2D.mesh -tf 1.5 -rs 4 -ok 2 -ot 1 -pa -o twp_rt -s 7 -writesol -offline -romsns -sdim 200000 -romsvds -romos -romgs -nwinsamp 21 -ef 0.9999999999 -sample-stages hyper-reduction preprocessing : ./laghos -p 7 -m ../data/rt2D.mesh -tf 1.5 -rs 4 -ok 2 -ot 1 -pa -o twp_rt -s 7 -online -romsns -romos -romgs -nwin 187 -sfacv 2 -sface 2 -romhrprep online : ./laghos -p 7 -m ../data/rt2D.mesh -tf 1.5 -rs 4 -ok 2 -ot 1 -pa -o twp_rt -s 7 -online -romsns -romos -romgs -nwin 187 -sfacv 2 -sface 2 -romhr restore : ./laghos -p 7 -m ../data/rt2D.mesh -tf 1.5 -rs 4 -ok 2 -ot 1 -pa -o twp_rt -s 7 -restore -romsns -romos -romgs -soldiff -nwin 187 FOM solution time ROM solution time Speed-up Velocity relative error 127 sec 8.7 sec 14.6 7.8e-3 LaghosROM is an external miniapp, available at https://github.com/CEED/Laghos/tree/rom/rom . No examples or miniapps match your criteria. <!-- function showElement(id, show) { //document.getElementById(id).style.display = show ? \"block\" : \"none\"; // workaround because Doxygen splits and duplicates the divs for some reason var divs = document.getElementsByTagName(\"div\"); for (i = 0; i < divs.length; i++) { if (divs.item(i).id == id) { divs.item(i).style.display = show ? \"block\" : \"none\"; } } return show ? 1 : 0; } function getBooleans(comboId) { combo = document.getElementById(comboId); first_selected = false; for (i = 0; i < combo.options.length; i++) { opt = combo.options[i]; selected = opt.selected || first_selected; if (!i) { first_selected = selected; } // create a boolean variable named after the option this[opt.id] = selected; } } function update() { getBooleans(\"group1\"); getBooleans(\"group2\"); getBooleans(\"group3\"); getBooleans(\"group4\"); getBooleans(\"group5\"); getBooleans(\"group6\"); numShown = 0 // expression continued... // example codes + showElement(\"poisson\", (diffusion) && (prom) && (global) && (no_hr) && (mfem) && (no_optimizer)) + showElement(\"poisson_greedy_prom\", (diffusion) && (prom) && (global) && (no_hr) && (mfem) && (no_optimizer)) + showElement(\"dg_advection\", (advection) && (dmd) && (reproductive) && (no_hr) && (mfem) && (no_optimizer)) + showElement(\"local_prom_dg_advection\", (advection) && (prom) && (interpolation) && (no_hr) && (mfem) && (no_optimizer)) + showElement(\"dg_euler\", (euler) && (dmd) && (reproductive) && (no_hr) && (mfem) && (no_optimizer)) + showElement(\"heat_conduction\", (diffusion) && (dmd) && (reproductive) && (no_hr) && (mfem) && (no_optimizer)) + showElement(\"parametric_dmd_heat_conduction\", (diffusion) && (dmd) && (interpolation) && (no_hr) && (mfem) && (no_optimizer) ) + showElement(\"optimal_control_dmd_heat_conduction\", (diffusion) && (dmd) && (interpolation) && (no_hr) && (mfem) && (de) ) + showElement(\"mixed_nonlinear_diffusion\", (diffusion) && (prom) && (global) && (hr) && (mfem) && (no_optimizer) ) + showElement(\"linear_elasticity\", (elasticity) && (prom) && (global) && (no_hr) && (mfem) && (no_optimizer) ) + showElement(\"nonlinear_elasticity_prom\", (elasticity) && (prom) && (global) && (hr) && (mfem) && (no_optimizer) ) + showElement(\"nonlinear_elasticity_dmd\", (elasticity) && (dmd) && (reproductive) && (no_hr) && (mfem) && (no_optimizer) ) + showElement(\"laghos\", (hydro) && (prom) && (global) && (hr) && (laghos) & (no_optimizer)) + showElement(\"1DdiscontinuousPulse\", (advection) && (dmd) && (reproductive) && (no_hr) && (hypar) && (no_optimizer)) + showElement(\"1DSodShockTube\", (euler) && (dmd) && (reproductive) && (no_hr) && (hypar) && (no_optimizer)) + showElement(\"2DEulerVortexConvection\", (euler) && (dmd) && (reproductive) && (no_hr) && (hypar) && (no_optimizer)) + showElement(\"2DEulerRiemannProblem\", (euler) && (dmd) && (reproductive) && (no_hr) && (hypar) && (no_optimizer)) + showElement(\"2DNavierStokesProblem\", (navierstokes) && (dmd) && (reproductive) && (no_hr) && (hypar) && (no_optimizer)) + showElement(\"1D1VVlasovEquation\", (vlasov) && (dmd) && (reproductive) && (no_hr) && (hypar) && (no_optimizer)) ; // ...end of expression // show/hide the message \"No examples match your criteria\" showElement(\"nomatch\", numShown == 0); } function initCombos() { var query = location.search.substr(1); query.split(\"&\").forEach(function(id) { if (id) { opt = document.getElementById(id); if (opt) { opt.selected = true; } } }); } // make sure \"no match\" div is not visible after page is loaded window.onload = update; // force vertical scrollbar document.getElementsByTagName(\"body\")[0].style = \"overflow-y: scroll\" // parse URL part after '?', e.g., http://.../index.html?elasticity&nurbs initCombos(); //-->","title":"Examples"},{"location":"examples.html#example-applications","text":"This page provides a list of libROM example applications. For detailed documentation of the libROM sources, including the examples, see the online Doxygen documentation or the doc directory in the distribution. The goal of the example codes is to provide a step-by-step introduction to libROM in simple model settings. Select from the categories below to display examples and miniapps that contain the respective feature. All examples support (arbitrarily) high-order meshes and finite element spaces . The numerical results from the example codes can be visualized using the GLVis or VisIt visualization tools. See the GLVis and VisIt websites for more details. Users are encouraged to submit any example codes and miniapps that they have created and would like to share. Contact a member of the libROM team to report bugs or post questions or comments .","title":"Example Applications"},{"location":"examples.html#application-pde","text":"All Diffusion Elasticity Euler Navier-Stokes Advection Hydro-dynamics Vlasov","title":"**Application (PDE)**"},{"location":"examples.html#reduced-order-models-type","text":"All pROM DMD","title":"**Reduced order models type**"},{"location":"examples.html#parameterization-type","text":"All Trust region Interpolation Global Reproductive","title":"**Parameterization type**"},{"location":"examples.html#hyper-reduction","text":"All Hyper-reduction No hyper-reduction","title":"**hyper-reduction**"},{"location":"examples.html#physics-code","text":"All MFEM Laghos HyPar","title":"**Physics code**"},{"location":"examples.html#optimization-solver","text":"All No optimizer Differential evolution","title":"**Optimization solver**"},{"location":"examples.html#poisson-problem","text":"This example code demonstrates the use of libROM and MFEM to define a reduced order model for a simple isoparametric finite element discretization of the Poisson problem $$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. The related tutorial YouTube video can be found here . The example parameterizes the righthand side with frequency variable, $\\kappa$: $$f = \\cases{ \\displaystyle \\sin(\\kappa (x_0+x_1+x_2)) & for 3D \\cr \\displaystyle \\sin(\\kappa (x_0+x_1)) & for 2D }$$ The 2D solution contour plot for $\\kappa=\\pi$ is shown in the figure on the right to show the effect of $\\kappa$. For demonstration, we sample solutions at $\\kappa=\\pi$, $1.1\\pi$, and $1.2\\pi$. Then a ROM is build with basis size of 3, which is used to predict the solution for $\\kappa = 1.15\\pi$. The ROM is able to achieve a speedup of $7.5$ with a relative error of $6.4\\times10^{-4}$. One can follow the command line options below to reproduce the numerical results summarized in the table below: offline1 : poisson_global_rom -offline -f 1.0 -id 0 offline2 : poisson_global_rom -offline -f 1.1 -id 1 offline3 : poisson_global_rom -offline -f 1.2 -id 2 merge : poisson_global_rom -merge -ns 3 reference FOM solution : poisson_global_rom -fom -f 1.15 online : poisson_global_rom -online -f 1.15 The command line option -f defines a frequency of the sinusoidal right hand side function. The relation between $kappa$ and f is defined as $\\kappa = \\pi f$. FOM solution time ROM solution time Speed-up Solution relative error 0.22 sec 0.029 sec 7.5 6.4e-4 The code that generates the numerical results above can be found in ( poisson_global_rom.cpp ) and the explanation of codes is provided in here . The poisson_global_rom.cpp is based on ex1p.cpp from MFEM with a modification on the right hand side function.","title":"Poisson Problem"},{"location":"examples.html#greedy-prom-poisson-problem","text":"This example code demonstrates physics-informed greedy sampling procedure of building local PROMs for the Poisson problem. $$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. The example parameterizes the righthand side with frequency variable, $\\kappa$: $$f = \\cases{ \\displaystyle \\sin(\\kappa (x_0+x_1+x_2)) & for 3D \\cr \\displaystyle \\sin(\\kappa (x_0+x_1)) & for 2D }$$ A set of local ROMs are built for chosen parameter sample points. The parameter sample points are chosen through physics-informed greedy procedure, which is explained in detail by the tutorial YouTube video . Then the local ROMs are interpolated to build a tailored local ROM for a predictive case. Unlike the global ROM, the interpolated ROM has dimension that is the same as the individual local ROM. For example, one can follow the command line options below to reproduce the numerical results summarized in the table below: greedy step : ./poisson_local_rom_greedy -build_database -greedy-param-min 0.5 -greedy-param-max 3.0 -greedy-param-size 15 -greedysubsize 4 -greedyconvsize 6 -greedyrelerrortol 0.01 --mesh \"../../../dependencies/mfem/data/square-disc-nurbs.mesh\" This particular greedy step generates local PROMs at the following 8 parameter points, i.e., 0.521923, 0.743108, 1.322449, 1.754950, 2.011140, 2.281129, 2.587821, 2.950198. reference FOM solution : ./poisson_local_rom_greedy -fom --mesh \"../../../dependencies/mfem/data/square-disc-nurbs.mesh\" -f X.XX online : ./poisson_local_rom_greedy -use_database -online --mesh \"../../../dependencies/mfem/data/square-disc-nurbs.mesh\" -f X.XX You can replace X.XX with any value between 0.5 and 3.0. The table below shows the performance results for three different parameter points. X.XX FOM solution time ROM solution time Speed-up Solution relative error 1.0 0.0135 sec 2.38e-6 sec 5.7e3 9.99593e-5 2.4 0.0137 sec 2.48e-6 sec 5.5e3 0.0001269 2.8 0.0159 sec 2.92e-6 sec 5.4e3 0.00126 The code that generates the numerical results above can be found in ( poisson_local_rom_greedy.cpp ). The poisson_local_rom_greedy.cpp is based on ex1p.cpp from MFEM with a modification on the right hand side function.","title":"Greedy PROM Poisson Problem"},{"location":"examples.html#heat-conduction-problem","text":"For a given initial condition, i.e., $u_0(x) = u(0,x)$, heat conduction solves a simple 2D/3D time dependent nonlinear heat conduction problem $$\\frac{\\partial u}{\\partial t} = \\nabla\\cdot (\\kappa + \\alpha u)\\nabla u,$$ with a natural insulating boundary condition $\\frac{du}{dn}=0$. We linearize the problem by using the temperature field $u$ from the previous time step to compute the conductivity coefficient. One can run the following command line options to reproduce the DMD results summarized in the table below: mpirun -np 8 ./heat_conduction -s 3 -a 0.5 -k 0.5 -o 4 -tf 0.7 -vs 1 -visit FOM solution time DMD setup time DMD query time DMD relative error 4.8 sec 0.34 sec 1.4e-3 sec 8.2e-4 The code that generates the numerical results above can be found in ( heat_conduction.cpp ). The heat_conduction.cpp is based on ex16p.cpp from MFEM.","title":"Heat conduction problem"},{"location":"examples.html#parametric-dmd-heat-conduction-problem","text":"This example demonstrates the parametric DMD on the heat conduction problem . The initial condition, $u_0(x)$, is parameterized by the center of circle and the radius, i.e., $$u_0(x) = \\cases{ \\displaystyle 2 & for |x-c| < r \\cr \\displaystyle 1 & for |x-c| $\\ge$ r }$$ One can run the following command line options to reproduce the parametric DMD results summarized in the table below: rm -rf parameters.txt mpirun -np 8 parametric_heat_conduction -r 0.1 -cx 0.1 -cy 0.1 -o 4 -visit -offline -rdim 16 mpirun -np 8 parametric_heat_conduction -r 0.1 -cx 0.1 -cy 0.5 -o 4 -visit -offline -rdim 16 mpirun -np 8 parametric_heat_conduction -r 0.1 -cx 0.5 -cy 0.1 -o 4 -visit -offline -rdim 16 mpirun -np 8 parametric_heat_conduction -r 0.1 -cx 0.5 -cy 0.5 -o 4 -visit -offline -rdim 16 mpirun -np 8 parametric_heat_conduction -r 0.5 -cx 0.1 -cy 0.1 -o 4 -visit -offline -rdim 16 mpirun -np 8 parametric_heat_conduction -r 0.25 -cx 0.2 -cy 0.4 -o 4 -visit -online -predict mpirun -np 8 parametric_heat_conduction -r 0.4 -cx 0.2 -cy 0.3 -o 4 -visit -online -predict where r, cx, and cy specify the radius, the x and y coordinates of circular initial conditions. r cx cy FOM solution time DMD setup time DMD query time DMD relative error 0.25 0.2 0.4 13.3 sec 0.34 sec 1.2 sec 7.0e-3 0.2 0.4 0.2 13.8 sec 0.32 sec 1.2 sec 3.9e-3 0.3 0.3 0.3 13.6 sec 0.33 sec 1.1 sec 1.3e-2 0.3 0.4 0.2 14.1 sec 0.34 sec 1.3 sec 8.4e-3 0.2 0.3 0.4 14.2 sec 0.34 sec 1.3 sec 7.9e-3 0.4 0.2 0.3 13.9 sec 0.36 sec 1.5 sec 9.0e-3 The code that generates the numerical results above can be found in ( parametric_heat_conduction.cpp ). The parametric_heat_conduction.cpp is based on ex16p.cpp from MFEM.","title":"Parametric DMD heat conduction problem"},{"location":"examples.html#optimal-control-dmd-heat-conduction-with-differential-evolution","text":"This example demonstrates the optimal control heat conduction problem with greedy parametric DMD and differential evolution. The initial condition, $u_0(x)$, is parameterized by the center of circle and the radius, i.e., $$u_0(x) = \\cases{ \\displaystyle 2 & for |x-c| < r \\cr \\displaystyle 1 & for |x-c| $\\ge$ r }$$ The goal of the optimal control problem is to find an initial condition that achieves the target last time step temperature distribution. If it does not achieve the target, then it should be closest, given the initial condition parameterization. It is formulated mathematically as an optimization problem: $$ \\underset{c,r}{minimize} \\ || u_T(c,r) - u_{target} ||_2^2,$$ where $u_T$ denotes the last time step temperature and $u_{target}$ denotes the target temperature. Note that $u_T$ depends on the initial condition parameters, i.e., $c$ and $r$. It means that we obtain $u_T$ by solving a forward heat conduction problem. As you can imagine, it needs to explore the parameter space and try to find $c$ and $r$ that produces $u_T$ that best matches $u_{target}$. If each solution process of heat conduction problem is computationally expensive, the search for the optimal parameter can take a while. Therefore, we use our parametric DMD to expedite the process and the search algorithm is done by the differential evolution . Here are the steps to solve the optimal control problem. First, you must delete any post-processed files from the previous differential evolution run. For example, rm -rf parameters.txt rm -rf de_parametric_heat_conduction_greedy_* Then create parametric DMD using a greedy approach with physics-informed error indicator: de_parametric_heat_conduction_greedy -build_database -rdim 16 -greedy-param-size 20 -greedysubsize 10 -greedyconvsize 15 -greedyreldifftol 0.0001 Then you can generate target temperature field with a specific $r$ and $c$ values. Here we used $r=0.2$, $cx=0.2$, and $cy=0.2$ to generate a target temperature field. The target temperature field is shown in the picture above (the one on the left). Therefore, if DMD is good enough, the differential evolution should be able to find $c$ and $r$ values that are closed to these: de_parametric_heat_conduction_greedy -r 0.2 -cx 0.2 -cy 0.2 -visit (Compute target FOM) where r, cx, and cy specify the radius, the x and y coordinates of circular initial conditions. Now you can run the differential evolution using the parametric DMD: de_parametric_heat_conduction_greedy -r 0.2 -cx 0.2 -cy 0.2 -visit -de -de_f 0.9 -de_cr 0.9 -de_ps 50 -de_min_iter 10 -de_max_iter 100 -de_ct 0.001 (Run interpolative differential evolution to see if target FOM can be matched) The differential evolution should be able to find the following optimal control parameters, e.g., in Quartz: $r=0.2002090156652667$, $cx=0.2000936529076073$, and $cy=0.2316380936755735$, which are close to the true parameters that were used to generate the targer temperature field. The DMD temperature field at the last time step on this control parameters is shown in the picture above (the one on the right). The code that generates the numerical results above can be found in ( de_parametric_heat_conduction_greedy.cpp ). The de_parametric_heat_conduction_greedy.cpp is based on ex16p.cpp from MFEM.","title":"Optimal Control DMD heat conduction with Differential Evolution"},{"location":"examples.html#mixed-nonlinear-diffusion","text":"For a given initial condition, i.e., $p_0(x) = p(0,x)$, mixed nonlinear diffusion problem solves a simple 2D/3D time dependent nonlinear problem: $$\\frac{\\partial p}{\\partial t} + \\nabla\\cdot \\boldsymbol{v} = f\\,, \\qquad \\nabla p = -a(p)\\boldsymbol{v},$$ with a natural insulating boundary condition $\\frac{\\partial v}{\\partial n}=0$. The $H(div)$-conforming Raviart-Thomas finite element space is used for the velocity function $\\boldsymbol{v}$, and the $L^2$ finite element space is used for pressure function, $p$. This example introduces how the hyper-reduction is implemented and how the reduced bases for two field varibles, $p$ and $\\boldsymbol{v}$. One can run the following command line options to reproduce the DMD results summarized in the table below: offline1 : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -offline -id 0 -sh 0.25 offline2 : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -offline -id 1 -sh 0.15 merge : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -merge -ns 2 offline3 : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -offline -id 2 -sh 0.2 online : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -online -rrdim 8 -rwdim 8 -sh 0.2 -id 2 FOM solution time ROM solution time Speed-up Solution relative error 41.68 sec 1.7 sec 24.5 1.6e-3 The code that generates the numerical results above can be found in ( mixed_nonlinear_diffusion.cpp ). The mixed_nonlinear_diffusion.cpp is based on ex16p.cpp from MFEM and modified to support mixed finite element approach.","title":"Mixed nonlinear diffusion"},{"location":"examples.html#1d-linear-advection-discontinuous-pulses","text":"For a given initial condition, i.e., $u_0(x) = u(0,x)$, 1D linear advection of the form $$\\frac{\\partial u}{\\partial t} + c\\frac{\\partial x}{\\partial t} = 0,$$ where $c$ is advection velocity. The initial condition, $u_0(x)$, is given by $$u_0(x) = \\cases{ \\displaystyle exp\\left (-log(2)\\frac{(x+7)^2}{0.0009}\\right ) & for -0.8 $\\le$ x $\\le$ -0.6 \\cr \\displaystyle 1 & for -0.4 $\\le$ x $\\le$ -0.2 \\cr \\displaystyle 1-|10(x-0.1)| & for 0 $\\le$ x $\\le$ 0.2 \\cr \\displaystyle \\sqrt{1-100(x-0.5)^2} & for 0.4 $\\le$ x $\\le$ 0.6 \\cr \\displaystyle 0 & \\text{otherwise} }$$ The DMD is applied to accelerate the advection simulation: FOM solution time DMD setup time DMD query time 3.85 sec 0.18 sec 0.027 sec The instruction of running this simulation can be found at the HyPar page, e.g., go to Examples -> libROM Examples -> 1D Linear Advection-Discontinuous Waves.","title":"1D linear advection - Discontinuous pulses"},{"location":"examples.html#advection","text":"For a given initial condition, i.e., $u_0(x) = u(0,x)$, DG advection solves the time-dependent advection problem: $$\\frac{\\partial u}{\\partial t} + v\\cdot\\nabla u = 0,$$ where $v$ is a given advection velocity. We choose velocity function so that the dynamics form a spiral advection. One can run the following command line options to reproduce the DMD results summarized in the table below: dg_advection -p 3 -rp 1 -dt 0.005 -tf 4 FOM solution time DMD setup time DMD query time DMD relative error 5.2 sec 30.6 sec 1.9e-2 sec 1.9e-4 The code that generates the numerical results above can be found in ( dg_advection.cpp ). The dg_advection.cpp is based on ex9p.cpp from MFEM.","title":"Advection"},{"location":"examples.html#local-prom-advection","text":"For a given initial condition, i.e., $u_0(x) = u(0,x)$, DG advection solves the time-dependent advection problem: $$\\frac{\\partial u}{\\partial t} + v\\cdot\\nabla u = 0,$$ where $v$ is a given advection velocity. We choose velocity function so that the dynamics form a spiral advection. This example illustrates how a parametric PROM can be built through local ROM interpolation techniques. The following sequence of command lines will let you build such a parametric PROM, where the frequency of sinusoidal initial condition function is used as a parameter (its value is passed by a user through -ff command line option). Two local PROMs are constructed through -offline option with parameter values of 1.02 and 1.08, then the local PROM operators are interpolated to build a tailored local PROM at the frequency value of 1.05. Unlike the global ROM, the interpolated PROM has dimension that is the same as the individual PROM, i.e., 40 for this particular problem. rm -rf frequencies.txt ./dg_advection_local_rom_matrix_interp --mesh \"../data/periodic-square.mesh\" -offline -rs 4 -ff 1.02 ./dg_advection_local_rom_matrix_interp --mesh \"../data/periodic-square.mesh\" -interp_prep -rs 4 -ff 1.02 -rdim 40 ./dg_advection_local_rom_matrix_interp --mesh \"../data/periodic-square.mesh\" -offline -rs 4 -ff 1.08 ./dg_advection_local_rom_matrix_interp --mesh \"../data/periodic-square.mesh\" -interp_prep -rs 4 -ff 1.08 -rdim 40 ./dg_advection_local_rom_matrix_interp --mesh \"../data/periodic-square.mesh\" -fom -rs 4 -ff 1.05 -visit ./dg_advection_local_rom_matrix_interp --mesh \"../data/periodic-square.mesh\" -online_interp -rs 4 -ff 1.05 -rdim 40 FOM solution time PROM solution time PROM speed-up PROM relative error 39.38 sec 0.63 sec 62.5 1.19e-2 The code that generates the numerical results above can be found in ( dg_advection_local_rom_matrix_interp.cpp ). The dg_advection_local_rom_matrix_interp.cpp is based on ex9p.cpp from MFEM.","title":"Local PROM Advection"},{"location":"examples.html#1d-euler-equation-sod-shock-tube","text":"1D Euler equations of the form $$ \\frac{\\partial \\rho}{\\partial t} + \\frac{\\partial \\rho u}{\\partial x} = 0$$ $$ \\frac{\\partial \\rho u}{\\partial t} + \\frac{\\partial \\rho u^2 + p}{\\partial x} = 0$$ $$ \\frac{\\partial e}{\\partial t} + \\frac{\\partial (e+p)u}{\\partial x} = 0$$ is solved with the initial condition given by $$ \\rho = 1, u = 0, p = 1 \\text{ for } 0 \\le x < 0.5$$ $$ \\rho = 0.125, u = 0, p = 0.1 \\text{ for } 0.5 \\le x \\le 1$$. The DMD is applied to accelerate the 1D Sod shock tube simulation: FOM solution time DMD setup time DMD query time 0.86 sec 0.13 sec 0.0027 sec The instruction of running this simulation can be found at the HyPar page, e.g., go to Examples -> libROM Examples -> 1D Sod Shock Tube.","title":"1D Euler Equation, Sod Shock Tube"},{"location":"examples.html#2d-euler-equation-isentropic-vortex-convection","text":"2D Compressible Euler equations of the form $$ \\frac{\\partial \\rho}{\\partial t} + \\frac{\\partial \\rho u}{\\partial x} + \\frac{\\partial \\rho v}{\\partial y}= 0$$ $$ \\frac{\\partial \\rho u}{\\partial t} + \\frac{\\partial \\rho u^2 + p}{\\partial x} + \\frac{\\partial \\rho uv}{\\partial y} = 0$$ $$ \\frac{\\partial \\rho v}{\\partial t} + \\frac{\\partial \\rho uv}{\\partial x} + \\frac{\\partial \\rho v^2 + p}{\\partial y} = 0$$ $$ \\frac{\\partial e}{\\partial t} + \\frac{\\partial (e+p)u}{\\partial x} + \\frac{\\partial (e+v)p}{\\partial y} = 0$$ is solved with the free-stream condition given by $$ \\rho_\\infty = 1, u_\\infty = 0.1, v_\\infty = 0, p_\\infty = 1 $$ and a vortex is introduced by $$ \\rho = \\left ( 1-\\frac{(\\gamma-1)b^2}{8\\gamma \\pi^2} e^{1-r^2} \\right )^{\\frac{1}{r-1}}, p = \\rho^\\gamma$$ $$ u = u_\\infty - \\frac{b}{2\\pi} e^{\\frac{1}{2}(1-r^2)}(y-y_c)$$ $$ v = v_\\infty + \\frac{b}{2\\pi} e^{\\frac{1}{2}(1-r^2)}(x-x_c),$$ where $b=0.5$ is the vortex strength and $r = \\left ( (x-x_c)^2 + (y-y_c)^2 \\right )^{\\frac{1}{2}}$ is the distance from the vortex center $(x_c,y_c) = (5,5)$. The DMD is applied to accelerate the vortex convection simulation: FOM solution time DMD setup time DMD query time 5.85 sec 5.25 sec 0.28 sec The instruction of running this simulation can be found at the HyPar page, e.g., go to Examples -> libROM Examples -> 2D Euler Equations - Isentropic Vortex Convection.","title":"2D Euler Equation, Isentropic Vortex Convection"},{"location":"examples.html#2d-euler-equation-riemann-problem","text":"2D Compressible Euler equations of the form $$ \\frac{\\partial \\rho}{\\partial t} + \\frac{\\partial \\rho u}{\\partial x} + \\frac{\\partial \\rho v}{\\partial y}= 0$$ $$ \\frac{\\partial \\rho u}{\\partial t} + \\frac{\\partial \\rho u^2 + p}{\\partial x} + \\frac{\\partial \\rho uv}{\\partial y} = 0$$ $$ \\frac{\\partial \\rho v}{\\partial t} + \\frac{\\partial \\rho uv}{\\partial x} + \\frac{\\partial \\rho v^2 + p}{\\partial y} = 0$$ $$ \\frac{\\partial e}{\\partial t} + \\frac{\\partial (e+p)u}{\\partial x} + \\frac{\\partial (e+v)p}{\\partial y} = 0$$ is solved. The DMD is applied to accelerate the Riemann problem: FOM solution time DMD setup time DMD query time 111.1 sec 17.6 sec 1.4 sec The instruction of running this simulation can be found at the HyPar page, e.g., go to Examples -> libROM Examples -> 2D Euler Equations - Riemann Problem Case 4","title":"2D Euler Equation, Riemann Problem"},{"location":"examples.html#euler-equation","text":"For a given initial condition, i.e., $u_0(x) = u(0,x)$, DG Euler solves the compressible Euler system of equation, i.e., a model nonlinear hyperbolic PDE: $$\\frac{\\partial u}{\\partial t} + \\nabla\\cdot \\boldsymbol{F}(u) = 0,$$ with a state vector $\\boldsymbol{u} = [\\rho,\\rho v_0, \\rho v_1, \\rho E]$, where $\\rho$ is the density, $v_i$ is the velocity in the $i$th direction, $E$ is the total specific energy, and $H = E + p/\\rho$ is the total specific enthalpy. The pressure, $p$ is computed through a simple equation of state (EOS) call. The conservative hydrodynamic flux $\\boldsymbol{F}$ in each direction $i$ is $$\\boldsymbol{F}_i = [\\rho v_i, \\rho v_0 v_i + p \\delta_{i,0}, \\rho v_1 v_{i,1} + p\\delta_{i,1}, \\rho v_i H]$$ One can run the following command line options to reproduce the DMD results summarized in the table below: mpirun -n 8 ./dg_euler -p 2 -rs 2 -rp 1 -o 1 -s 3 -visit DMD rel.error FOM solution time DMD setup time DMD query time $\\rho$ $\\rho v_0$ $\\rho v_1$ $E$ 5.65 sec 38.9 sec 1.4e-3 sec 8.0e-7 1.2e-4 1.6e-3 2.6e-6 The code that generates the numerical results above can be found in ( dg_euler.cpp ). The dg_euler.cpp is based on ex18p.cpp from MFEM.","title":"Euler equation"},{"location":"examples.html#2d-navierstokes-equations-lid-driven-square-cavity-problem","text":"A lid-driven square cavity problem is solved. The two references for this problem are Erturk, E., Corke, T.C., and Gokcol, C., `` Numerical Solutions of 2-D Steady Incompressible Driven Cavity Flow at High Reynolds Numbers \", International Journal for Numerical Methods in Fluids, 48, 2005 Ghia, U., Ghia, K.N., Shin, C.T., `` High-Re Solutions for Incompressible Flow using the Navier-Stokes Equations and a Multigrid Method \", Journal of Computational Physics, 48, 1982 The DMD is applied to accelerate the cavity flow simulation: FOM solution time DMD setup time DMD query time 554.6 sec 58.6 sec 0.3 sec The instruction of running this simulation can be found at the HyPar page, e.g., go to Examples -> libROM Examples -> 2D Navier-Stokes Equations - Lid-Driven Square Cavity","title":"2D Navier\u2013Stokes Equations, Lid-driven square cavity problem"},{"location":"examples.html#1d-1v-vlasov-equation-two-stream-instability","text":"The 1D-1V Vlasov equatoin is solved with the initial condition given by $$ f(x,v) = \\frac{4}{\\pi T} \\left ( 1+\\frac{1}{10} cos(2k\\pi\\frac{x}{L}) \\right ) \\left ( \\exp\\left( -\\frac{(v-2)^2}{2T} \\right) + \\exp\\left( -\\frac{(v+2)^2}{2T} \\right ) \\right ), k=1, T=1, L=2\\pi. $$ The DMD is applied to accelerate the cavity flow simulation: FOM solution time DMD setup time DMD query time 11.34 sec 2.30 sec 0.34 sec The instruction of running this simulation can be found at the HyPar page, e.g., go to Examples -> libROM Examples -> 2D (1D-1V) Vlasov Equation.","title":"1D-1V Vlasov Equation, Two-Stream Instability"},{"location":"examples.html#linear-elasticity","text":"This example demonstrates how to apply projection-based ROM to a linear elasticity problem. The linear elasiticity problem describes a multi-material cantilever beam. Specifically, the following weak form is solved: $$-\\text{div}(\\sigma(\\boldsymbol{u})) = 0$$ where $$\\sigma(\\boldsymbol{u}) = \\lambda \\text{div}(\\boldsymbol{u}) \\boldsymbol{I} + \\mu (\\nabla \\boldsymbol{u} + \\nabla \\boldsymbol{u}^T)$$ is the stress tensor corresponding to displacement field $\\boldsymbol{u}$, and $\\lambda$ and $\\mu$ are the material Lame constants. The Lame constants are related to Young's modulus ($E$) and Poisson's ratio ($\\nu$) as $$\\lambda = \\frac{E\\nu}{(1+\\nu)(1-2\\nu)}$$ $$\\mu = \\frac{E}{2(1+\\nu)}$$ The boundary condition are $\\boldsymbol{u}=\\boldsymbol{0}$ on the fixed part of the boundary with attribute 1, and $\\sigma(\\boldsymbol{u})\\cdot n = f$ on the remainder with f being a constant pull down vector on boundary elements with attribute 2, and zero otherwise. The geometry of the domain is assumed to be as follows: Three distinct steps are required, i.e., offline, merge, and online steps, to build global ROM for the linear elasticity problem. The general description of building a global ROM is explained in this YouTube tutorial video . We parameterized Poisson's ratio ($\\nu$) from 0.2 to 0.4. One can run the following command line options to reproduce the DMD results summarized in the table below: offline phase : ./linear_elasticity_global_rom --mesh \"../../../dependencies/mfem/data/beam-hex-nurbs.mesh\" -offline -id 0 -nu 0.2 offline phase : ./linear_elasticity_global_rom --mesh \"../../../dependencies/mfem/data/beam-hex-nurbs.mesh\" -offline -id 1 -nu 0.4 merge phase : ./linear_elasticity_global_rom --mesh \"../../../dependencies/mfem/data/beam-hex-nurbs.mesh\" -merge -ns 2 fom phase : ./linear_elasticity_global_rom --mesh \"../../../dependencies/mfem/data/beam-hex-nurbs.mesh\" -offline -id 2 -nu 0.XX online phase : ./linear_elasticity_global_rom --mesh \"../../../dependencies/mfem/data/beam-hex-nurbs.mesh\" -online -id 3 -nu 0.XX You can replace 0.XX with any value between 0.2 and 0.5. It must be strictly less than 0.5. Note that the global ROM is able to predict the point outside of the training region with high accuracy, i.e., $\\nu=0.45$. The table below shows the performance results for three different parameter points. Poisson's ratio ($\\nu$) FOM solution time ROM solving time Position relative error 0.25 4.96e-2 sec 3.54e-6 sec 0.00081 0.3 4.93e-2 sec 4.37e-6 sec 0.00133 0.35 5.96e-2 sec 4.60e-6 sec 0.00121 0.45 5.22e-2 sec 4.36e-6 sec 0.00321 The code that generates the numerical results above can be found in ( linear_elasticity_global_rom.cpp ). The linear_elasticity_global_rom.cpp is based on ex2p.cpp from MFEM.","title":"Linear elasticity"},{"location":"examples.html#nonlinear-elasticity-prom","text":"For a given initial condition, i.e., $v_0(x) = v(0,x)$, nonlinear elasticity solves a time dependent nonlinear elasticity problem of the form $$\\frac{\\partial v}{\\partial t} = H(x) + Sv\\,, \\qquad \\frac{\\partial x}{\\partial t} = v,$$ where $H$ is a hyperelastic model and $S$ is a viscosity operator of Laplacian type. The initial displacement is set zero and the initial velocity is set as zero except the third component which is defined: $$v_3(0,x) = -\\frac{\\mu}{80}\\sin(\\mu x_1)$$ One can run the following command line options to build global ROM and reproduce the results summarizedin the table below. You can replace XXX in the fom and online phase to take any $\\mu$ value between 3.9 and 4.1: offline phase : ./nonlinear_elasticity_global_rom --mesh \"../../../dependencies/mfem/data/beam-hex-nurbs.mesh\" --offline -dt 0.01 -tf 5.0 -s 14 -vs 10 -sc 3.9 -id 0 offline phase : ./nonlinear_elasticity_global_rom --mesh \"../../../dependencies/mfem/data/beam-hex-nurbs.mesh\" --offline -dt 0.01 -tf 5.0 -s 14 -vs 10 -sc 4.1 -id 1 merge phase : ./nonlinear_elasticity_global_rom --mesh \"../../../dependencies/mfem/data/beam-hex-nurbs.mesh\" --merge -ns 2 -dt 0.01 -tf 5.0 fom phase : ./nonlinear_elasticity_global_rom --mesh \"../../../dependencies/mfem/data/beam-hex-nurbs.mesh\" --offline -dt 0.01 -tf 5.0 -s 14 -vs 5 -sc XXX -id 2 online phase : ./nonlinear_elasticity_global_rom --mesh \"../../../dependencies/mfem/data/beam-hex-nurbs.mesh\" --online -dt 0.01 -tf 5.0 -s 14 -vs 5 -hyp -rvdim 40 -rxdim 10 -hdim 71 -nsr 200 -sc XXX $\\mu$ FOM solution time PROM online time Speed-up Position relative error 3.92 164.9 sec 20.5 sec 8.0 0.0053 3.94 169.2 sec 20.8 sec 8.1 0.0053 3.96 167.8 sec 20.9 sec 8.0 0.0057 3.98 162.7 sec 22.1 sec 7.4 0.0062 4.0 169.4 sec 21.1 sec 8.0 0.0067 4.02 168.4 sec 20.8 sec 8.1 0.0071 4.04 160.6 sec 22.8 sec 7.0 0.0073 4.06 173.4 sec 22.7 sec 7.6 0.0071 4.08 169.2 sec 20.0 sec 8.5 0.0066 The code that generates the numerical results above can be found in ( nonlinear_elasticity_global_rom.cpp ). The nonlinear_elasticity_global_rom.cpp is based on ex10p.cpp from MFEM.","title":"Nonlinear elasticity, PROM"},{"location":"examples.html#nonlinear-elasticity-dmd","text":"For a given initial condition, i.e., $v_0(x) = v(0,x)$, nonlinear elasticity solves a time dependent nonlinear elasticity problem of the form $$\\frac{\\partial v}{\\partial t} = H(x) + Sv\\,, \\qquad \\frac{\\partial x}{\\partial t} = v,$$ where $H$ is a hyperelastic model and $S$ is a viscosity operator of Laplacian type. One can run the following command line options to reproduce the DMD results summarized in the table below: mpirun -np 8 ./nonlinear_elasticity -s 2 -rs 1 -dt 0.01 -tf 5 -visit FOM solution time DMD setup time DMD query time Position relative error Velocity relative error 10.4 sec 2.9e-1 sec 1.1 sec 7.0e-5 1.4e-3 The code that generates the numerical results above can be found in ( nonlinear_elasticity.cpp ). The nonlinear_elasticity.cpp is based on ex10p.cpp from MFEM.","title":"Nonlinear elasticity, DMD"},{"location":"examples.html#laghos-rom-miniapp","text":"Laghos (LAGrangian High-Order Solver) is a miniapp that solves the time-dependent Euler equations of compressible gas dynamics in a moving Lagrangian frame using unstructured high-order finite element spatial discretization and explicit high-order time-stepping. LaghosROM introduces reduced order models of Laghos simulations. A list of example problems that you can solve with LaghosROM includes Sedov blast, Gresho vortex, Taylor-Green vortex, triple-point, and Rayleigh-Taylor instability problems. Below are command line options for each problems and some numerical results. For each problem, four different phases need to be taken, i.e., the offline, hyper-reduction preprocessing, online, and restore phase. The online phase runs necessary full order model (FOM) to generate simulation data. libROM dynamically collects the data as the FOM simulation marches in time domain. In the hyper-reduction preprocessing phase, the libROM builds a library of reduced basis as well as hyper-reduction operators. The online phase runs the ROM and the restore phase projects the ROM solutions to the full order model dimension.","title":"Laghos ROM Miniapp"},{"location":"examples.html#sedov-blast-problem","text":"Sedov blast problem is a three-dimensional standard shock hydrodynamic benchmark test. An initial delta source of internal energy deposited at the origin of a three-dimensional cube is considered. The computational domain is the unit cube $\\tilde{\\Omega} = [0,1]^3$ with wall boundary conditions on all surfaces, i.e., $v\\cdot n = 0$. The initial velocity is given by $v=0$. The initial density is given by $\\rho = 1$. The initial energy is given by a delta function at the origin. The adiabatic index in the ideal gas equations of state is set $\\gamma = 1.4$. The initial mesh is a uniform Catesian hexahedral mesh, which deforms over time. It can be seen that the radial symmetry is maintained in the shock wave propagation in both FOM and PROM simulations. One can reproduce the PROM numerical result, following the command line options described below: offline : ./laghos -o twp_sedov -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -offline -visit -romsvds -ef 0.9999 -writesol -romos -rostype load -romsns -nwinsamp 21 -sample-stages hyper-reduction preprocessing : ./laghos -o twp_sedov -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -online -romsvds -romos -rostype load -romhrprep -romsns -romgs -nwin 66 -sfacv 2 -sface 2 (-sopt) online : ./laghos -o twp_sedov -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -online -romsvds -romos -rostype load -romhr -romsns -romgs -nwin 66 -sfacv 2 -sface 2 restore : ./laghos -o twp_sedov -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -restore -soldiff -romsvds -romos -rostype load -romsns -romgs -nwin 66 FOM solution time ROM solution time Speed-up Velocity relative error (DEIM) Velocity relative error (SOPT) 191 sec 8.3 sec 22.8 2.2e-4 1.1e-4 One can also easily apply time-windowing DMD to Sedov blast problem easily. First, prepare tw_sedov3.csv file, which contains a sequence of time steps, {0.01, 0.02, $\\ldots$, 0.79, 0.8 } in a column. Then you can follow the command line options described below: offline : mpirun -np 8 ./laghos -o dmd_sedov -p 4 -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -offline -visit -romsvds -ef 0.9999 -writesol -nwin 80 -tw tw_sedov3.csv -dmd -dmdnuf -met -no-romoffset online : mpirun -np 8 ./laghos -o dmd_sedov -p 4 -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -restore -soldiff -romsvds -dmd -dmdnuf -no-romoffset FOM solution time DMD restoration time Speed-up Velocity relative error 30.4 sec 15.0. sec 2.0 0.0382461","title":"Sedov blast problem"},{"location":"examples.html#gresho-vortex-problem","text":"Gresho vortex problem is a two-dimensional benchmark test for the incompressible inviscid Navier-Stokes equations. The computational domain is the unit square $\\tilde\\Omega = [-0.5,0.5]^2$ with wall boundary conditions on all surfaces, i.e., $v\\dot n = 0$. Let $(r,\\phi)$ denote the polar coordinates of a particle $\\tilde{x} \\in \\tilde{\\Omega}$. The initial angular velocity is given by $$v_\\phi = \\cases{ \\displaystyle 5r & for 0 $\\leq$ r < 0.2 \\cr \\displaystyle 2-5r & for 0.2 $\\leq$ r < 0.4 \\cr \\displaystyle 0 i & for r $\\geq$ 0.4. }$$ The initial density if given by $\\rho=1$. The initial thermodynamic pressure is given by $$p = \\cases{ 5 + \\frac{25}{2} r^2 & for 0 $\\leq$ r < 0.2 \\cr 9 - 4 \\log(0.2) + \\frac{25}{2} - 20r + 4 \\log(r) & for 0.2 $\\leq$ r < 0.4 \\cr 3 + 4\\log(2) & for r $\\geq$ 0.4 }$$ offline : ./laghos -o twp_gresho -p 4 -m ../data/square_gresho.mesh -rs 4 -ok 3 -ot 2 -tf 0.62 -s 7 -visit -writesol -offline -ef 0.9999 -romsvds -romos -rostype load -romsns -nwinsamp 21 -sample-stages hyper-reduction preprocessing : ./laghos -o twp_gresho -p 4 -m ../data/square_gresho.mesh -rs 4 -ok 3 -ot 2 -tf 0.62 -s 7 -online -romhrprep -romsvds -romos -rostype load -romsns -romgs -nwin 152 -sfacv 2 -sface 2 online : ./laghos -o twp_gresho -p 4 -m ../data/square_gresho.mesh -rs 4 -ok 3 -ot 2 -tf 0.62 -s 7 -online -romhr -romsvds -romos -rostype load -romsns -romgs -nwin 152 -sfacv 2 -sface 2 restore : ./laghos -o twp_gresho -p 4 -m ../data/square_gresho.mesh -rs 4 -ok 3 -ot 2 -tf 0.62 -s 7 -soldiff -restore -romsvds -romos -rostype load -romsns -romgs -nwin 152 FOM solution time ROM solution time Speed-up Velocity relative error 218 sec 8.4 sec 25.9 2.1e-4","title":"Gresho vortex problem"},{"location":"examples.html#taylor-green-vortex","text":"Taylor-Green vortex problem is a three-dimensional benchmark test for the incompressible Navier-Stokes equasions. A manufactured smooth solution is considered by extending the steady state Taylor-Green vortex solution to the compressible Euler equations. The computational domain is the unit cube $\\tilde{\\Omega}=[0,1]^3$ with wall boundary conditions on all surfaces, i.e., $v\\cdot n = 0$. The initial velocity is given by $$ v = (\\sin{(\\pi x)} \\cos{(\\pi y)} \\cos{(\\pi z)}, -\\cos{(\\pi x)}\\sin{(\\pi y)}\\cos{(\\pi z)}, 0) $$ The initial density is given by $\\rho =1$. The initial thermodynamic pressure is given by $$ p = 100 + \\frac{(\\cos{(2\\pi x)} + \\cos{(2\\pi y))(\\cos{(2\\pi z)+2})-2}}{16} $$ The initial energy is related to the pressure and the density by the equation of state for the ideal gas, $p=(\\gamma-1)\\rho e$, with $\\gamma = 5/3$. The initial mesh is a uniform Cartesian hexahedral mesh, which deforms over time. The visualized solution is given on the right. One can reproduce the numerical result, following the command line options described below: offline : ./laghos -o twp_taylor -m ../data/cube01_hex.mesh -p 0 -rs 2 -cfl 0.1 -tf 0.25 -s 7 -pa -offline -visit -romsvds -ef 0.9999 -writesol -romos -rostype load -romsns -nwinsamp 21 -sdim 1000 -sample-stages hyper-reduction preprocessing : ./laghos -o twp_taylor -m ../data/cube01_hex.mesh -p 0 -rs 2 -cfl 0.1 -tf 0.25 -s 7 -pa -online -romsvds -romos -rostype load -romhrprep -romsns -romgs -nwin 82 -sfacv 2 -sface 2 online : ./laghos -o twp_taylor -m ../data/cube01_hex.mesh -p 0 -rs 2 -cfl 0.1 -tf 0.25 -s 7 -pa -online -romsvds -romos -rostype load -romhr -romsns -romgs -nwin 82 -sfacv 2 -sface 2 restore : ./laghos -o twp_taylor -m ../data/cube01_hex.mesh -p 0 -rs 2 -cfl 0.1 -tf 0.25 -s 7 -pa -restore -soldiff -romsvds -romos -rostype load -romsns -romgs -nwin 82 FOM solution time ROM solution time Speed-up Velocity relative error 170 sec 5.4 sec 31.2 1.1e-6","title":"Taylor-Green vortex"},{"location":"examples.html#triple-point-problem","text":"Triple-point problem is a three-dimensional shock test with two materials in three states. The computational domain is $\\tilde{\\Omega} = [0,7] \\times [0,3 ] \\times [0,1.5]$ with wall boundary conditions on all surfaces, i.e., $v\\cdot n = 0$. The initial velocity is given by $v=0$. The initial density is given by $$\\rho = \\cases{ \\displaystyle 1 & for x $\\leq$ 1 or y $\\leq$ 1.5, \\cr \\displaystyle 1/8 & for x $>$ 1 and y $>$ 1.5 }$$ The initial thermodynamic pressure is given for $$p = \\cases{ \\displaystyle 1 & for x $\\leq$ 1, \\cr \\displaystyle 0.1 & for x $>$ 1 }$$ The initial energy is related to the pressure and the density by the equation of state for the ideal gas, $p=(\\gamma-1)\\rho e$, with $$\\gamma = \\cases{ \\displaystyle 1.5 & for x $\\leq$ 1 or y $>$ 1.5\\cr \\displaystyle 1.4 & for x $>$ 1 and y $\\leq$ 1.5 }$$ The initial mesh is a uniform Cartesian hexahedral mesh, which deforms over time. The visualized solution is given on the right. One can reproduce the numerical result, following the command line options described below: offline : ./laghos -o twp_triple -p 3 -m ../data/box01_hex.mesh -rs 2 -tf 0.8 -s 7 -cfl 0.5 -pa -offline -writesol -visit -romsvds -romos -rostype load -romsns -nwinsamp 21 -ef 0.9999 -sdim 200 -sample-stages hyper-reduction preprocessing : ./laghos -o twp_triple -p 3 -m ../data/box01_hex.mesh -rs 2 -tf 0.8 -s 7 -cfl 0.5 -pa -online -romhrprep -romsvds -romos -rostype load -romgs -romsns -nwin 18 -sfacv 2 -sface 2 online : ./laghos -o twp_triple -p 3 -m ../data/box01_hex.mesh -rs 2 -tf 0.8 -s 7 -cfl 0.5 -pa -online -romhr -romsvds -romos -rostype load -romgs -romsns -nwin 18 -sfacv 2 -sface 2 restore : ./laghos -o twp_triple -p 3 -m ../data/box01_hex.mesh -rs 2 -tf 0.8 -s 7 -cfl 0.5 -pa -restore -soldiff -romsvds -romos -rostype load -romgs -romsns -nwin 18 FOM solution time ROM solution time Speed-up Velocity relative error 122 sec 1.4 sec 87.8 8.1e-4","title":"Triple-point problem"},{"location":"examples.html#rayleigh-taylor-instability-problem","text":"Rayleigh-Taylor instability problem offline : ./laghos -p 7 -m ../data/rt2D.mesh -tf 1.5 -rs 4 -ok 2 -ot 1 -pa -o twp_rt -s 7 -writesol -offline -romsns -sdim 200000 -romsvds -romos -romgs -nwinsamp 21 -ef 0.9999999999 -sample-stages hyper-reduction preprocessing : ./laghos -p 7 -m ../data/rt2D.mesh -tf 1.5 -rs 4 -ok 2 -ot 1 -pa -o twp_rt -s 7 -online -romsns -romos -romgs -nwin 187 -sfacv 2 -sface 2 -romhrprep online : ./laghos -p 7 -m ../data/rt2D.mesh -tf 1.5 -rs 4 -ok 2 -ot 1 -pa -o twp_rt -s 7 -online -romsns -romos -romgs -nwin 187 -sfacv 2 -sface 2 -romhr restore : ./laghos -p 7 -m ../data/rt2D.mesh -tf 1.5 -rs 4 -ok 2 -ot 1 -pa -o twp_rt -s 7 -restore -romsns -romos -romgs -soldiff -nwin 187 FOM solution time ROM solution time Speed-up Velocity relative error 127 sec 8.7 sec 14.6 7.8e-3 LaghosROM is an external miniapp, available at https://github.com/CEED/Laghos/tree/rom/rom . No examples or miniapps match your criteria. <!-- function showElement(id, show) { //document.getElementById(id).style.display = show ? \"block\" : \"none\"; // workaround because Doxygen splits and duplicates the divs for some reason var divs = document.getElementsByTagName(\"div\"); for (i = 0; i < divs.length; i++) { if (divs.item(i).id == id) { divs.item(i).style.display = show ? \"block\" : \"none\"; } } return show ? 1 : 0; } function getBooleans(comboId) { combo = document.getElementById(comboId); first_selected = false; for (i = 0; i < combo.options.length; i++) { opt = combo.options[i]; selected = opt.selected || first_selected; if (!i) { first_selected = selected; } // create a boolean variable named after the option this[opt.id] = selected; } } function update() { getBooleans(\"group1\"); getBooleans(\"group2\"); getBooleans(\"group3\"); getBooleans(\"group4\"); getBooleans(\"group5\"); getBooleans(\"group6\"); numShown = 0 // expression continued... // example codes + showElement(\"poisson\", (diffusion) && (prom) && (global) && (no_hr) && (mfem) && (no_optimizer)) + showElement(\"poisson_greedy_prom\", (diffusion) && (prom) && (global) && (no_hr) && (mfem) && (no_optimizer)) + showElement(\"dg_advection\", (advection) && (dmd) && (reproductive) && (no_hr) && (mfem) && (no_optimizer)) + showElement(\"local_prom_dg_advection\", (advection) && (prom) && (interpolation) && (no_hr) && (mfem) && (no_optimizer)) + showElement(\"dg_euler\", (euler) && (dmd) && (reproductive) && (no_hr) && (mfem) && (no_optimizer)) + showElement(\"heat_conduction\", (diffusion) && (dmd) && (reproductive) && (no_hr) && (mfem) && (no_optimizer)) + showElement(\"parametric_dmd_heat_conduction\", (diffusion) && (dmd) && (interpolation) && (no_hr) && (mfem) && (no_optimizer) ) + showElement(\"optimal_control_dmd_heat_conduction\", (diffusion) && (dmd) && (interpolation) && (no_hr) && (mfem) && (de) ) + showElement(\"mixed_nonlinear_diffusion\", (diffusion) && (prom) && (global) && (hr) && (mfem) && (no_optimizer) ) + showElement(\"linear_elasticity\", (elasticity) && (prom) && (global) && (no_hr) && (mfem) && (no_optimizer) ) + showElement(\"nonlinear_elasticity_prom\", (elasticity) && (prom) && (global) && (hr) && (mfem) && (no_optimizer) ) + showElement(\"nonlinear_elasticity_dmd\", (elasticity) && (dmd) && (reproductive) && (no_hr) && (mfem) && (no_optimizer) ) + showElement(\"laghos\", (hydro) && (prom) && (global) && (hr) && (laghos) & (no_optimizer)) + showElement(\"1DdiscontinuousPulse\", (advection) && (dmd) && (reproductive) && (no_hr) && (hypar) && (no_optimizer)) + showElement(\"1DSodShockTube\", (euler) && (dmd) && (reproductive) && (no_hr) && (hypar) && (no_optimizer)) + showElement(\"2DEulerVortexConvection\", (euler) && (dmd) && (reproductive) && (no_hr) && (hypar) && (no_optimizer)) + showElement(\"2DEulerRiemannProblem\", (euler) && (dmd) && (reproductive) && (no_hr) && (hypar) && (no_optimizer)) + showElement(\"2DNavierStokesProblem\", (navierstokes) && (dmd) && (reproductive) && (no_hr) && (hypar) && (no_optimizer)) + showElement(\"1D1VVlasovEquation\", (vlasov) && (dmd) && (reproductive) && (no_hr) && (hypar) && (no_optimizer)) ; // ...end of expression // show/hide the message \"No examples match your criteria\" showElement(\"nomatch\", numShown == 0); } function initCombos() { var query = location.search.substr(1); query.split(\"&\").forEach(function(id) { if (id) { opt = document.getElementById(id); if (opt) { opt.selected = true; } } }); } // make sure \"no match\" div is not visible after page is loaded window.onload = update; // force vertical scrollbar document.getElementsByTagName(\"body\")[0].style = \"overflow-y: scroll\" // parse URL part after '?', e.g., http://.../index.html?elasticity&nurbs initCombos(); //-->","title":"Rayleigh-Taylor instability problem"},{"location":"features.html","text":"MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}}); Features The goal of libROM is to provide high-performance scalable library for data-driven reduced order modeling. Proper orthogonal decomposition One of the core features in libROM is the ability to extract important modes from given physical simulation data. The proper othogonal decomposition (POD) is a popular method for compressing physical simulation data to obtain optimal \"reduced\" bases in the following sense: $$\\boldsymbol{\\Phi} =\\underset{\\boldsymbol{A}\\in\\mathbb{R}^{n\\times r}, \\boldsymbol{A}^T\\boldsymbol{A} = \\boldsymbol{I}_{r\\times r} }{\\arg\\min} || \\boldsymbol{U} - \\boldsymbol{A}\\boldsymbol{A}^T\\boldsymbol{U} ||_F^2, $$ where $\\boldsymbol{U}\\in\\mathbb{R}^{n\\times m}$ is simulation data and $\\boldsymbol{I}_{r\\times r} \\in \\mathbb{R}^{r\\times r}$ denotes an identity matrix. That is, the POD tries to find the orthogonal matrix, $\\boldsymbol{\\Phi}$, whose span minimizes the projection error in the Frobenius norm. The POD modes can be obtained in two equivalent ways: (i) eigenvalue decomposition and (ii) singular value decomposition (SVD). We take the latter approach, i.e., let's say the thin SVD of $\\boldsymbol{U}$ is given by $$\\boldsymbol{U} = \\boldsymbol{W\\Sigma V}^T.$$ Then the solution of the POD is given by taking the first $r$ columns of the left singular matrix, i.e., $\\boldsymbol{\\Phi} = [\\boldsymbol{w}_{1},\\ldots ,\\boldsymbol{w}_r]$, where $\\boldsymbol{w}_k$ is $k$th left singular vector, assuming that the singular value is written in the decreasing order. Efficient data collection High-fidelity physical simulations generate intensive data in its size, which makes the data collection process daunting. Therefore, the libROM aims to ease the difficulty associated with the intensive data size. The libROM can be directly integrated to the physics solver that generates the intensive simulation data. For example, if the physical simulation is time dependent, then each time step solution data can be feed into the libROM incrementally so that the singular value decomposition is efficiently updated in parallel. This approach is incremental SVD . There are other types of SVDs which exploits efficiency. The libROM provides following four SVDs: Static SVD incremental SVD randomized SVD space-time SVD Static SVD The static SVD waits the libROM to collect all the simulation data. Once the snapshot matrix $\\boldsymbol{U}$ is formed, then the SVD is performed. Therefore, if the data size is big, this approach is not efficient and not recommended. However, because it gives the most accurate SVD results, it is ideal for a small problem. Incremental SVD Unlike the static SVD, the incremental SVD does not wait. Instead, as the data comes in, the SVD is performed right away. Because the incremental SVD only needs to find out the effect of one additional simulation data vector to the previous SVD, the update can be done very efficiently without requiring much memory. Therefore, it is useful for large-scale problems. For the detailed explanation about the incremental SVD, we refer to the following journal papers: M. Brand, Incremental singular value decomposition of uncertain data with missing values , In European Conference on Computer Vision , p707-720, 2002 G. Oxberry, T. Kostova-Vassilevska, W. Arrighi, K. Chand, Limited-memory adaptive snapshot selection for proper orthogonal decomposition , International Journal for Numerical Methods in Engineering , 109(2), p198-217, 2016 H. Fareed, J.R. Singler, Error Analysis of an Incremental Proper Orthogonal Decomposition Algorithm for PDE Simulation Data , Journal of Computational and Applied Mathematics , 368, 112525, 2020 Randomized SVD Randomization can bring computational efficiency in computing SVDs. For example, consider that one needs to extract $p$ dominant modes from $n \\times m$ tall dense matrix, using SVD. The randomized SVD requires $\\mathcal{O}(nm\\log(p))$ floating-point operations, while the static SVD algorithm requires $\\mathcal{O}(nmp)$ flops. The randomized SVD that is implemented in libROM can be found in the following journal paper: N. Halko, P.G. Martinsson, J.A. Tropp, Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions . SIAM review , 53(2), p217-288, 2011 Space-time SVD For time dependent problems, one can reduce not only the spatial degrees of freedom, but also the temporal degrees of freedom by representing the space-time solution as a linear combination of a space-time reduced basis. The space-time reduced basis can be mathematically written as a Kronecker product of temporal and spatial bases. Fortunately, one can extract temporal as well as spatial reduced bases from one single SVD. The procedure is schematically depicted in the figure below: For the detailed explanation about the incremental SVD, we refer to the following three journal papers: Y. Kim, K. Wang, Y. Choi, Efficient space\u2013time reduced order model for linear dynamical systems in Python using less than 120 lines of code . Mathematics , 9(14), 1690, 2021 Y. Choi, P. Brown, W. Arrighi, R. Anderson, K. Huynh, Space\u2013time reduced order model for large-scale linear dynamical systems with application to boltzmann transport problems . Journal of Computational Physics , 424, 109845, 2021 Y. Choi, K. Carlberg, Space-time least-squares Petrov-Galerkin projection for nonlinear model reduction , SIAM Journal on Scientific Computing , 41(1), A26-A58, 2019 Dynamic Mode Decomposition The dynamic mode decomposition (DMD) provides a great way of finding an approximate locally linear dynamical system, $$ \\frac{d\\boldsymbol{u}}{dt} = \\mathcal{A}\\boldsymbol{u},$$ for a given nonlinear dynamical system, $$ \\frac{d\\boldsymbol{u}}{dt} = \\boldsymbol{f}(\\boldsymbol{u},t;\\boldsymbol{\\mu}),$$ with initial condition, $\\boldsymbol{u}_0$. It takes non-intrusive approach, i.e., equation-free method, so it is applicable even if there is only data, but no $\\boldsymbol{f}(\\boldsymbol{u},t;\\boldsymbol{\\mu})$. For example, let's say the discrete-time data are given as: $$\\boldsymbol{U} = [\\boldsymbol{u}_1,\\ldots,\\boldsymbol{u}_m],$$ where $\\boldsymbol{u}_k\\in\\mathbb{R}^n$ denotes solution at $t=k\\Delta t$. The DMD is trying to find the best $\\boldsymbol{A}$ such that $$\\boldsymbol{U}^+ = \\boldsymbol{A}\\boldsymbol{U}^-,$$ where $\\boldsymbol{U}^+ = [\\boldsymbol{u}_2,\\ldots,\\boldsymbol{u}_m]$ and $\\boldsymbol{U}^- = [\\boldsymbol{u}_1, \\ldots, \\boldsymbol{u}_{m-1}]$. The following procedure is taken to find the best $\\boldsymbol{A}$. Take the singular value decomposition (SVD) of $\\boldsymbol{U}^-$ $$\\boldsymbol{U}^- \\approx \\boldsymbol{W}\\boldsymbol{\\Omega}\\boldsymbol{V}^*,$$ where $*$ denotes the conjugate transpose, $\\boldsymbol{W}\\in\\mathbb{C}^{n\\times r}$, $\\boldsymbol{\\Sigma}\\in\\mathbb{C}^{r\\times r}$, $\\boldsymbol{V}\\in\\mathbb{C}^{m\\times r}$, and $r \\leq m$. Because $\\boldsymbol{U}^+ = \\boldsymbol{A}\\boldsymbol{U}^-$, using the pseudo-inverse of the approximate $\\boldsymbol{U}^-$, we have $$\\boldsymbol{A} \\approx \\tilde{\\boldsymbol{A}} = \\boldsymbol{U}^+\\boldsymbol{V}\\boldsymbol{\\Omega}^{-1}\\boldsymbol{W}^*$$ It is easier to deal with the reduced operator $\\tilde{\\boldsymbol{A}}_r$, which relates the discrete-time dynamic of reduced states: $$\\tilde{\\boldsymbol{u}}_{k+1} = \\tilde{\\boldsymbol{A}}_r\\tilde{\\boldsymbol{u}}_k,$$ where $\\boldsymbol{u}_k = \\boldsymbol{W} \\tilde{\\boldsymbol{u}}_k$ and $\\tilde{\\boldsymbol{A}}_r$ is defined as $$\\tilde{\\boldsymbol{A}}_r=\\boldsymbol{W}^*\\tilde{\\boldsymbol{A}}\\boldsymbol{W}$$ $$\\tilde{\\boldsymbol{A}}_r=\\boldsymbol{W}^*\\boldsymbol{U}^+\\boldsymbol{V}\\boldsymbol{\\Omega}^{-1}$$ Let the eigen-decomposition of $\\tilde{\\boldsymbol{A}}_r$ to be $$\\tilde{\\boldsymbol{A}}_r \\boldsymbol{X} = \\boldsymbol{\\Lambda}\\boldsymbol{X}$$ and set either $\\boldsymbol{\\Phi} = \\boldsymbol{W}\\boldsymbol{X}$ or $\\boldsymbol{\\Phi} = \\boldsymbol{U}^+ \\boldsymbol{V} \\boldsymbol{\\Omega}^{-1}\\boldsymbol{X}$, then the DMD solution at time, $t$, can be found as $$\\boldsymbol{u}(t) = \\boldsymbol{\\Phi}\\boldsymbol{\\Lambda}^{t/\\Delta t} \\boldsymbol{b}_0,$$ where $\\boldsymbol{b}_0 = \\boldsymbol{\\Phi}^\\dagger \\boldsymbol{u}_0$. For the detailed explanation about the DMD, we refer to the following book: J.N. Kutz, S.L. Brunton, B.W. Brunton, J.L. Proctor, Dynamic mode decomposition: data-driven modeling of complex systems . Society for Industrial and Applied Mathematics , 2016 Projection-based reduced order model In contrast to the DMD, the projection-based reduced order model (pROM) takes an intrusive approach, that is, it is NOT equation-free. The pROM first represents the solution as a linear combincation of reduced basis. The reduced basis can be obtained by the POD, for example. Let's denote the reduced basis as $\\boldsymbol{\\Phi}\\in\\mathbb{R}^{n\\times r}$ and express the solution, $\\boldsymbol{u}\\in\\mathbb{R}^n$ as $$\\boldsymbol{u} = \\boldsymbol{u}_{\\text{ref}}+\\boldsymbol{\\Phi}\\hat{\\boldsymbol{u}},$$ where $\\hat{\\boldsymbol{u}} \\in \\mathbb{R}^r$ denotes the generalized coordinates with respect to the reduced basis. Then we substitute $\\boldsymbol{u}$ in the governing equation, say a nonlinear dynamical system governed by the following ordinary differential equations, $$\\frac{d\\boldsymbol{u}}{dt} = \\boldsymbol{f}(\\boldsymbol{u},t;\\boldsymbol{\\mu}),$$ to obtain the over-determined system, i.e., $$\\boldsymbol{\\Phi}\\frac{d\\hat{\\boldsymbol{u}}}{dt} = \\boldsymbol{f}(\\boldsymbol{u}_{\\text{ref}}+\\boldsymbol{\\Phi}\\hat{\\boldsymbol{u}},t;\\boldsymbol{\\mu}),$$ which has more equations than unknowns. Therefore, the system needs to be closed by a projection. Galerkin and Petrov-Galerking projections are popular. For example, the Galerkin projection multiplies both sides by $\\boldsymbol{\\Phi}^T$ and the system of equations become $$\\frac{d\\hat{\\boldsymbol{u}}}{dt} = \\boldsymbol{\\Phi}^T \\boldsymbol{f}(\\boldsymbol{u}_{\\text{ref}}+\\boldsymbol{\\Phi}\\hat{\\boldsymbol{u}},t;\\boldsymbol{\\mu})$$ By the way, the nonlinear term $\\boldsymbol{f}$ still scales with the full order model size and it needs to be updated every time its argument changes due to Newton step updates, for example. The hyper-reduction provides an efficient way of computing nonlinear terms by sampling an important subset. By the way, if $\\boldsymbol{f}$ is linear, then $\\boldsymbol{\\Phi}^T\\boldsymbol{f}$ can be pre-computed, so the hyper-reduction is not necessary. Hyper-reduction Hyper-reduction is essential to reduce the complexity of nonlinear terms in pROM. The most popular hyper-reduction technique is the discrete empirical interpolation method (DEIM). The DEIM approximates the nonlinear term with a gappy POD, i.e., it expresses the nonlinear term with a linear combination of the nonlinear term reduced basis, $\\boldsymbol{\\Phi}_{f}\\in\\mathbb{R}^{n\\times f}$: $$\\boldsymbol{f} \\approx \\boldsymbol{\\Phi}_f \\hat{\\boldsymbol{f}},$$ where $\\hat{\\boldsymbol{f}}\\in\\mathbb{R}^{f}$ is a generalized coordinate for the nonlinear term. The usual data for the nonlinear term basis, $\\boldsymbol{\\Phi}_{f}$ is snapshot of nonlinear term itself. Alternatively, it can be replaced by the solution basis (i.e., $\\boldsymbol{\\Phi}$ or slight modification of it) via the SNS method introduced in the following journal paper: Y. Choi, D. Coombs, R. Anderson, SNS: a solution-based nonlinear subspace method for time-dependent model order reduction . SIAM Journal on Scientific Computing , 42(2), A1116\u2013A1146, 2020 Then, we introduce a sampling matrix (in order words, a collocation matrix), $\\boldsymbol{Z}\\in\\mathbb{R}^{n\\times z}$, which selects a subset of the nonliear term, $\\boldsymbol{F}$. That is, each column of $\\boldsymbol{Z}$ is a column of the identity matrix, $\\boldsymbol{I} \\in \\mathbb{R}^{n\\times n}$. Combining the collocation matrix and the nonlinear basis, we solve the following least-squares problem to solve for the generalized coordinate, $\\hat{\\boldsymbol{f}}$: $$\\hat{\\boldsymbol{f}} = \\underset{\\boldsymbol{y}\\in{\\mathbb{R}^{f}}}{\\arg\\min} \\hspace{3pt} || \\boldsymbol{Z}^T\\boldsymbol{f} - \\boldsymbol{Z}^T\\boldsymbol{\\Phi}_f \\boldsymbol{y} ||_2^2$$ The solution to the least-squares problem is known to be $$\\hat{\\boldsymbol{f}} = (\\boldsymbol{Z}^T\\boldsymbol{\\Phi}_{f})^\\dagger \\boldsymbol{Z}^T\\boldsymbol{f}.$$ Note that $(\\boldsymbol{Z}^T\\boldsymbol{\\Phi}_{f})^\\dagger$ can be pre-computed once the indices for $\\boldsymbol{Z}$ and $\\boldsymbol{\\Phi}_f$ are known. Note also that you do not need to construct $\\boldsymbol{Z}$. You only need to sample selected rows of $\\boldsymbol{\\Phi}_f$ and do the pseudo-inversion. This is what we do in libROM. Also note that we only need to evaluate a subset of $\\boldsymbol{f}$ because of $\\boldsymbol{Z}^T$ in front of $\\boldsymbol{f}$. Parametric ROMs Whether it is intrusive or non-intrusive ROM, if the ROM can only reproduce the full order model simulation data with high accuracy, it is useless because the full order model solution is already available. In order for any ROMs to be useful, they must be able to predict the solution which is not generated yet. We call such a ROM parametric because it is able to predict the solution for a new parameter value. Two extreme types of parametric ROMs are global and local ROMs. Global ROMs The global ROMs collect simulation data over several sampled points in a given parameter space and use all of them as a whole, building a global reduced basis. The size of the reduced basis becomes larger as the number of samples increases. Therefore, the global ROM is only effective when a small number of samples are used. Local ROMs A local ROM is built with the simulation data corresponding only to one specific sample. Usually, several local ROMs are built for several sample points and either interpolation or trust-region is used to predict the solution at points which were not sampled. Greedy sampling algorithm The greedy sampling algorithm is a physics-informed sampling strategy to build a parametric ROM . The parametric ROM can be used to predict the solution of a new parameter point that has not been seen in the training phase. The greey algorithms follow the general procedure below: Define a parameter space Pick an initial point in the parameter space to build a ROM there (a good cancidiate initla point is either the centroid or one of end points) Evaluate error indicator of the current ROM (either global or local ROM) at $N$ random points within the parameter space Check if the maximum error indicator value is less than the desirable accuracy threshold If the answer to Step 4 is yes, then terminate the greedy process. If the answer to Step 4 is no, then collect the full order model simulation data at the maximum error indicator point and add them to update the ROM Go to Step 3. The success of the greedy algorithm depends on the error indicator . The error indicator must satisfy the following two criteria: Its value must have positive correlation with the relative error measure The evaluation of the error indicator must be computationally efficient Note that the error indicator plays a role of a proxy for the accuracy of the ROM. The most popular error indicator is residual-based, which we recommend you to use for your physical simulations. The general framework of the greedy algorithm is implemented in libROM. The example of the libROM usage case can be found for the Poisson problem at poisson_greedy.cpp . The corresponding tutorial page can be found here . Several variants of the greedy procedure described above is possible. For more detailed explanation about the greedy algorithm, we refer to the following jounral paper, where the greedy algorithm is described for the interpolated ROM in a matrix manifold: Y. Choi, G. Boncoraglio, S. Anderson, D. Amsallem, C. Farhat, Gradient-based constrained optimization using a database of linear reduced order models . Journal of Computational Physics , 423, 109787, 2020 We recommend another excellent paper for the greedy algorithm: A. Paul-Dubois-Taine, D. Amsallem, An adaptive and efficient greedy procedure for the optimal training of parametric reduced-order models . International Journal for Numerical Methods in Engineering , 102, p1262-1292, 2014 Open Source libROM is an open-source software, and can be freely used under the terms of the MIT and APACHE license.","title":"Features"},{"location":"features.html#features","text":"The goal of libROM is to provide high-performance scalable library for data-driven reduced order modeling.","title":"Features"},{"location":"features.html#proper-orthogonal-decomposition","text":"One of the core features in libROM is the ability to extract important modes from given physical simulation data. The proper othogonal decomposition (POD) is a popular method for compressing physical simulation data to obtain optimal \"reduced\" bases in the following sense: $$\\boldsymbol{\\Phi} =\\underset{\\boldsymbol{A}\\in\\mathbb{R}^{n\\times r}, \\boldsymbol{A}^T\\boldsymbol{A} = \\boldsymbol{I}_{r\\times r} }{\\arg\\min} || \\boldsymbol{U} - \\boldsymbol{A}\\boldsymbol{A}^T\\boldsymbol{U} ||_F^2, $$ where $\\boldsymbol{U}\\in\\mathbb{R}^{n\\times m}$ is simulation data and $\\boldsymbol{I}_{r\\times r} \\in \\mathbb{R}^{r\\times r}$ denotes an identity matrix. That is, the POD tries to find the orthogonal matrix, $\\boldsymbol{\\Phi}$, whose span minimizes the projection error in the Frobenius norm. The POD modes can be obtained in two equivalent ways: (i) eigenvalue decomposition and (ii) singular value decomposition (SVD). We take the latter approach, i.e., let's say the thin SVD of $\\boldsymbol{U}$ is given by $$\\boldsymbol{U} = \\boldsymbol{W\\Sigma V}^T.$$ Then the solution of the POD is given by taking the first $r$ columns of the left singular matrix, i.e., $\\boldsymbol{\\Phi} = [\\boldsymbol{w}_{1},\\ldots ,\\boldsymbol{w}_r]$, where $\\boldsymbol{w}_k$ is $k$th left singular vector, assuming that the singular value is written in the decreasing order.","title":"Proper orthogonal decomposition"},{"location":"features.html#efficient-data-collection","text":"High-fidelity physical simulations generate intensive data in its size, which makes the data collection process daunting. Therefore, the libROM aims to ease the difficulty associated with the intensive data size. The libROM can be directly integrated to the physics solver that generates the intensive simulation data. For example, if the physical simulation is time dependent, then each time step solution data can be feed into the libROM incrementally so that the singular value decomposition is efficiently updated in parallel. This approach is incremental SVD . There are other types of SVDs which exploits efficiency. The libROM provides following four SVDs: Static SVD incremental SVD randomized SVD space-time SVD","title":"Efficient data collection"},{"location":"features.html#static-svd","text":"The static SVD waits the libROM to collect all the simulation data. Once the snapshot matrix $\\boldsymbol{U}$ is formed, then the SVD is performed. Therefore, if the data size is big, this approach is not efficient and not recommended. However, because it gives the most accurate SVD results, it is ideal for a small problem.","title":"Static SVD"},{"location":"features.html#incremental-svd","text":"Unlike the static SVD, the incremental SVD does not wait. Instead, as the data comes in, the SVD is performed right away. Because the incremental SVD only needs to find out the effect of one additional simulation data vector to the previous SVD, the update can be done very efficiently without requiring much memory. Therefore, it is useful for large-scale problems. For the detailed explanation about the incremental SVD, we refer to the following journal papers: M. Brand, Incremental singular value decomposition of uncertain data with missing values , In European Conference on Computer Vision , p707-720, 2002 G. Oxberry, T. Kostova-Vassilevska, W. Arrighi, K. Chand, Limited-memory adaptive snapshot selection for proper orthogonal decomposition , International Journal for Numerical Methods in Engineering , 109(2), p198-217, 2016 H. Fareed, J.R. Singler, Error Analysis of an Incremental Proper Orthogonal Decomposition Algorithm for PDE Simulation Data , Journal of Computational and Applied Mathematics , 368, 112525, 2020","title":"Incremental SVD"},{"location":"features.html#randomized-svd","text":"Randomization can bring computational efficiency in computing SVDs. For example, consider that one needs to extract $p$ dominant modes from $n \\times m$ tall dense matrix, using SVD. The randomized SVD requires $\\mathcal{O}(nm\\log(p))$ floating-point operations, while the static SVD algorithm requires $\\mathcal{O}(nmp)$ flops. The randomized SVD that is implemented in libROM can be found in the following journal paper: N. Halko, P.G. Martinsson, J.A. Tropp, Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions . SIAM review , 53(2), p217-288, 2011","title":"Randomized SVD"},{"location":"features.html#space-time-svd","text":"For time dependent problems, one can reduce not only the spatial degrees of freedom, but also the temporal degrees of freedom by representing the space-time solution as a linear combination of a space-time reduced basis. The space-time reduced basis can be mathematically written as a Kronecker product of temporal and spatial bases. Fortunately, one can extract temporal as well as spatial reduced bases from one single SVD. The procedure is schematically depicted in the figure below: For the detailed explanation about the incremental SVD, we refer to the following three journal papers: Y. Kim, K. Wang, Y. Choi, Efficient space\u2013time reduced order model for linear dynamical systems in Python using less than 120 lines of code . Mathematics , 9(14), 1690, 2021 Y. Choi, P. Brown, W. Arrighi, R. Anderson, K. Huynh, Space\u2013time reduced order model for large-scale linear dynamical systems with application to boltzmann transport problems . Journal of Computational Physics , 424, 109845, 2021 Y. Choi, K. Carlberg, Space-time least-squares Petrov-Galerkin projection for nonlinear model reduction , SIAM Journal on Scientific Computing , 41(1), A26-A58, 2019","title":"Space-time SVD"},{"location":"features.html#dynamic-mode-decomposition","text":"The dynamic mode decomposition (DMD) provides a great way of finding an approximate locally linear dynamical system, $$ \\frac{d\\boldsymbol{u}}{dt} = \\mathcal{A}\\boldsymbol{u},$$ for a given nonlinear dynamical system, $$ \\frac{d\\boldsymbol{u}}{dt} = \\boldsymbol{f}(\\boldsymbol{u},t;\\boldsymbol{\\mu}),$$ with initial condition, $\\boldsymbol{u}_0$. It takes non-intrusive approach, i.e., equation-free method, so it is applicable even if there is only data, but no $\\boldsymbol{f}(\\boldsymbol{u},t;\\boldsymbol{\\mu})$. For example, let's say the discrete-time data are given as: $$\\boldsymbol{U} = [\\boldsymbol{u}_1,\\ldots,\\boldsymbol{u}_m],$$ where $\\boldsymbol{u}_k\\in\\mathbb{R}^n$ denotes solution at $t=k\\Delta t$. The DMD is trying to find the best $\\boldsymbol{A}$ such that $$\\boldsymbol{U}^+ = \\boldsymbol{A}\\boldsymbol{U}^-,$$ where $\\boldsymbol{U}^+ = [\\boldsymbol{u}_2,\\ldots,\\boldsymbol{u}_m]$ and $\\boldsymbol{U}^- = [\\boldsymbol{u}_1, \\ldots, \\boldsymbol{u}_{m-1}]$. The following procedure is taken to find the best $\\boldsymbol{A}$. Take the singular value decomposition (SVD) of $\\boldsymbol{U}^-$ $$\\boldsymbol{U}^- \\approx \\boldsymbol{W}\\boldsymbol{\\Omega}\\boldsymbol{V}^*,$$ where $*$ denotes the conjugate transpose, $\\boldsymbol{W}\\in\\mathbb{C}^{n\\times r}$, $\\boldsymbol{\\Sigma}\\in\\mathbb{C}^{r\\times r}$, $\\boldsymbol{V}\\in\\mathbb{C}^{m\\times r}$, and $r \\leq m$. Because $\\boldsymbol{U}^+ = \\boldsymbol{A}\\boldsymbol{U}^-$, using the pseudo-inverse of the approximate $\\boldsymbol{U}^-$, we have $$\\boldsymbol{A} \\approx \\tilde{\\boldsymbol{A}} = \\boldsymbol{U}^+\\boldsymbol{V}\\boldsymbol{\\Omega}^{-1}\\boldsymbol{W}^*$$ It is easier to deal with the reduced operator $\\tilde{\\boldsymbol{A}}_r$, which relates the discrete-time dynamic of reduced states: $$\\tilde{\\boldsymbol{u}}_{k+1} = \\tilde{\\boldsymbol{A}}_r\\tilde{\\boldsymbol{u}}_k,$$ where $\\boldsymbol{u}_k = \\boldsymbol{W} \\tilde{\\boldsymbol{u}}_k$ and $\\tilde{\\boldsymbol{A}}_r$ is defined as $$\\tilde{\\boldsymbol{A}}_r=\\boldsymbol{W}^*\\tilde{\\boldsymbol{A}}\\boldsymbol{W}$$ $$\\tilde{\\boldsymbol{A}}_r=\\boldsymbol{W}^*\\boldsymbol{U}^+\\boldsymbol{V}\\boldsymbol{\\Omega}^{-1}$$ Let the eigen-decomposition of $\\tilde{\\boldsymbol{A}}_r$ to be $$\\tilde{\\boldsymbol{A}}_r \\boldsymbol{X} = \\boldsymbol{\\Lambda}\\boldsymbol{X}$$ and set either $\\boldsymbol{\\Phi} = \\boldsymbol{W}\\boldsymbol{X}$ or $\\boldsymbol{\\Phi} = \\boldsymbol{U}^+ \\boldsymbol{V} \\boldsymbol{\\Omega}^{-1}\\boldsymbol{X}$, then the DMD solution at time, $t$, can be found as $$\\boldsymbol{u}(t) = \\boldsymbol{\\Phi}\\boldsymbol{\\Lambda}^{t/\\Delta t} \\boldsymbol{b}_0,$$ where $\\boldsymbol{b}_0 = \\boldsymbol{\\Phi}^\\dagger \\boldsymbol{u}_0$. For the detailed explanation about the DMD, we refer to the following book: J.N. Kutz, S.L. Brunton, B.W. Brunton, J.L. Proctor, Dynamic mode decomposition: data-driven modeling of complex systems . Society for Industrial and Applied Mathematics , 2016","title":"Dynamic Mode Decomposition"},{"location":"features.html#projection-based-reduced-order-model","text":"In contrast to the DMD, the projection-based reduced order model (pROM) takes an intrusive approach, that is, it is NOT equation-free. The pROM first represents the solution as a linear combincation of reduced basis. The reduced basis can be obtained by the POD, for example. Let's denote the reduced basis as $\\boldsymbol{\\Phi}\\in\\mathbb{R}^{n\\times r}$ and express the solution, $\\boldsymbol{u}\\in\\mathbb{R}^n$ as $$\\boldsymbol{u} = \\boldsymbol{u}_{\\text{ref}}+\\boldsymbol{\\Phi}\\hat{\\boldsymbol{u}},$$ where $\\hat{\\boldsymbol{u}} \\in \\mathbb{R}^r$ denotes the generalized coordinates with respect to the reduced basis. Then we substitute $\\boldsymbol{u}$ in the governing equation, say a nonlinear dynamical system governed by the following ordinary differential equations, $$\\frac{d\\boldsymbol{u}}{dt} = \\boldsymbol{f}(\\boldsymbol{u},t;\\boldsymbol{\\mu}),$$ to obtain the over-determined system, i.e., $$\\boldsymbol{\\Phi}\\frac{d\\hat{\\boldsymbol{u}}}{dt} = \\boldsymbol{f}(\\boldsymbol{u}_{\\text{ref}}+\\boldsymbol{\\Phi}\\hat{\\boldsymbol{u}},t;\\boldsymbol{\\mu}),$$ which has more equations than unknowns. Therefore, the system needs to be closed by a projection. Galerkin and Petrov-Galerking projections are popular. For example, the Galerkin projection multiplies both sides by $\\boldsymbol{\\Phi}^T$ and the system of equations become $$\\frac{d\\hat{\\boldsymbol{u}}}{dt} = \\boldsymbol{\\Phi}^T \\boldsymbol{f}(\\boldsymbol{u}_{\\text{ref}}+\\boldsymbol{\\Phi}\\hat{\\boldsymbol{u}},t;\\boldsymbol{\\mu})$$ By the way, the nonlinear term $\\boldsymbol{f}$ still scales with the full order model size and it needs to be updated every time its argument changes due to Newton step updates, for example. The hyper-reduction provides an efficient way of computing nonlinear terms by sampling an important subset. By the way, if $\\boldsymbol{f}$ is linear, then $\\boldsymbol{\\Phi}^T\\boldsymbol{f}$ can be pre-computed, so the hyper-reduction is not necessary.","title":"Projection-based reduced order model"},{"location":"features.html#hyper-reduction","text":"Hyper-reduction is essential to reduce the complexity of nonlinear terms in pROM. The most popular hyper-reduction technique is the discrete empirical interpolation method (DEIM). The DEIM approximates the nonlinear term with a gappy POD, i.e., it expresses the nonlinear term with a linear combination of the nonlinear term reduced basis, $\\boldsymbol{\\Phi}_{f}\\in\\mathbb{R}^{n\\times f}$: $$\\boldsymbol{f} \\approx \\boldsymbol{\\Phi}_f \\hat{\\boldsymbol{f}},$$ where $\\hat{\\boldsymbol{f}}\\in\\mathbb{R}^{f}$ is a generalized coordinate for the nonlinear term. The usual data for the nonlinear term basis, $\\boldsymbol{\\Phi}_{f}$ is snapshot of nonlinear term itself. Alternatively, it can be replaced by the solution basis (i.e., $\\boldsymbol{\\Phi}$ or slight modification of it) via the SNS method introduced in the following journal paper: Y. Choi, D. Coombs, R. Anderson, SNS: a solution-based nonlinear subspace method for time-dependent model order reduction . SIAM Journal on Scientific Computing , 42(2), A1116\u2013A1146, 2020 Then, we introduce a sampling matrix (in order words, a collocation matrix), $\\boldsymbol{Z}\\in\\mathbb{R}^{n\\times z}$, which selects a subset of the nonliear term, $\\boldsymbol{F}$. That is, each column of $\\boldsymbol{Z}$ is a column of the identity matrix, $\\boldsymbol{I} \\in \\mathbb{R}^{n\\times n}$. Combining the collocation matrix and the nonlinear basis, we solve the following least-squares problem to solve for the generalized coordinate, $\\hat{\\boldsymbol{f}}$: $$\\hat{\\boldsymbol{f}} = \\underset{\\boldsymbol{y}\\in{\\mathbb{R}^{f}}}{\\arg\\min} \\hspace{3pt} || \\boldsymbol{Z}^T\\boldsymbol{f} - \\boldsymbol{Z}^T\\boldsymbol{\\Phi}_f \\boldsymbol{y} ||_2^2$$ The solution to the least-squares problem is known to be $$\\hat{\\boldsymbol{f}} = (\\boldsymbol{Z}^T\\boldsymbol{\\Phi}_{f})^\\dagger \\boldsymbol{Z}^T\\boldsymbol{f}.$$ Note that $(\\boldsymbol{Z}^T\\boldsymbol{\\Phi}_{f})^\\dagger$ can be pre-computed once the indices for $\\boldsymbol{Z}$ and $\\boldsymbol{\\Phi}_f$ are known. Note also that you do not need to construct $\\boldsymbol{Z}$. You only need to sample selected rows of $\\boldsymbol{\\Phi}_f$ and do the pseudo-inversion. This is what we do in libROM. Also note that we only need to evaluate a subset of $\\boldsymbol{f}$ because of $\\boldsymbol{Z}^T$ in front of $\\boldsymbol{f}$.","title":"Hyper-reduction"},{"location":"features.html#parametric-roms","text":"Whether it is intrusive or non-intrusive ROM, if the ROM can only reproduce the full order model simulation data with high accuracy, it is useless because the full order model solution is already available. In order for any ROMs to be useful, they must be able to predict the solution which is not generated yet. We call such a ROM parametric because it is able to predict the solution for a new parameter value. Two extreme types of parametric ROMs are global and local ROMs.","title":"Parametric ROMs"},{"location":"features.html#global-roms","text":"The global ROMs collect simulation data over several sampled points in a given parameter space and use all of them as a whole, building a global reduced basis. The size of the reduced basis becomes larger as the number of samples increases. Therefore, the global ROM is only effective when a small number of samples are used.","title":"Global ROMs"},{"location":"features.html#local-roms","text":"A local ROM is built with the simulation data corresponding only to one specific sample. Usually, several local ROMs are built for several sample points and either interpolation or trust-region is used to predict the solution at points which were not sampled.","title":"Local ROMs"},{"location":"features.html#greedy-sampling-algorithm","text":"The greedy sampling algorithm is a physics-informed sampling strategy to build a parametric ROM . The parametric ROM can be used to predict the solution of a new parameter point that has not been seen in the training phase. The greey algorithms follow the general procedure below: Define a parameter space Pick an initial point in the parameter space to build a ROM there (a good cancidiate initla point is either the centroid or one of end points) Evaluate error indicator of the current ROM (either global or local ROM) at $N$ random points within the parameter space Check if the maximum error indicator value is less than the desirable accuracy threshold If the answer to Step 4 is yes, then terminate the greedy process. If the answer to Step 4 is no, then collect the full order model simulation data at the maximum error indicator point and add them to update the ROM Go to Step 3. The success of the greedy algorithm depends on the error indicator . The error indicator must satisfy the following two criteria: Its value must have positive correlation with the relative error measure The evaluation of the error indicator must be computationally efficient Note that the error indicator plays a role of a proxy for the accuracy of the ROM. The most popular error indicator is residual-based, which we recommend you to use for your physical simulations. The general framework of the greedy algorithm is implemented in libROM. The example of the libROM usage case can be found for the Poisson problem at poisson_greedy.cpp . The corresponding tutorial page can be found here . Several variants of the greedy procedure described above is possible. For more detailed explanation about the greedy algorithm, we refer to the following jounral paper, where the greedy algorithm is described for the interpolated ROM in a matrix manifold: Y. Choi, G. Boncoraglio, S. Anderson, D. Amsallem, C. Farhat, Gradient-based constrained optimization using a database of linear reduced order models . Journal of Computational Physics , 423, 109787, 2020 We recommend another excellent paper for the greedy algorithm: A. Paul-Dubois-Taine, D. Amsallem, An adaptive and efficient greedy procedure for the optimal training of parametric reduced-order models . International Journal for Numerical Methods in Engineering , 102, p1262-1292, 2014","title":"Greedy sampling algorithm"},{"location":"features.html#open-source","text":"libROM is an open-source software, and can be freely used under the terms of the MIT and APACHE license.","title":"Open Source"},{"location":"gallery.html","text":"Gallery This page collects screenshots from various ROM simulations based on libROM. Sedov blast simulated with Laghos and accelerated by libROM . Visualization with VisIt . 2D Gresho vortex simulated with Laghos and accelerated by libROM . Visualization with VisIt . 2D Nonlinear diffusion problem simulated with MFEM and accelerated by libROM . Visualization with VisIt . 3D Crooked pipe for nonlinear radiation diffusion problem simulated with BLAST and accelerated by libROM . Visualization with VisIt . 2D Rayleigh-Taylor instability problem simulated with Laghos and accelerated by libROM . Visualization with VisIt . Triple-point problem simulated with Laghos and accelerated by libROM . Visualization with VisIt . An optimal design for the wind turbine blade solved with LiDO and accelerated by libROM . Visualization with VisIt . 3D Boltzmann particle transport problem solved with ARDRA and accelerated by libROM . Visualization with VisIt . 3D Boltzmann particle transport problem solved with ARDRA and accelerated by libROM . Visualization with VisIt . Taylor-Green vortex problem simulated with Laghos and accelerated by libROM . Visualization with VisIt . Stress-constrained optimal L-bracket problem solved by LiDO and accelerated by libROM . Visualization with VisIt . 3D cantilever beam problem solved by LiDO and accelerated by libROM . Visualization with VisIt . 2D vortex shedding cylinder problem solved by SU2 and its reduced basis by libROM below. Click image below for zoomed-in picture. Visualization with ParaView . 2D NACA0012 airfoil problem solved by SU2 and its reduced basis by libROM . Click image above for zoomed-in picture. Visualization with MATLAB .","title":"Gallery"},{"location":"gallery.html#gallery","text":"This page collects screenshots from various ROM simulations based on libROM. Sedov blast simulated with Laghos and accelerated by libROM . Visualization with VisIt . 2D Gresho vortex simulated with Laghos and accelerated by libROM . Visualization with VisIt . 2D Nonlinear diffusion problem simulated with MFEM and accelerated by libROM . Visualization with VisIt . 3D Crooked pipe for nonlinear radiation diffusion problem simulated with BLAST and accelerated by libROM . Visualization with VisIt . 2D Rayleigh-Taylor instability problem simulated with Laghos and accelerated by libROM . Visualization with VisIt . Triple-point problem simulated with Laghos and accelerated by libROM . Visualization with VisIt . An optimal design for the wind turbine blade solved with LiDO and accelerated by libROM . Visualization with VisIt . 3D Boltzmann particle transport problem solved with ARDRA and accelerated by libROM . Visualization with VisIt . 3D Boltzmann particle transport problem solved with ARDRA and accelerated by libROM . Visualization with VisIt . Taylor-Green vortex problem simulated with Laghos and accelerated by libROM . Visualization with VisIt . Stress-constrained optimal L-bracket problem solved by LiDO and accelerated by libROM . Visualization with VisIt . 3D cantilever beam problem solved by LiDO and accelerated by libROM . Visualization with VisIt . 2D vortex shedding cylinder problem solved by SU2 and its reduced basis by libROM below. Click image below for zoomed-in picture. Visualization with ParaView . 2D NACA0012 airfoil problem solved by SU2 and its reduced basis by libROM . Click image above for zoomed-in picture. Visualization with MATLAB .","title":"Gallery"},{"location":"hlcs.html","text":"MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}}); HLCS Webinar ( in California time ) HLCS stands for Hartree-Livermore joint seminar series on Computational Science. We hold a webinar roughly once a month at 8:30 AM on Tuesday in California time. It is sponsored by the Hartree Centre and the Lawrence Livermore National Laboratory ( LLNL ). It is intended to spur collaboration with industry through discussions on computational science, high performance computing (HPC) and data science. Scheduled Talks in 2022 When Speaker Institution Title WebEx or Zoom Past Talks in 2022 Date Speaker Institution Title YouTube Nov. 8 Erik Draeger and David Beckingsale LLNL RADIUSS and the HPCIC: Outreach through open-source software link Sept. 13 Jony Castagna and Francesca Schiavello Hartree Centre Style Eddy Simulation link July 5 Youngsoo Choi LLNL Interpretable and Explainable Data-Driven Methods for Physical Simulations link May 24 Michael Gleaves and Vassil Alexandrov Hartree Centre Industrial engagement and research highlights at the Hartree Center link","title":"HLCS"},{"location":"hlcs.html#hlcs-webinar-in-california-time","text":"HLCS stands for Hartree-Livermore joint seminar series on Computational Science. We hold a webinar roughly once a month at 8:30 AM on Tuesday in California time. It is sponsored by the Hartree Centre and the Lawrence Livermore National Laboratory ( LLNL ). It is intended to spur collaboration with industry through discussions on computational science, high performance computing (HPC) and data science.","title":"HLCS Webinar (in California time)"},{"location":"hlcs.html#scheduled-talks-in-2022","text":"When Speaker Institution Title WebEx or Zoom","title":"Scheduled Talks in 2022"},{"location":"hlcs.html#past-talks-in-2022","text":"Date Speaker Institution Title YouTube Nov. 8 Erik Draeger and David Beckingsale LLNL RADIUSS and the HPCIC: Outreach through open-source software link Sept. 13 Jony Castagna and Francesca Schiavello Hartree Centre Style Eddy Simulation link July 5 Youngsoo Choi LLNL Interpretable and Explainable Data-Driven Methods for Physical Simulations link May 24 Michael Gleaves and Vassil Alexandrov Hartree Centre Industrial engagement and research highlights at the Hartree Center link","title":"Past Talks in 2022"},{"location":"news.html","text":"All News Updates Date Message June 3, 2023 Youngsoo Choi will present at SIAM OP23 Mar 29, 2023 AAAI Spring Symposium was organized Mar 10, 2023 gLaSDI open source code is available in gitHub. Mar 6, 2023 LaSDI open source code is available in gitHub. Feb 15, 2023 parametric DMD paper is published in JCP. Oct 17, 2022 Rayleigh-Taylor instability ROM paper is published in JCP. Oct 1, 2022 CWROM stress lattice paper is published in CMAME. Sep 30, 2022 Youngsoo Choi will present ``Efficient Nonlinear Manifold Reduced Order Models with Shallow Sparse Neural Network\" at SIAM MDS22 Sep 28, 2022 Dylan Copeland will present ``Reduced Order Models for Multi-Material ALE Hydrodynamics\" at SIAM MDS22 Sep 27, 2022 Siu Wun Cheung will present ``Accelerating Hydrodyanmics Simulation with Reduced Order Models\" at SIAM MDS22 Apr 26, 2022 gLaSDI preprint is available in arXiv. Mar 29, 2022 S-OPT preprint is available in arXiv. Nov 19, 2021 NM-ROM paper is published in JCP. Nov 10, 2021 Laghos ROM is published at CMAME. Oct 1, 2021 Domain decomposition ROM paper is published at CMAME Sep 27, 2021 First version of libROM webpage is launched July 19, 2021 Space time ROM-Python paper is published in Mathematics Jan 1, 2021 Space time ROM paper is published in Journal of Computational Physics","title":"_News"},{"location":"news.html#all-news-updates","text":"Date Message June 3, 2023 Youngsoo Choi will present at SIAM OP23 Mar 29, 2023 AAAI Spring Symposium was organized Mar 10, 2023 gLaSDI open source code is available in gitHub. Mar 6, 2023 LaSDI open source code is available in gitHub. Feb 15, 2023 parametric DMD paper is published in JCP. Oct 17, 2022 Rayleigh-Taylor instability ROM paper is published in JCP. Oct 1, 2022 CWROM stress lattice paper is published in CMAME. Sep 30, 2022 Youngsoo Choi will present ``Efficient Nonlinear Manifold Reduced Order Models with Shallow Sparse Neural Network\" at SIAM MDS22 Sep 28, 2022 Dylan Copeland will present ``Reduced Order Models for Multi-Material ALE Hydrodynamics\" at SIAM MDS22 Sep 27, 2022 Siu Wun Cheung will present ``Accelerating Hydrodyanmics Simulation with Reduced Order Models\" at SIAM MDS22 Apr 26, 2022 gLaSDI preprint is available in arXiv. Mar 29, 2022 S-OPT preprint is available in arXiv. Nov 19, 2021 NM-ROM paper is published in JCP. Nov 10, 2021 Laghos ROM is published at CMAME. Oct 1, 2021 Domain decomposition ROM paper is published at CMAME Sep 27, 2021 First version of libROM webpage is launched July 19, 2021 Space time ROM-Python paper is published in Mathematics Jan 1, 2021 Space time ROM paper is published in Journal of Computational Physics","title":"All News Updates"},{"location":"poisson.html","text":"MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}}); Poisson equation The main code for this tutorial can be found in poisson_global_rom.cpp , which accelerates the Poisson problem $$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. The numerical results can be found in Poisson Problem . libROM assumes that you have a physics code, such as MFEM , SU2 , and Laghos . Then, libROM can be integrated into the physics code to build ROM to accelerate physics simulation. For example, see numerical results in Examples and Gallery . This tutorial illustrates how various libROM objects and functions can be used to collect simulation data, build reduced basis, and construct reduced order model operator to accelerate and predict a target physics simulation. The following tutorials are available: Tutorial 1 : offline , Take and write simulation data with libROM. Tutorial 2 : merge , Collect simulation data and build a reduced basis. Tutorial 3 : online , Build a ROM operator, solve the ROM system, and restore the full order state. Building Follow the building page to build the libROM library. You must build it with -m option to build MFEM library together. ~/libROM> ./scripts/compile.sh -m Tutorial 1 This tutorial demonstrates how to collect simulation data with libROM. The important object is BasisGenerator , which collects simulation data and computes reduced basis, using various singular value decomposition ( SVD ) algorithms, e.g., incremental SVD and static SVD . The incremental SVD is useful for time-dependent problems. Because the Poisson problem is a time-independent problem, we will focus on the usage of the static SVD. The definition of BasisGenerator class can be found in BasisGenerator.h . You must include BasisGenerator.h in your physics code where the simulation data is generated. For example, BasisGenerator.h is included in Line 32 of poisson_global_rom.cpp for Poisson Problem . #include \"BasisGenerator.h\" A BasisGenerator pointer is defined in Line 234 of poisson_global_rom.cpp and the pointer is initiated in Line 243 of poisson_global_rom.cpp . The BasisGenerator requires four inputs to initialize, i.e., Options , boolean variable, string, and Database::formats. The object, Options, sets various options for the BasisGenerator, such as the basis dimension and singular value tolerance. The boolean variable determines if the incremental or static SVD will be used. For this tutorial, we choose the static SVD, so the boolean variable must be false. Finally, the string input specifies the name of the basis file and Database::formats specifies the file format for the basis file. The default format is Database::HDF5. The detailed description for inputs for Options and BasisGenerator can be found in Options.h and BasisGenerator.h . The specific inputs used for the Poisson problem can be found in Lines 227--232 of poisson_global_rom.cpp . Now, the instantiated BasisGenerator, i.e., generator , collects the simulation data once it is available. The Poisson problem generates the solution, $X$, in Line 338 of poisson_global_rom.cpp and it is collected in the generator in Line 345 of poisson_global_rom.cpp . The member function, writeSnapshot on Line 346 of poisson_global_rom.cpp simply writes the solution data in the specified HDF5 file. Make sure that the pointers, generator and options , are deleted after done with sampling. This completes the libROM data collection implementation, which corresponds to the offline phase in the Poisson problem . If you execute the following command: poisson_global_rom -offline -f 1.0 -id 0 then you should see the HDF5 snapshot output file, i.e., basis0_snapshot.000000 . The command line options above include -offline that indicates the offline phase, -f 1.0 sets the frequency variable $\\kappa=1.0$ (see the Poisson problem for the description of the frequency variable), and -id 0 labels the snapshot index. The visualization of the solution can be done either with VisIt or GLVis. For example, the VisIt shows the following solution contour for this specific simulation: Please execute the following commands: poisson_global_rom -offline -f 1.1 -id 1 poisson_global_rom -offline -f 1.2 -id 2 whose solution contour corresponds, respectively, to: Tutorial 2 Once the simulation data are collected within libROM basis files, they can be merged to form a reduced basis. This process is called the merge phase . It is implemented in Lines 249--270 of poisson_global_rom.cpp . As in Tutorial 1 , the objects, Options and BasisGenerator must be defined (see Lines 251--253 of poisson_global_rom.cpp . The generator iterates over the individual HDF5 snapshot file and loads them all (see Lines 254--259 of poisson_global_rom.cpp . The member function endSamples in Line 260 of poisson_global_rom.cpp computes the reduced basis. Again make sure to delete the pointers, i.e., generator and options . For exammple, the following command line option runs the merge phase: poisson_global_rom -merge -ns 3 The command line option, -merge , invokes the merges phase and -ns 3 option indicates that there are three different snapshot files. The merge phase reads the three snapshot files, i.e., basis0_snapshot.000000 , basis1_snapshot.000000 , and basis2_snapshot.000000 , which were generated in Tutorial 1 , and forms a reduced basis and stores it in the HDF5 basis file, i.e., basis.000000 . Tutorial 3 The online phase builds ROM operators, solves the ROM system, and restores the full order states for a new parameter value. This tutorial demonstrates these three different actions for the frequency value, $\\kappa = 1.15$. Lines 356--357 of poisson_global_rom.cpp implements the step of reading a basis file. The BasisReader object reads the basis file, using member function, getSpatialBasis , which returns a Matrix object in libROM. The number of rows and columns of the reduced basis can be obtained through the member functions of the Matrix class, i.e., numRows and numColumns , respectively. Line 364 of poisson_global_rom.cpp defines a MFEM DenseMatrix that holds the transpose of the reduced basis matrix. This must be understood as the transpose because libROM stores the matrix row-wise. The MFEM matrix is defined to form a reduced system operator, whose process is implemented in Lines 368--375 of poisson_global_rom.cpp . Then the reduced system operator is inverted at Line 370 of poisson_global_rom.cpp . The reduced right-hand-side is formed by multiplying the reduced basis transpose to the full order model right-hand-side vector, $B$ at Line 374 of poisson_global_rom.cpp . Line 380 of poisson_global_rom.cpp solves the reduced system of equation. Line 384 of poisson_global_rom.cpp restores the corresponding full order state by multipling the reduced solution by the reduced basis. The command line options that executes the online phase described above are poisson_global_rom -online -f 1.15 where -online option invokes the online phase and -f 1.15 sets the frequency value $\\kappa = 1.15$. This particular example ROM accelerates the physics simulation by $7.5$ and achieves the relative error, $6.4e-4$, with respect to the corresponding full order model solution.","title":"Poisson equation"},{"location":"poisson.html#poisson-equation","text":"The main code for this tutorial can be found in poisson_global_rom.cpp , which accelerates the Poisson problem $$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. The numerical results can be found in Poisson Problem . libROM assumes that you have a physics code, such as MFEM , SU2 , and Laghos . Then, libROM can be integrated into the physics code to build ROM to accelerate physics simulation. For example, see numerical results in Examples and Gallery . This tutorial illustrates how various libROM objects and functions can be used to collect simulation data, build reduced basis, and construct reduced order model operator to accelerate and predict a target physics simulation. The following tutorials are available: Tutorial 1 : offline , Take and write simulation data with libROM. Tutorial 2 : merge , Collect simulation data and build a reduced basis. Tutorial 3 : online , Build a ROM operator, solve the ROM system, and restore the full order state.","title":"Poisson equation"},{"location":"poisson.html#building","text":"Follow the building page to build the libROM library. You must build it with -m option to build MFEM library together. ~/libROM> ./scripts/compile.sh -m","title":"Building"},{"location":"poisson.html#tutorial-1","text":"This tutorial demonstrates how to collect simulation data with libROM. The important object is BasisGenerator , which collects simulation data and computes reduced basis, using various singular value decomposition ( SVD ) algorithms, e.g., incremental SVD and static SVD . The incremental SVD is useful for time-dependent problems. Because the Poisson problem is a time-independent problem, we will focus on the usage of the static SVD. The definition of BasisGenerator class can be found in BasisGenerator.h . You must include BasisGenerator.h in your physics code where the simulation data is generated. For example, BasisGenerator.h is included in Line 32 of poisson_global_rom.cpp for Poisson Problem . #include \"BasisGenerator.h\" A BasisGenerator pointer is defined in Line 234 of poisson_global_rom.cpp and the pointer is initiated in Line 243 of poisson_global_rom.cpp . The BasisGenerator requires four inputs to initialize, i.e., Options , boolean variable, string, and Database::formats. The object, Options, sets various options for the BasisGenerator, such as the basis dimension and singular value tolerance. The boolean variable determines if the incremental or static SVD will be used. For this tutorial, we choose the static SVD, so the boolean variable must be false. Finally, the string input specifies the name of the basis file and Database::formats specifies the file format for the basis file. The default format is Database::HDF5. The detailed description for inputs for Options and BasisGenerator can be found in Options.h and BasisGenerator.h . The specific inputs used for the Poisson problem can be found in Lines 227--232 of poisson_global_rom.cpp . Now, the instantiated BasisGenerator, i.e., generator , collects the simulation data once it is available. The Poisson problem generates the solution, $X$, in Line 338 of poisson_global_rom.cpp and it is collected in the generator in Line 345 of poisson_global_rom.cpp . The member function, writeSnapshot on Line 346 of poisson_global_rom.cpp simply writes the solution data in the specified HDF5 file. Make sure that the pointers, generator and options , are deleted after done with sampling. This completes the libROM data collection implementation, which corresponds to the offline phase in the Poisson problem . If you execute the following command: poisson_global_rom -offline -f 1.0 -id 0 then you should see the HDF5 snapshot output file, i.e., basis0_snapshot.000000 . The command line options above include -offline that indicates the offline phase, -f 1.0 sets the frequency variable $\\kappa=1.0$ (see the Poisson problem for the description of the frequency variable), and -id 0 labels the snapshot index. The visualization of the solution can be done either with VisIt or GLVis. For example, the VisIt shows the following solution contour for this specific simulation: Please execute the following commands: poisson_global_rom -offline -f 1.1 -id 1 poisson_global_rom -offline -f 1.2 -id 2 whose solution contour corresponds, respectively, to:","title":"Tutorial 1"},{"location":"poisson.html#tutorial-2","text":"Once the simulation data are collected within libROM basis files, they can be merged to form a reduced basis. This process is called the merge phase . It is implemented in Lines 249--270 of poisson_global_rom.cpp . As in Tutorial 1 , the objects, Options and BasisGenerator must be defined (see Lines 251--253 of poisson_global_rom.cpp . The generator iterates over the individual HDF5 snapshot file and loads them all (see Lines 254--259 of poisson_global_rom.cpp . The member function endSamples in Line 260 of poisson_global_rom.cpp computes the reduced basis. Again make sure to delete the pointers, i.e., generator and options . For exammple, the following command line option runs the merge phase: poisson_global_rom -merge -ns 3 The command line option, -merge , invokes the merges phase and -ns 3 option indicates that there are three different snapshot files. The merge phase reads the three snapshot files, i.e., basis0_snapshot.000000 , basis1_snapshot.000000 , and basis2_snapshot.000000 , which were generated in Tutorial 1 , and forms a reduced basis and stores it in the HDF5 basis file, i.e., basis.000000 .","title":"Tutorial 2"},{"location":"poisson.html#tutorial-3","text":"The online phase builds ROM operators, solves the ROM system, and restores the full order states for a new parameter value. This tutorial demonstrates these three different actions for the frequency value, $\\kappa = 1.15$. Lines 356--357 of poisson_global_rom.cpp implements the step of reading a basis file. The BasisReader object reads the basis file, using member function, getSpatialBasis , which returns a Matrix object in libROM. The number of rows and columns of the reduced basis can be obtained through the member functions of the Matrix class, i.e., numRows and numColumns , respectively. Line 364 of poisson_global_rom.cpp defines a MFEM DenseMatrix that holds the transpose of the reduced basis matrix. This must be understood as the transpose because libROM stores the matrix row-wise. The MFEM matrix is defined to form a reduced system operator, whose process is implemented in Lines 368--375 of poisson_global_rom.cpp . Then the reduced system operator is inverted at Line 370 of poisson_global_rom.cpp . The reduced right-hand-side is formed by multiplying the reduced basis transpose to the full order model right-hand-side vector, $B$ at Line 374 of poisson_global_rom.cpp . Line 380 of poisson_global_rom.cpp solves the reduced system of equation. Line 384 of poisson_global_rom.cpp restores the corresponding full order state by multipling the reduced solution by the reduced basis. The command line options that executes the online phase described above are poisson_global_rom -online -f 1.15 where -online option invokes the online phase and -f 1.15 sets the frequency value $\\kappa = 1.15$. This particular example ROM accelerates the physics simulation by $7.5$ and achieves the relative error, $6.4e-4$, with respect to the corresponding full order model solution.","title":"Tutorial 3"},{"location":"poisson_greedy.html","text":"MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}}); Greedy for Poisson equation The main code for this tutorial can be found at poisson_local_rom_greedy.cpp , which demonstrates how to use libROM to execute greedy procedure for the ROM of the Poisson problem introduced in the Poisson equation tutorial . For the recap, the general procedure of the greedy algorithm follows: Define a parameter space Pick an initial point in the parameter space to build a ROM there (a good cancidiate initla point is either the centroid or one of end points) Evaluate error indicator of the current ROM (either global or local ROM) at $N$ random points within the parameter space Check if the maximum error indicator value is less than the desirable accuracy threshold If the answer to Step 4 is yes, then terminate the greedy process. If the answer to Step 4 is no, then collect the full order model simulation data at the maximum error indicator point and add them to update the ROM Go to Step 3. As in the Poisson equation tutorial , we choose to vary the frequency $\\kappa$ as parameter. First, we define the parameter space to be from $0.5$ to $3$, which is larger than the one used in Poisson equation tutorial . You can try the following command line options to run the greedy procedure: ./poisson_local_rom_greedy -build_database -greedy-param-min 0.5 -greedy-param-max 3 -greedy-param-size 40 -greedysubsize 10 -greedyconvsize 20 -greedyrelerrortol 0.01 The lower and upper bounds of the parameter are determined by the options, -greedy-param-min and -greedy-param-max , respectively. The option -greedy-param-size specifies the total number of random sample points within the parameter space for the whole greedy procedure. The option -greedysubsize sets the number of sub-sample points, where the error indicator is evaluated at every greedy iterations. The option -greedyconvsize sets the number of convergence-sample points on which the error indicator is checked and the termination of the greedy algorithm is determined if the error indicators are below the convergence threshold after the error indicator tests on the sub-sample points have been passed. Finally, -greedyrelerrortol sets the desirable relative error for the greedy algorithm to achieve. The core class of the libROM for the greedy procedure is GreedySampler , which is defined on Line 126 of poisson_local_rom_greedy.cpp The GreedySampler generates sampling points within a given parameter space. The class has two sub-classes, i.e., GreedyCustomSampler and GreedyRandomSampler . The GreedyCustomSampler generates pre-defined sampling points, e.g., a tensor product sampling points, while the GreedyRandomSampler generates random sampling points, e.g., Latin hyper-cube sampling points. The GreedySampler also does book-keeping job of at which sampling point to evaluate the error indicator, when to move onto the next greedy step, and which sampling point has the maximum error indicator value. Just to be clear, the libROM does not do everything for you. For example, the error indicator must be defined in the physics solver. For the Poisson example, the residual-based error indicator is defined at Lines 529-535 of poisson_loca_rom_greedy.cpp . Once the greedy procedure completes, the log file, called poisson_greedy_algorithm_log.txt , is generated to show the progress of the greedy procedure and the final parameter points on which the global ROM was built. For example, you will see the following block at the end of the file, indicating the final parameter points on which the global ROM is built. Sampled Parameter Points [ 0.591166 ] [ 0.844964 ] [ 1.066678 ] [ 1.353370 ] [ 1.710334 ] [ 1.992794 ] [ 2.568171 ] [ 2.985638 ] Because we set the -greedyrelerrortol to be 0.01, the global ROM built through the greedy procedure must be able to predict a solution with a relative error less than 1$\\%$ for any points in the parameter space. Indeed, let's try to predict the solution at $\\kappa = 2.2$, which was not one of the final parameter points. Let's first generate the full order model solution with the following command line option: ./poisson_local_rom_greedy -offline -f 2.2 This full order model solution will be used to compute the relative error for the ROM solution. The ROM solution can be obtained by the following command line option: ./poisson_local_rom_greedy -use_database -online -f 2.2 Indeed, the relative error of 0.00167671 is achieved","title":"Greedy for Poisson"},{"location":"poisson_greedy.html#greedy-for-poisson-equation","text":"The main code for this tutorial can be found at poisson_local_rom_greedy.cpp , which demonstrates how to use libROM to execute greedy procedure for the ROM of the Poisson problem introduced in the Poisson equation tutorial . For the recap, the general procedure of the greedy algorithm follows: Define a parameter space Pick an initial point in the parameter space to build a ROM there (a good cancidiate initla point is either the centroid or one of end points) Evaluate error indicator of the current ROM (either global or local ROM) at $N$ random points within the parameter space Check if the maximum error indicator value is less than the desirable accuracy threshold If the answer to Step 4 is yes, then terminate the greedy process. If the answer to Step 4 is no, then collect the full order model simulation data at the maximum error indicator point and add them to update the ROM Go to Step 3. As in the Poisson equation tutorial , we choose to vary the frequency $\\kappa$ as parameter. First, we define the parameter space to be from $0.5$ to $3$, which is larger than the one used in Poisson equation tutorial . You can try the following command line options to run the greedy procedure: ./poisson_local_rom_greedy -build_database -greedy-param-min 0.5 -greedy-param-max 3 -greedy-param-size 40 -greedysubsize 10 -greedyconvsize 20 -greedyrelerrortol 0.01 The lower and upper bounds of the parameter are determined by the options, -greedy-param-min and -greedy-param-max , respectively. The option -greedy-param-size specifies the total number of random sample points within the parameter space for the whole greedy procedure. The option -greedysubsize sets the number of sub-sample points, where the error indicator is evaluated at every greedy iterations. The option -greedyconvsize sets the number of convergence-sample points on which the error indicator is checked and the termination of the greedy algorithm is determined if the error indicators are below the convergence threshold after the error indicator tests on the sub-sample points have been passed. Finally, -greedyrelerrortol sets the desirable relative error for the greedy algorithm to achieve. The core class of the libROM for the greedy procedure is GreedySampler , which is defined on Line 126 of poisson_local_rom_greedy.cpp The GreedySampler generates sampling points within a given parameter space. The class has two sub-classes, i.e., GreedyCustomSampler and GreedyRandomSampler . The GreedyCustomSampler generates pre-defined sampling points, e.g., a tensor product sampling points, while the GreedyRandomSampler generates random sampling points, e.g., Latin hyper-cube sampling points. The GreedySampler also does book-keeping job of at which sampling point to evaluate the error indicator, when to move onto the next greedy step, and which sampling point has the maximum error indicator value. Just to be clear, the libROM does not do everything for you. For example, the error indicator must be defined in the physics solver. For the Poisson example, the residual-based error indicator is defined at Lines 529-535 of poisson_loca_rom_greedy.cpp . Once the greedy procedure completes, the log file, called poisson_greedy_algorithm_log.txt , is generated to show the progress of the greedy procedure and the final parameter points on which the global ROM was built. For example, you will see the following block at the end of the file, indicating the final parameter points on which the global ROM is built. Sampled Parameter Points [ 0.591166 ] [ 0.844964 ] [ 1.066678 ] [ 1.353370 ] [ 1.710334 ] [ 1.992794 ] [ 2.568171 ] [ 2.985638 ] Because we set the -greedyrelerrortol to be 0.01, the global ROM built through the greedy procedure must be able to predict a solution with a relative error less than 1$\\%$ for any points in the parameter space. Indeed, let's try to predict the solution at $\\kappa = 2.2$, which was not one of the final parameter points. Let's first generate the full order model solution with the following command line option: ./poisson_local_rom_greedy -offline -f 2.2 This full order model solution will be used to compute the relative error for the ROM solution. The ROM solution can be obtained by the following command line option: ./poisson_local_rom_greedy -use_database -online -f 2.2 Indeed, the relative error of 0.00167671 is achieved","title":"Greedy for Poisson equation"},{"location":"publications.html","text":"Publications 2023 Q.A. Huhn, M.E. Tano, J.C. Ragusa, Y. Choi, Parametric dynamic mode decomposition for reduced order modeling , Journal of Computational Physics , 475, 111852, 2023 S.W Cheung, Y. Choi, D. Copeland, K. Huynh, Local Lagrangian reduced-order modeling for Rayleigh-Taylor instability by solution manifold decomposition , Journal of Computational Physics , 472, 111655, 2023 2022 T. Kadeethum, F. Ballarin, D. O'Malley, Y. Choi, N. Bouklas, H. Yoon, Reduced order modeling for flow and transport problems with Barlow Twins self-supervised learning , Scientific Reports , 12(1), 2022 X. He, Y. Choi, W. Fries, J. Belof, J.S. Chen, Certified data-driven physics-informed greedy auto-encoder simulator , arXiv preprint , arXiv:2211.13698, 2022 C. G. Petra, M. Salazar De Troya, N. Petra, Y. Choi, G. M. Oxberry, D. Tortorelli, On the implementation of a quasi-Newton interior-point method for PDE-constrained optimization using finite element discretizations , Optimization Methods and Software , 1-32, 2022 S. McBane, Y. Choi, K. Willcox, Stress-constrained topology optimization of lattice-like structures using component-wise reduced order models , Computer Methods in Applied Mechanics and Engineering , 400, 115525, 2022 T. Kadeethum, D. O'Malley, Y. Choi, H.S. Viswanathan, N. Bouklas, and H. Yoon, Continuous conditional generative adversarial networks for data-driven solutions of poroelasticity with heterogeneous material properties , Computers & Geosciences , Volume 167, 105212, 2022 W. Fries, X. He, Y. Choi, LaSDI: Parametric latent space dynamics identification , Computer Methods in Applied Mechanics and Engineering , volume 399, 115436, 2022 , Also available as arXiv:2203.02076 . C.F. Jekel, D.M. Sterbentz, S. Aubry, Y. Choi, D.A. White, J.L. Belof, Using Conservation Laws to Infer Deep Learning Model Accuracy of Richtmyer-Meshkov Instabilities arXiv preprint , arXiv:2208.11477, 2022 X. He, Y. Choi, W. Fries, J. Belof, J.S. Chen, gLaSDI: Parametric physics-informed greedy latent space dynamics identification , arXiv preprint , arXiv:2204.12005, 2022 J.T. Lauzon, S.W. Cheung, Y. Shin, Y. Choi, D. M. Copeland, K. Huynh, S-OPT: a points selection algorithm for hyper-reduction in reduced order models , arXiv preprint , arXiv:2203.16494, 2022 Y. Kim, Y. Choi, D. Widemann, T. Zohdi, A fast and accurate physics-informed neural network reduced order model with shallow masked autoencoder , Journal of Computational Physics , 451, 110841, 2022 . Also available as arXiv:2009.11990 . T. Kadeethum, F. Ballarin, D. O'Malley, Y. Choi, N. Bouklas, H. Yoon, Reduced order modeling with Barlow Twins self-supervised learning: Navigating the space between linear and nonlinear solution manifolds , arXiv preprint , arXiv:2202.05460, 2022 T. Kadeethum, F. Ballarin, Y. Choi, D. O'Malley, H. Yoon, N. Bouklas, Non-intrusive reduced order modeling of natural convection in porous media using convolutional autoencoders: Comparison with linear subspace techniques , Advances in Water Resources , Volume 160, 104098, 2022 2021 T. Kadeethum, D. O'Malley, J.N. Fuhg, Y. Choi, J. Lee, H.S. Viswanathan, N. Bouklas, A framework for data-driven solution and parameter estimation of PDEs using conditional generative adversarial networks , Nature Computational Science , 1, 819-829, 2021 D. Copeland, S.W. Cheung, K. Huynh, Y. Choi, Reduced order models for Lagrangian hydrodynamics , Computer Methods in Applied Mechanics and Engineering , Volume 388, 114259, 2021 . Also available as arXiv:2104.11404 . C. Hoang, Y. Choi, K. Carlberg, Domain-decomposition least-squares Petrov-Galerkin (DD-LSPG) nonlinear model reduction , Computer Methods in Applied Mechanics and Engineering , Volume 384, 113997, 2021 S. McBane, Y. Choi, Component-wise reduced order model lattice-type structure design , Computer Methods in Applied Mechanics and Engineering , 381, 113813, 2021 Y. Kim, K.M. Wang, Y. Choi, Efficient space-time reduced order model for linear dynamical systems in Python using less than 120 lines of code , Mathematics , 9(14), 1690, 2021 Y. Choi, P. Brown, W. Arrighi, R. Anderson, K. Huynh, Space-time reduced order model for large-scale linear dynamical systems with application to Boltzmann transport problems , Journal of Computational Physics , 424, 109845, 2021 . Also available as arXiv:1910.01260 . 2020 Y. Choi, D. Coombs, R. Anderson, SNS: A Solution-based nonlinear subspace method for time-dependent model order reduction , SIAM Journal on Scientific Computing , 42(2), A1116-A1147, 2020 Y. Choi, G. Boncoraglio, S. Anderson, D. Amsallem, C. Farhat Gradient-based constrained optimization using a database of linear reduced order models , Journal of Computational Physics , 423, 109787, 2020 . Also available as arXiv:1506.07849 . Y. Kim, Y. Choi, D. Widemann, T. Zohdi, Efficient nonlinear manifold reduced order model Workshop on machine learning for engineering modeling, simulation and design @ NeurIPS 2020 , 2020 . Also available as arXiv:2011.07727 2019 and earlier Y. Choi, K. Carlberg, Space-time least-squares Petrov-Galerkin projection for nonlinear model reduction , SIAM Journal on Scientific Computing , 41(1), A26-A58, 2019 Y. Choi, G. Oxberry, D. Whit, T. Kirchdoerfer, Accelerating design optimization using reduced order models , arXiv preprint , arXiv:1909.11320, 2019 K. Carlberg, Y. Choi, S. Sargsyan, Conservative model reduction for finite-volume models , Journal of Computational Physics , 371, p280-314, 2018 G. Oxberry, T. Kostova-Vassilevska, W. Arrighi, K. Chand, Limited-memory adaptive snapshot selection for proper orthogonal decomposition , International Journal of Numerical Methods in Engineering , 109(2), p198-217, 2016 D. Amsallem, M. Zahr, Y. Choi, C. Farhat, Design optimization using hyper-reduced-order models , Structural and Multidisciplinary Optimization , 51, p919-940, 2015 MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Publications"},{"location":"publications.html#publications","text":"","title":"Publications"},{"location":"publications.html#2023","text":"Q.A. Huhn, M.E. Tano, J.C. Ragusa, Y. Choi, Parametric dynamic mode decomposition for reduced order modeling , Journal of Computational Physics , 475, 111852, 2023 S.W Cheung, Y. Choi, D. Copeland, K. Huynh, Local Lagrangian reduced-order modeling for Rayleigh-Taylor instability by solution manifold decomposition , Journal of Computational Physics , 472, 111655, 2023","title":"2023"},{"location":"publications.html#2022","text":"T. Kadeethum, F. Ballarin, D. O'Malley, Y. Choi, N. Bouklas, H. Yoon, Reduced order modeling for flow and transport problems with Barlow Twins self-supervised learning , Scientific Reports , 12(1), 2022 X. He, Y. Choi, W. Fries, J. Belof, J.S. Chen, Certified data-driven physics-informed greedy auto-encoder simulator , arXiv preprint , arXiv:2211.13698, 2022 C. G. Petra, M. Salazar De Troya, N. Petra, Y. Choi, G. M. Oxberry, D. Tortorelli, On the implementation of a quasi-Newton interior-point method for PDE-constrained optimization using finite element discretizations , Optimization Methods and Software , 1-32, 2022 S. McBane, Y. Choi, K. Willcox, Stress-constrained topology optimization of lattice-like structures using component-wise reduced order models , Computer Methods in Applied Mechanics and Engineering , 400, 115525, 2022 T. Kadeethum, D. O'Malley, Y. Choi, H.S. Viswanathan, N. Bouklas, and H. Yoon, Continuous conditional generative adversarial networks for data-driven solutions of poroelasticity with heterogeneous material properties , Computers & Geosciences , Volume 167, 105212, 2022 W. Fries, X. He, Y. Choi, LaSDI: Parametric latent space dynamics identification , Computer Methods in Applied Mechanics and Engineering , volume 399, 115436, 2022 , Also available as arXiv:2203.02076 . C.F. Jekel, D.M. Sterbentz, S. Aubry, Y. Choi, D.A. White, J.L. Belof, Using Conservation Laws to Infer Deep Learning Model Accuracy of Richtmyer-Meshkov Instabilities arXiv preprint , arXiv:2208.11477, 2022 X. He, Y. Choi, W. Fries, J. Belof, J.S. Chen, gLaSDI: Parametric physics-informed greedy latent space dynamics identification , arXiv preprint , arXiv:2204.12005, 2022 J.T. Lauzon, S.W. Cheung, Y. Shin, Y. Choi, D. M. Copeland, K. Huynh, S-OPT: a points selection algorithm for hyper-reduction in reduced order models , arXiv preprint , arXiv:2203.16494, 2022 Y. Kim, Y. Choi, D. Widemann, T. Zohdi, A fast and accurate physics-informed neural network reduced order model with shallow masked autoencoder , Journal of Computational Physics , 451, 110841, 2022 . Also available as arXiv:2009.11990 . T. Kadeethum, F. Ballarin, D. O'Malley, Y. Choi, N. Bouklas, H. Yoon, Reduced order modeling with Barlow Twins self-supervised learning: Navigating the space between linear and nonlinear solution manifolds , arXiv preprint , arXiv:2202.05460, 2022 T. Kadeethum, F. Ballarin, Y. Choi, D. O'Malley, H. Yoon, N. Bouklas, Non-intrusive reduced order modeling of natural convection in porous media using convolutional autoencoders: Comparison with linear subspace techniques , Advances in Water Resources , Volume 160, 104098, 2022","title":"2022"},{"location":"publications.html#2021","text":"T. Kadeethum, D. O'Malley, J.N. Fuhg, Y. Choi, J. Lee, H.S. Viswanathan, N. Bouklas, A framework for data-driven solution and parameter estimation of PDEs using conditional generative adversarial networks , Nature Computational Science , 1, 819-829, 2021 D. Copeland, S.W. Cheung, K. Huynh, Y. Choi, Reduced order models for Lagrangian hydrodynamics , Computer Methods in Applied Mechanics and Engineering , Volume 388, 114259, 2021 . Also available as arXiv:2104.11404 . C. Hoang, Y. Choi, K. Carlberg, Domain-decomposition least-squares Petrov-Galerkin (DD-LSPG) nonlinear model reduction , Computer Methods in Applied Mechanics and Engineering , Volume 384, 113997, 2021 S. McBane, Y. Choi, Component-wise reduced order model lattice-type structure design , Computer Methods in Applied Mechanics and Engineering , 381, 113813, 2021 Y. Kim, K.M. Wang, Y. Choi, Efficient space-time reduced order model for linear dynamical systems in Python using less than 120 lines of code , Mathematics , 9(14), 1690, 2021 Y. Choi, P. Brown, W. Arrighi, R. Anderson, K. Huynh, Space-time reduced order model for large-scale linear dynamical systems with application to Boltzmann transport problems , Journal of Computational Physics , 424, 109845, 2021 . Also available as arXiv:1910.01260 .","title":"2021"},{"location":"publications.html#2020","text":"Y. Choi, D. Coombs, R. Anderson, SNS: A Solution-based nonlinear subspace method for time-dependent model order reduction , SIAM Journal on Scientific Computing , 42(2), A1116-A1147, 2020 Y. Choi, G. Boncoraglio, S. Anderson, D. Amsallem, C. Farhat Gradient-based constrained optimization using a database of linear reduced order models , Journal of Computational Physics , 423, 109787, 2020 . Also available as arXiv:1506.07849 . Y. Kim, Y. Choi, D. Widemann, T. Zohdi, Efficient nonlinear manifold reduced order model Workshop on machine learning for engineering modeling, simulation and design @ NeurIPS 2020 , 2020 . Also available as arXiv:2011.07727","title":"2020"},{"location":"publications.html#2019-and-earlier","text":"Y. Choi, K. Carlberg, Space-time least-squares Petrov-Galerkin projection for nonlinear model reduction , SIAM Journal on Scientific Computing , 41(1), A26-A58, 2019 Y. Choi, G. Oxberry, D. Whit, T. Kirchdoerfer, Accelerating design optimization using reduced order models , arXiv preprint , arXiv:1909.11320, 2019 K. Carlberg, Y. Choi, S. Sargsyan, Conservative model reduction for finite-volume models , Journal of Computational Physics , 371, p280-314, 2018 G. Oxberry, T. Kostova-Vassilevska, W. Arrighi, K. Chand, Limited-memory adaptive snapshot selection for proper orthogonal decomposition , International Journal of Numerical Methods in Engineering , 109(2), p198-217, 2016 D. Amsallem, M. Zahr, Y. Choi, C. Farhat, Design optimization using hyper-reduced-order models , Structural and Multidisciplinary Optimization , 51, p919-940, 2015 MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"2019 and earlier"},{"location":"rom.html","text":"Projection-based Reduced Order Model The reduced order models are achieved by applying data-driven model order reduction techniques to high-fidelity physics models, typically represented by partial differential equations (PDEs). There is a large body of literature on reduced order models, including the following excellent books: Certified reduced basis methods for parametrized partial differential equations by Jan S. Hesthaven and Gianluigi Rozza and Benjamin Stamm Model reduction of parametrized systems by Peter Benner and Mario Ohlberger and Anthony T. Patera and Gianluigi Rozza and Karsten Urban Reduced-order modeling (ROM) for simulation and optimization by Winfried Keiper and Anja Milde and Stefan Volkwein Approximation of large-scale dynamical systems by Athanasios C. Antoulas Machine learning, low-rank approximations and reduced order modeling in computational mechanics by Felix Fritzen and David Ryckelynck Machine learning for model order reduction by Khaled Salah Mohamed Reduced order methods for modeling and computational reduction by Alfio Quarteroni and Gianluigi Rozza The successful reduced order model development depends on many factors: Good quality and quantity of data Optimal and scalable data reduction schemes Optimal projection methods Efficient hyper-reduction for nonlinear reduction Sampling algorithms The libROM is designed to provide useful and scalable identify the low-rank approximation be lightweight, general and highly scalable reduced order model toolkit that provides the building blocks for developing finite element algorithms in a manner similar to that of MATLAB for linear algebra methods. The success measure for a reduced order model: speed-up accuracy differentiability verifiability predictability Some of the C++ classes for the finite element realizations of these PDE-level concepts in libROM are described below.","title":"Projection-based Reduced Order Model"},{"location":"rom.html#projection-based-reduced-order-model","text":"The reduced order models are achieved by applying data-driven model order reduction techniques to high-fidelity physics models, typically represented by partial differential equations (PDEs). There is a large body of literature on reduced order models, including the following excellent books: Certified reduced basis methods for parametrized partial differential equations by Jan S. Hesthaven and Gianluigi Rozza and Benjamin Stamm Model reduction of parametrized systems by Peter Benner and Mario Ohlberger and Anthony T. Patera and Gianluigi Rozza and Karsten Urban Reduced-order modeling (ROM) for simulation and optimization by Winfried Keiper and Anja Milde and Stefan Volkwein Approximation of large-scale dynamical systems by Athanasios C. Antoulas Machine learning, low-rank approximations and reduced order modeling in computational mechanics by Felix Fritzen and David Ryckelynck Machine learning for model order reduction by Khaled Salah Mohamed Reduced order methods for modeling and computational reduction by Alfio Quarteroni and Gianluigi Rozza The successful reduced order model development depends on many factors: Good quality and quantity of data Optimal and scalable data reduction schemes Optimal projection methods Efficient hyper-reduction for nonlinear reduction Sampling algorithms The libROM is designed to provide useful and scalable identify the low-rank approximation be lightweight, general and highly scalable reduced order model toolkit that provides the building blocks for developing finite element algorithms in a manner similar to that of MATLAB for linear algebra methods. The success measure for a reduced order model: speed-up accuracy differentiability verifiability predictability Some of the C++ classes for the finite element realizations of these PDE-level concepts in libROM are described below.","title":"Projection-based Reduced Order Model"}]}