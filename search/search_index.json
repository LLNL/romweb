{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"libROM is a free , lightweight , scalable C++ library for data-driven physical simulation methods. It is the main tool box that the reduced order modeling team at LLNL uses to develop efficient model order reduction techniques and physics-constrained data-driven methods . We try to collect any useful reduced order model routines, which are separable to the high-fidelity physics solvers, into libROM. Plus, libROM is open source, so anyone is welcome to suggest new ideas or contribute to the development. Let's work together for better data-driven technology! Features Proper Orthogonal Decomposition Dynamic mode decomposition Projection-based reduced order models Hyper-reduction Greedy algorithm Many more features will be available soon. Stay tuned! libROM is used in many projects, including BLAST , ARDRA , Laghos , and SU2 . Many MFEM -based ROM examples can be found in Examples . See also our Gallery , Publications and News pages. News Date Message Nov 10, 2021 Laghos ROM is published at CMAME. Free download is available for 50 days. Oct 1, 2021 Domain decomposition ROM paper is published at CMAME Sep 27, 2021 First version of libROM webpage is launched July 19, 2021 Space time ROM-Python paper is published in Mathematics Jan 1, 2021 Space-time ROM paper is published in Journal of Computational Physics libROM tutorials in YouTube Date Title July 22, 2021 Poisson equation & its finite element discretization Sep. 1, 2021 Poisson equation & its reduced order model Sep. 23, 2021 Physics-informed sampling procedure for reduced order models Latest Release Examples \u250a Code documentation \u250a Sources Download libROM-master.zip Documentation Building libROM \u250a Poisson equation \u250a Greedy for Poisson New users should start by examining the example codes and tutorials . We also recommend using GLVis or VisIt for visualization. Contact Use the GitHub issue tracker to report bugs or post questions or comments . See the About page for citation information.","title":"Home"},{"location":"index.html#features","text":"Proper Orthogonal Decomposition Dynamic mode decomposition Projection-based reduced order models Hyper-reduction Greedy algorithm Many more features will be available soon. Stay tuned! libROM is used in many projects, including BLAST , ARDRA , Laghos , and SU2 . Many MFEM -based ROM examples can be found in Examples . See also our Gallery , Publications and News pages.","title":"Features"},{"location":"index.html#news","text":"Date Message Nov 10, 2021 Laghos ROM is published at CMAME. Free download is available for 50 days. Oct 1, 2021 Domain decomposition ROM paper is published at CMAME Sep 27, 2021 First version of libROM webpage is launched July 19, 2021 Space time ROM-Python paper is published in Mathematics Jan 1, 2021 Space-time ROM paper is published in Journal of Computational Physics","title":"News"},{"location":"index.html#librom-tutorials-in-youtube","text":"Date Title July 22, 2021 Poisson equation & its finite element discretization Sep. 1, 2021 Poisson equation & its reduced order model Sep. 23, 2021 Physics-informed sampling procedure for reduced order models","title":"libROM tutorials in YouTube"},{"location":"index.html#latest-release","text":"Examples \u250a Code documentation \u250a Sources Download libROM-master.zip","title":"Latest Release"},{"location":"index.html#documentation","text":"Building libROM \u250a Poisson equation \u250a Greedy for Poisson New users should start by examining the example codes and tutorials . We also recommend using GLVis or VisIt for visualization.","title":"Documentation"},{"location":"index.html#contact","text":"Use the GitHub issue tracker to report bugs or post questions or comments . See the About page for citation information.","title":"Contact"},{"location":"about.html","text":"About libROM Please cite with: @misc{ doecode_24508, title = {libROM}, author = {Choi, Youngsoo and Arrighi, William J. and Copeland, Dylan M. and Anderson, Robert W. and Oxberry, Geoffrey M.}, abstractNote = {libROM is a collection of C++ classes that compute reduced order models and hyperreduced order models for systems of ordinary differential equations. libROM includes parallel, adaptive methods for proper orthogonal decomposition, and parallel, non-adaptive methods for hyperreduction using the discrete empirical interpolation method.}, doi = {10.11578/dc.20190408.3}, url = {https://doi.org/10.11578/dc.20190408.3}, howpublished = {[Computer Software] \\url{https://doi.org/10.11578/dc.20190408.3}}, year = {2019}, month = {oct} } Contributors Bob Anderson Siu Wun Cheung Youngsoo Choi Dylan Copeland Kevin Huynh Jessica Lauzon Sean McBane Geoffrey Oxberry License MIT license Apache license This work performed under the auspices of the U.S. Department of Energy by Lawrence Livermore Laboratory under Contract DE-AC52-07NA27344. Software release number: LLNL-CODE-766763. DOI: 10.11578/dc.20190408.3 . Disclaimer This document was prepared as an account of work sponsored by an agency of the United States government. Neither the United States government nor Lawrence Livermore National Security, LLC, nor any of their employees makes any warranty, expressed or implied, or assumes any legal liability or responsibility for the accuracy, completeness, or usefulness of any information, apparatus, product, or process disclosed, or represents that its use would not infringe privately owned rights. Reference herein to any specific commercial product, process, or service by trade name, trademark, manufacturer, or otherwise does not necessarily constitute or imply its endorsement, recommendation, or favoring by the United States government or Lawrence Livermore National Security, LLC. The views and opinions of authors expressed herein do not necessarily state or reflect those of the United States government or Lawrence Livermore National Security, LLC, and shall not be used for advertising or product endorsement purposes. Website built with MkDocs , Bootstrap and Bootswatch . Hosted on GitHub .","title":"About"},{"location":"about.html#about-librom","text":"Please cite with: @misc{ doecode_24508, title = {libROM}, author = {Choi, Youngsoo and Arrighi, William J. and Copeland, Dylan M. and Anderson, Robert W. and Oxberry, Geoffrey M.}, abstractNote = {libROM is a collection of C++ classes that compute reduced order models and hyperreduced order models for systems of ordinary differential equations. libROM includes parallel, adaptive methods for proper orthogonal decomposition, and parallel, non-adaptive methods for hyperreduction using the discrete empirical interpolation method.}, doi = {10.11578/dc.20190408.3}, url = {https://doi.org/10.11578/dc.20190408.3}, howpublished = {[Computer Software] \\url{https://doi.org/10.11578/dc.20190408.3}}, year = {2019}, month = {oct} }","title":"About libROM"},{"location":"about.html#contributors","text":"Bob Anderson Siu Wun Cheung Youngsoo Choi Dylan Copeland Kevin Huynh Jessica Lauzon Sean McBane Geoffrey Oxberry","title":"Contributors"},{"location":"about.html#license","text":"MIT license Apache license This work performed under the auspices of the U.S. Department of Energy by Lawrence Livermore Laboratory under Contract DE-AC52-07NA27344. Software release number: LLNL-CODE-766763. DOI: 10.11578/dc.20190408.3 .","title":"License"},{"location":"about.html#disclaimer","text":"This document was prepared as an account of work sponsored by an agency of the United States government. Neither the United States government nor Lawrence Livermore National Security, LLC, nor any of their employees makes any warranty, expressed or implied, or assumes any legal liability or responsibility for the accuracy, completeness, or usefulness of any information, apparatus, product, or process disclosed, or represents that its use would not infringe privately owned rights. Reference herein to any specific commercial product, process, or service by trade name, trademark, manufacturer, or otherwise does not necessarily constitute or imply its endorsement, recommendation, or favoring by the United States government or Lawrence Livermore National Security, LLC. The views and opinions of authors expressed herein do not necessarily state or reflect those of the United States government or Lawrence Livermore National Security, LLC, and shall not be used for advertising or product endorsement purposes. Website built with MkDocs , Bootstrap and Bootswatch . Hosted on GitHub .","title":"Disclaimer"},{"location":"building.html","text":"Building libROM A simple tutorial on how to build and run libROM. For more details, see the README file. In addition to the native build system described below, libROM packages are also available in Spack: Spack Instructions Clone libROM https://github.com/LLNL/libROM Installation To compile libROM with default build settings (Mac and LLNL LC Machines): ./scripts/compile.sh To compile libROM for Ardra (LLNL LC Machines only): ./scripts/ardra_compile.sh To compile libROM using a different toolchain within cmake/toolchains (Mac and LLNL LC Machines): ./scripts/toolchain_compile.sh toolchain.cmake Compilation options: -a: Compile a special build for the LLNL codebase: Ardra -d: Compile in debug mode. -m: Compile with MFEM (required to run the libROM examples) -t: Use your own cmake/toolchain -u: Update all of libROM's dependencies.","title":"Building libROM"},{"location":"building.html#building-librom","text":"A simple tutorial on how to build and run libROM. For more details, see the README file. In addition to the native build system described below, libROM packages are also available in Spack: Spack","title":"Building libROM"},{"location":"building.html#instructions","text":"Clone libROM https://github.com/LLNL/libROM","title":"Instructions"},{"location":"building.html#installation","text":"To compile libROM with default build settings (Mac and LLNL LC Machines): ./scripts/compile.sh To compile libROM for Ardra (LLNL LC Machines only): ./scripts/ardra_compile.sh To compile libROM using a different toolchain within cmake/toolchains (Mac and LLNL LC Machines): ./scripts/toolchain_compile.sh toolchain.cmake Compilation options: -a: Compile a special build for the LLNL codebase: Ardra -d: Compile in debug mode. -m: Compile with MFEM (required to run the libROM examples) -t: Use your own cmake/toolchain -u: Update all of libROM's dependencies.","title":"Installation"},{"location":"ddps.html","text":"MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}}); DDPS Webinar ( in California time ) Scheduled Talks, 2021 When Speaker Institution Title WebEx Nov. 12, 10 AM WaiChing Sun Columbia University Data-driven constitutive updates: from model-free poroelasticity to level set plasticity trained by neural networks link Nov. 18, 10 AM Michael Mahoney UC Berkeley TBD link Dec. 3, 10 AM Igor Mezic UC Santa Barbara TBD link Past Talks in 2021 Date Speaker Institution Title YouTube Nov. 4th Misha Khodak CMU Towards automatic architecture design for emerging machine learning tasks link Oct. 28th Masayuki Yano U. of Toronto Towards reliable, efficient, and automated model reduction of parametrized nonlinear PDEs: error estimation, adaptivity, and application to aerodynamics link Oct. 7th Youngsoo Choi LLNL libROM: Library for physics-constrained data-driven physical simulations link Sep. 30th Peter Benner Max Planck Identification of Nonlinear Dynamical Systems from Noisy Measurements link Sep. 2nd Ionut-Gabriel Farcas Oden Institute Learning hierarchies of reduced-dimension and context-aware low-fidelity models for multi-fidelity Monte Carlo sampling link Aug. 26th Jesse Capecelatro U. of Michagan Turbulent disperse two-phase flows: simulations and data-driven modeling link Aug. 19th Christopher J. Earls Cornell U. Gaining mechanistic insight through learning Green's functions: Uncovering the solutions to hidden PDEs link Aug. 13, 10 AM Dmitriy Anistratov North Carolina State U. Reduced order models for thermal radiative transfer problems based on moment equations and POD/DMD of Eddington tensor link Aug. 5th Luca Magri Imperial College, London Physics-aware reservoir-computing for turbulence and chaotic learning NA Jul. 30th Marta D'Elia Sandia Data-driven learning of nonlocal models: bridging scales and design of new neural networks link Jul. 22nd Hannah Lu Stanford U. Dynamic model decomposition for reduced order modeling in flow and transport problems NA Jul. 15th Yeonjong Shin Brown U. Towards a mathematical understanding of modern machine learning: theory, algorithms, and applications link Jul. 9th Rui Wang UC, San Diego Physics-guided deep learning for dynamics for forecasting link Jul. 1st Tan Bui UT, Austin Model-constrained deep learning approaches for inference, control, and uncertainty quantification link Jun. 24th Matthew Zahr U. of Notre Dame Model reduction of convection-dominated partial differential equations via optimization-based implicit feature tracking link Jun. 10th David Ryckelynck Mines ParisTech Model order reduction assisted by deep neural networks (ROM-net) link Jun. 3rd Harbir Antil George Mason U. Applications of Fractional Operators from Optimal Control to Machine Learning link May 27th Romit Maulik Argonne Neural architecture search for surrogate modeling link May 20th Tobias Pfaff, Alvaro Sanchez-Gonzalez DeepMind Learning physical simulation with Graph Network link May 14th George Karniadakis Brown U. Approximating functions, functionals, and operators using deep neural networks for diverse applications link Apr. 29th Traian Iliescu Virginia Tech. Large Eddy Simulation Reduced Order Models (LES-ROMs) link Apr. 15th Tommaso Taddei Inria Registration-based model reduction of parameterized advection-dominated PDEs link Apr. 7th Francisco Chinesta ENSAM ParisTech Empowering Hybrid Twins from Physics-Informed Artificial Intelligence link Apr. 1st Priya Donti Carnegie Mellon U. Incorporating power system physics into deep learning via implicit layers link Mar. 25th Mario Ohlberger U. Munster Model reduction with adaptive enrichment for large scale PDE-constrained optimization link Mar. 18th Karthik Duraisamy U. of Michigan Towards Robust, Accurate and Tractable Reduced Order Models for Multi-scale, Multi-physics Problems link Mar. 10th Pawan Goyal Max Planck Physics-informed learning for nonlinear dynamical systems: a deep learning approach to operator inference link Feb. 18th Nils Thuerey Technische Universitat Munchen Differentiable Physics Simulations for Deep Learning link Jan. 27th Alfio Quarteroni EPFL The mathematical heart: a computational model for the simulation of the heart function link Jan. 21th Steven Brunton U. of Washington Interpretable and Generalizable Machine Learning for Fluid Mechanics link Jan. 7th Irina Tezaur Sandia The Schwarz alternating methods as a means for concurrent multiscale coupling in solid mechanics link Past Talks in 2020 Date Speaker Institution Title YouTube Dec. 17th Jan Hesthaven EPFL Non-intrusive reduced order models using physics informed neural networks link Dec. 10th Jesse Chan Rice U. Entropy stable schemes for nonlinear conservation laws: high order discontinuous Galerkin methods and reduced order modeling link Nov. 18th Paris Perdikaris UPenn When and why physics-informed neural networks fail to train: A neural tangent kernel perspective link Nov. 12th Donsub Rim Courant Institute Distilling nonlinear shock waves: Nonlinear model reduction for transport dominated problems using deep neural networks link Oct. 29th Byungsoo Kim ETH Zurich Data-Driven Methods for Fluid Simulations in Computer Graphics link","title":"DDPS"},{"location":"ddps.html#ddps-webinar-in-california-time","text":"","title":"DDPS Webinar (in California time)"},{"location":"ddps.html#scheduled-talks-2021","text":"When Speaker Institution Title WebEx Nov. 12, 10 AM WaiChing Sun Columbia University Data-driven constitutive updates: from model-free poroelasticity to level set plasticity trained by neural networks link Nov. 18, 10 AM Michael Mahoney UC Berkeley TBD link Dec. 3, 10 AM Igor Mezic UC Santa Barbara TBD link","title":"Scheduled Talks, 2021"},{"location":"ddps.html#past-talks-in-2021","text":"Date Speaker Institution Title YouTube Nov. 4th Misha Khodak CMU Towards automatic architecture design for emerging machine learning tasks link Oct. 28th Masayuki Yano U. of Toronto Towards reliable, efficient, and automated model reduction of parametrized nonlinear PDEs: error estimation, adaptivity, and application to aerodynamics link Oct. 7th Youngsoo Choi LLNL libROM: Library for physics-constrained data-driven physical simulations link Sep. 30th Peter Benner Max Planck Identification of Nonlinear Dynamical Systems from Noisy Measurements link Sep. 2nd Ionut-Gabriel Farcas Oden Institute Learning hierarchies of reduced-dimension and context-aware low-fidelity models for multi-fidelity Monte Carlo sampling link Aug. 26th Jesse Capecelatro U. of Michagan Turbulent disperse two-phase flows: simulations and data-driven modeling link Aug. 19th Christopher J. Earls Cornell U. Gaining mechanistic insight through learning Green's functions: Uncovering the solutions to hidden PDEs link Aug. 13, 10 AM Dmitriy Anistratov North Carolina State U. Reduced order models for thermal radiative transfer problems based on moment equations and POD/DMD of Eddington tensor link Aug. 5th Luca Magri Imperial College, London Physics-aware reservoir-computing for turbulence and chaotic learning NA Jul. 30th Marta D'Elia Sandia Data-driven learning of nonlocal models: bridging scales and design of new neural networks link Jul. 22nd Hannah Lu Stanford U. Dynamic model decomposition for reduced order modeling in flow and transport problems NA Jul. 15th Yeonjong Shin Brown U. Towards a mathematical understanding of modern machine learning: theory, algorithms, and applications link Jul. 9th Rui Wang UC, San Diego Physics-guided deep learning for dynamics for forecasting link Jul. 1st Tan Bui UT, Austin Model-constrained deep learning approaches for inference, control, and uncertainty quantification link Jun. 24th Matthew Zahr U. of Notre Dame Model reduction of convection-dominated partial differential equations via optimization-based implicit feature tracking link Jun. 10th David Ryckelynck Mines ParisTech Model order reduction assisted by deep neural networks (ROM-net) link Jun. 3rd Harbir Antil George Mason U. Applications of Fractional Operators from Optimal Control to Machine Learning link May 27th Romit Maulik Argonne Neural architecture search for surrogate modeling link May 20th Tobias Pfaff, Alvaro Sanchez-Gonzalez DeepMind Learning physical simulation with Graph Network link May 14th George Karniadakis Brown U. Approximating functions, functionals, and operators using deep neural networks for diverse applications link Apr. 29th Traian Iliescu Virginia Tech. Large Eddy Simulation Reduced Order Models (LES-ROMs) link Apr. 15th Tommaso Taddei Inria Registration-based model reduction of parameterized advection-dominated PDEs link Apr. 7th Francisco Chinesta ENSAM ParisTech Empowering Hybrid Twins from Physics-Informed Artificial Intelligence link Apr. 1st Priya Donti Carnegie Mellon U. Incorporating power system physics into deep learning via implicit layers link Mar. 25th Mario Ohlberger U. Munster Model reduction with adaptive enrichment for large scale PDE-constrained optimization link Mar. 18th Karthik Duraisamy U. of Michigan Towards Robust, Accurate and Tractable Reduced Order Models for Multi-scale, Multi-physics Problems link Mar. 10th Pawan Goyal Max Planck Physics-informed learning for nonlinear dynamical systems: a deep learning approach to operator inference link Feb. 18th Nils Thuerey Technische Universitat Munchen Differentiable Physics Simulations for Deep Learning link Jan. 27th Alfio Quarteroni EPFL The mathematical heart: a computational model for the simulation of the heart function link Jan. 21th Steven Brunton U. of Washington Interpretable and Generalizable Machine Learning for Fluid Mechanics link Jan. 7th Irina Tezaur Sandia The Schwarz alternating methods as a means for concurrent multiscale coupling in solid mechanics link","title":"Past Talks in 2021"},{"location":"ddps.html#past-talks-in-2020","text":"Date Speaker Institution Title YouTube Dec. 17th Jan Hesthaven EPFL Non-intrusive reduced order models using physics informed neural networks link Dec. 10th Jesse Chan Rice U. Entropy stable schemes for nonlinear conservation laws: high order discontinuous Galerkin methods and reduced order modeling link Nov. 18th Paris Perdikaris UPenn When and why physics-informed neural networks fail to train: A neural tangent kernel perspective link Nov. 12th Donsub Rim Courant Institute Distilling nonlinear shock waves: Nonlinear model reduction for transport dominated problems using deep neural networks link Oct. 29th Byungsoo Kim ETH Zurich Data-Driven Methods for Fluid Simulations in Computer Graphics link","title":"Past Talks in 2020"},{"location":"download.html","text":"Latest Release Code documentation \u250a Sources Download libROM-master.zip Please use the GitHub issue tracker to report bugs or post questions or comments . All Releases Filename Version Release Date Size CLOC Notes libROM-master.zip v1.0 Sep 2021 160K 22K initial release","title":"Download"},{"location":"download.html#latest-release","text":"Code documentation \u250a Sources Download libROM-master.zip Please use the GitHub issue tracker to report bugs or post questions or comments .","title":"Latest Release"},{"location":"download.html#all-releases","text":"Filename Version Release Date Size CLOC Notes libROM-master.zip v1.0 Sep 2021 160K 22K initial release","title":"All Releases"},{"location":"examples.html","text":"MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}}); Example Applications This page provides a list of libROM example applications. For detailed documentation of the libROM sources, including the examples, see the online Doxygen documentation or the doc directory in the distribution. The goal of the example codes is to provide a step-by-step introduction to libROM in simple model settings. Select from the categories below to display examples and miniapps that contain the respective feature. All examples support (arbitrarily) high-order meshes and finite element spaces . The numerical results from the example codes can be visualized using the GLVis or VisIt visualization tools. See the GLVis and VisIt websites for more details. Users are encouraged to submit any example codes and miniapps that they have created and would like to share. Contact a member of the libROM team to report bugs or post questions or comments . **Application (PDE)** All Diffusion Elasticity Euler Advection Compressible flow **Reduced order models type** All pROM DMD **Parameterization type** All Trust region Interpolation Global Reproductive **hyper-reduction** All Hyper-reduction No hyper-reduction Poisson Problem This example code demonstrates the use of libROM and MFEM to define a reduced order model for a simple isoparametric finite element discretization of the Poisson problem $$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. The example parameterizes the righthand side with frequency variable, $\\kappa$: $$f = \\cases{ \\displaystyle \\sin(\\kappa (x_0+x_1+x_2)) & for 3D \\cr \\displaystyle \\sin(\\kappa (x_0+x_1)) & for 2D }$$ The 2D solution contour plot for $\\kappa=1$ is shown in the figure on the right to show the effect of $\\kappa$. For demonstration, we sample solutions at $\\kappa=1$, $1.1$, and $1.2$. Then a ROM is build with basis size of 3, which is used to predict the solution for $\\kappa = 1.15$. The ROM is able to achieve a speedup of $7.5$ with a relative error of $6.4\\times10^{-4}$. One can follow the command line options below to reproduce the numerical results summarized in the table below: offline1 : poisson -offline -f 1.0 -id 0 offline2 : poisson -offline -f 1.1 -id 1 offline3 : poisson -offline -f 1.2 -id 2 merge : poisson -merge -ns 3 online : poisson -online -f 1.15 FOM solution time ROM solution time Speed-up Solution relative error 0.22 sec 0.029 sec 7.5 6.4e-4 The code that generates the numerical results above can be found in ( poisson.cpp ) and the explanation of codes is provided in here . The poisson.cpp is based on ex1p.cpp from MFEM with a modification on the right hand side function. Advection For a given initial condition, i.e., $u_0(x) = u(0,x)$, DG advection solves the time-dependent advection problem: $$\\frac{\\partial u}{\\partial t} + v\\cdot\\nabla u = 0,$$ where $v$ is a given advection velocity. One can run the following command line options to reproduce the DMD results summarized in the table below: dg_advection -p 3 -rp 1 -dt 0.005 -tf 4 -visit FOM solution time DMD setup time DMD query time DMD relative error 5.2 sec 30.6 sec 1.9e-2 sec 1.9e-4 The code that generates the numerical results above can be found in ( dg_advection.cpp ). The dg_advection.cpp is based on ex9p.cpp from MFEM. Euler equation For a given initial condition, i.e., $u_0(x) = u(0,x)$, DG Euler solves the compressible Euler system of equation, i.e., a model nonlinear hyperbolic PDE: $$\\frac{\\partial u}{\\partial t} + \\nabla\\cdot \\boldsymbol{F}(u) = 0,$$ with a state vector $\\boldsymbol{u} = [\\rho,\\rho v_0, \\rho v_1, \\rho E]$, where $\\rho$ is the density, $v_i$ is the velocity in the $i$th direction, $E$ is the total specific energy, and $H = E + p/\\rho$ is the total specific enthalpy. The pressure, $p$ is computed through a simple equation of state (EOS) call. The conservative hydrodynamic flux $\\boldsymbol{F}$ in each direction $i$ is $$\\boldsymbol{F}_i = [\\rho v_i, \\rho v_0 v_i + p \\delta_{i,0}, \\rho v_1 v_{i,1} + p\\delta_{i,1}, \\rho v_i H]$$ One can run the following command line options to reproduce the DMD results summarized in the table below: mpirun -n 8 ./dg_euler -p 2 -rs 2 -rp 1 -o 1 -s 3 -visit DMD rel.error FOM solution time DMD setup time DMD query time $\\rho$ $\\rho v_0$ $\\rho v_1$ $E$ 5.65 sec 38.9 sec 1.4e-3 sec 8.0e-7 1.2e-4 1.6e-3 2.6e-6 The code that generates the numerical results above can be found in ( dg_euler.cpp ). The dg_euler.cpp is based on ex18p.cpp from MFEM. Heat conduction problem For a given initial condition, i.e., $u_0(x) = u(0,x)$, heat conduction solves a simple 2D/3D time dependent nonlinear heat conduction problem $$\\frac{\\partial u}{\\partial t} = \\nabla\\cdot (\\kappa + \\alpha u)\\nabla u,$$ with a natural insulating boundary condition $\\frac{du}{dn}=0$. We linearize the problem by using the temperature field $u$ from the previous time step to compute the conductivity coefficient. One can run the following command line options to reproduce the DMD results summarized in the table below: mpirun -np 8 ./heat_conduction -s 3 -a 0.5 -k 0.5 -o 4 -tf 0.7 -vs 1 -visit FOM solution time DMD setup time DMD query time DMD relative error 4.8 sec 0.34 sec 1.4e-3 sec 8.2e-4 The code that generates the numerical results above can be found in ( heat_conduction.cpp ). The heat_conduction.cpp is based on ex16p.cpp from MFEM. Mixed nonlinear diffusion For a given initial condition, i.e., $p_0(x) = p(0,x)$, mixed nonlinear diffusion problem solves a simple 2D/3D time dependent nonlinear problem: $$\\frac{\\partial p}{\\partial t} + \\nabla\\cdot \\boldsymbol{v} = f\\,, \\qquad \\nabla p = -a(p)\\boldsymbol{v},$$ with a natural insulating boundary condition $\\frac{\\partial v}{\\partial n}=0$. The $H(div)$-conforming Raviart-Thomas finite element space is used for the velocity function $\\boldsymbol{v}$, and the $L^2$ finite element space is used for pressure function, $p$. This example introduces how the hyper-reduction is implemented and how the reduced bases for two field varibles, $p$ and $\\boldsymbol{v}$. One can run the following command line options to reproduce the DMD results summarized in the table below: offline1 : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -offline -id 0 -sh 0.25 offline2 : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -offline -id 1 -sh 0.15 merge : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -merge -ns 2 offline3 : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -offline -id 2 -sh 0.2 online : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -online -rrdim 8 -rwdim 8 -sh 0.2 -id 2 FOM solution time ROM solution time Speed-up Solution relative error 41.68 sec 1.7 sec 24.5 1.6e-3 The code that generates the numerical results above can be found in ( mixed_nonlinear_diffusion.cpp ). The mixed_nonlinear_diffusion.cpp is based on ex16p.cpp from MFEM and modified to support mixed finite element approach. Nonlinear elasticity For a given initial condition, i.e., $v_0(x) = v(0,x)$, nonlinear elasticity solves a time dependent nonlinear elasticity problem of the form $$\\frac{\\partial v}{\\partial t} = H(x) + Sv\\,, \\qquad \\frac{\\partial x}{\\partial t} = v,$$ where $H$ is a hyperelastic model and $S$ is a viscosity operator of Laplacian type. One can run the following command line options to reproduce the DMD results summarized in the table below: mpirun -np 8 ./nonlinear_elasticity -s 2 -rs 1 -dt 0.01 -tf 5 -visit FOM solution time DMD setup time DMD query time Position relative error Velocity relative error 3.7 sec 4.7e-1 sec 6.9e-4 sec 7.0e-5 1.4e-3 The code that generates the numerical results above can be found in ( nonlinear_elasticity.cpp ). The nonlinear_elasticity.cpp is based on ex10p.cpp from MFEM. Laghos ROM Miniapp Laghos (LAGrangian High-Order Solver) is a miniapp that solves the time-dependent Euler equations of compressible gas dynamics in a moving Lagrangian frame using unstructured high-order finite element spatial discretization and explicit high-order time-stepping. LaghosROM introduces reduced order models of Laghos simulations. A list of example problems that you can solve with LaghosROM includes Sedov blast, Gresho vortex, Taylor-Green vortex, triple-point, and Rayleigh-Taylor instability problems. Below are command line options for each problems and some numerical results. For each problem, four different phases need to be taken, i.e., the offline, hyper-reduction preprocessing, online, and restore phase. The online phase runs necessary full order model (FOM) to generate simulation data. libROM dynamically collects the data as the FOM simulation marches in time domain. In the hyper-reduction preprocessing phase, the libROM builds a library of reduced basis as well as hyper-reduction operators. The online phase runs the ROM and the restore phase projects the ROM solutions to the full order model dimension. Sedov blast problem Sedov blast problem is a three-dimensional standard shock hydrodynamic benchmark test. An initial delta source of internal energy deposited at the origin of a three-dimensional cube is considered. The computational domain is the unit cube $\\tilde{\\Omega} = [0,1]^3$ with wall boundary conditions on all surfaces, i.e., $v\\cdot n = 0$. The initial velocity is given by $v=0$. The initial density is given by $\\rho = 1$. The initial energy is given by a delta function at the origin. The adiabatic index in the ideal gas equations of state is set $\\gamma = 1.4$. The initial mesh is a uniform Catesian hexahedral mesh, which deforms over time. It can be seen that the radial symmetry is maintained in the shock wave propagation in both FOM and ROM simulations. One can reproduce the numerical result, following the command line options described below: offline : ./laghos -o twp_sedov -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -offline -visit -romsvds -ef 0.9999 -writesol -romos -rostype load -romsns -nwinsamp 21 -sample-stages hyper-reduction preprocessing : ./laghos -o twp_sedov -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -online -romsvds -romos -rostype load -romhrprep -romsns -romgs -nwin 66 -sfacv 2 -sface 2 online : ./laghos -o twp_sedov -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -online -romsvds -romos -rostype load -romhr -romsns -romgs -nwin 66 -sfacv 2 -sface 2 restore : ./laghos -o twp_sedov -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -restore -soldiff -romsvds -romos -rostype load -romsns -romgs -nwin 66 FOM solution time ROM solution time Speed-up Velocity relative error 191 sec 8.3 sec 22.8 2.2e-4 Gresho vortex problem Gresho vortex problem is a two-dimensional benchmark test for the incompressible inviscid Navier-Stokes equations. The computational domain is the unit square $\\tilde\\Omega = [-0.5,0.5]^2$ with wall boundary conditions on all surfaces, i.e., $v\\dot n = 0$. Let $(r,\\phi)$ denote the polar coordinates of a particle $\\tilde{x} \\in \\tilde{\\Omega}$. The initial angular velocity is given by $$v_\\phi = \\cases{ \\displaystyle 5r & for 0 $\\leq$ r < 0.2 \\cr \\displaystyle 2-5r & for 0.2 $\\leq$ r < 0.4 \\cr \\displaystyle 0 i & for r $\\geq$ 0.4. }$$ The initial density if given by $\\rho=1$. The initial thermodynamic pressure is given by $$p = \\cases{ 5 + \\frac{25}{2} r^2 & for 0 $\\leq$ r < 0.2 \\cr 9 - 4 \\log(0.2) + \\frac{25}{2} - 20r + 4 \\log(r) & for 0.2 $\\leq$ r < 0.4 \\cr 3 + 4\\log(2) & for r $\\geq$ 0.4 }$$ offline : ./laghos -o twp_gresho -p 4 -m ../data/square_gresho.mesh -rs 4 -ok 3 -ot 2 -tf 0.62 -s 7 -visit -writesol -offline -ef 0.9999 -romsvds -romos -rostype load -romsns -nwinsamp 21 -sample-stages hyper-reduction preprocessing : ./laghos -o twp_gresho -p 4 -m ../data/square_gresho.mesh -rs 4 -ok 3 -ot 2 -tf 0.62 -s 7 -online -romhrprep -romsvds -romos -rostype load -romsns -romgs -nwin 152 -sfacv 2 -sface 2 online : ./laghos -o twp_gresho -p 4 -m ../data/square_gresho.mesh -rs 4 -ok 3 -ot 2 -tf 0.62 -s 7 -online -romhr -romsvds -romos -rostype load -romsns -romgs -nwin 152 -sfacv 2 -sface 2 restore : ./laghos -o twp_gresho -p 4 -m ../data/square_gresho.mesh -rs 4 -ok 3 -ot 2 -tf 0.62 -s 7 -soldiff -restore -romsvds -romos -rostype load -romsns -romgs -nwin 152 FOM solution time ROM solution time Speed-up Velocity relative error 218 sec 8.4 sec 25.9 2.1e-4 Taylor-Green vortex Taylor-Green vortex problem is a three-dimensional benchmark test for the incompressible Navier-Stokes equasions. A manufactured smooth solution is considered by extending the steady state Taylor-Green vortex solution to the compressible Euler equations. The computational domain is the unit cube $\\tilde{\\Omega}=[0,1]^3$ with wall boundary conditions on all surfaces, i.e., $v\\cdot n = 0$. The initial velocity is given by $$ v = (\\sin{(\\pi x)} \\cos{(\\pi y)} \\cos{(\\pi z)}, -\\cos{(\\pi x)}\\sin{(\\pi y)}\\cos{(\\pi z)}, 0) $$ The initial density is given by $\\rho =1$. The initial thermodynamic pressure is given by $$ p = 100 + \\frac{(\\cos{(2\\pi x)} + \\cos{(2\\pi y))(\\cos{(2\\pi z)+2})-2}}{16} $$ The initial energy is related to the pressure and the density by the equation of state for the ideal gas, $p=(\\gamma-1)\\rho e$, with $\\gamma = 5/3$. The initial mesh is a uniform Cartesian hexahedral mesh, which deforms over time. The visualized solution is given on the right. One can reproduce the numerical result, following the command line options described below: offline : ./laghos -o twp_taylor -m ../data/cube01_hex.mesh -p 0 -rs 2 -cfl 0.1 -tf 0.25 -s 7 -pa -offline -visit -romsvds -ef 0.9999 -writesol -romos -rostype load -romsns -nwinsamp 21 -sdim 1000 -sample-stages hyper-reduction preprocessing : ./laghos -o twp_taylor -m ../data/cube01_hex.mesh -p 0 -rs 2 -cfl 0.1 -tf 0.25 -s 7 -pa -online -romsvds -romos -rostype load -romhrprep -romsns -romgs -nwin 82 -sfacv 2 -sface 2 online : ./laghos -o twp_taylor -m ../data/cube01_hex.mesh -p 0 -rs 2 -cfl 0.1 -tf 0.25 -s 7 -pa -online -romsvds -romos -rostype load -romhr -romsns -romgs -nwin 82 -sfacv 2 -sface 2 restore : ./laghos -o twp_taylor -m ../data/cube01_hex.mesh -p 0 -rs 2 -cfl 0.1 -tf 0.25 -s 7 -pa -restore -soldiff -romsvds -romos -rostype load -romsns -romgs -nwin 82 FOM solution time ROM solution time Speed-up Velocity relative error 170 sec 5.4 sec 31.2 1.1e-6 Triple-point problem Triple-point problem is a three-dimensional shock test with two materials in three states. The computational domain is $\\tilde{\\Omega} = [0,7] \\times [0,3 ] \\times [0,1.5]$ with wall boundary conditions on all surfaces, i.e., $v\\cdot n = 0$. The initial velocity is given by $v=0$. The initial density is given by $$\\rho = \\cases{ \\displaystyle 1 & for x $\\leq$ 1 or y $\\leq$ 1.5, \\cr \\displaystyle 1/8 & for x $>$ 1 and y $>$ 1.5 }$$ The initial thermodynamic pressure is given for $$p = \\cases{ \\displaystyle 1 & for x $\\leq$ 1, \\cr \\displaystyle 0.1 & for x $>$ 1 }$$ The initial energy is related to the pressure and the density by the equation of state for the ideal gas, $p=(\\gamma-1)\\rho e$, with $$\\gamma = \\cases{ \\displaystyle 1.5 & for x $\\leq$ 1 or y $>$ 1.5\\cr \\displaystyle 1.4 & for x $>$ 1 and y $\\leq$ 1.5 }$$ The initial mesh is a uniform Cartesian hexahedral mesh, which deforms over time. The visualized solution is given on the right. One can reproduce the numerical result, following the command line options described below: offline : ./laghos -o twp_triple -p 3 -m ../data/box01_hex.mesh -rs 2 -tf 0.8 -s 7 -cfl 0.5 -pa -offline -writesol -visit -romsvds -romos -rostype load -romsns -nwinsamp 21 -ef 0.9999 -sdim 200 -sample-stages hyper-reduction preprocessing : ./laghos -o twp_triple -p 3 -m ../data/box01_hex.mesh -rs 2 -tf 0.8 -s 7 -cfl 0.5 -pa -online -romhrprep -romsvds -romos -rostype load -romgs -romsns -nwin 18 -sfacv 2 -sface 2 online : ./laghos -o twp_triple -p 3 -m ../data/box01_hex.mesh -rs 2 -tf 0.8 -s 7 -cfl 0.5 -pa -online -romhr -romsvds -romos -rostype load -romgs -romsns -nwin 18 -sfacv 2 -sface 2 restore : ./laghos -o twp_triple -p 3 -m ../data/box01_hex.mesh -rs 2 -tf 0.8 -s 7 -cfl 0.5 -pa -restore -soldiff -romsvds -romos -rostype load -romgs -romsns -nwin 18 FOM solution time ROM solution time Speed-up Velocity relative error 122 sec 1.4 sec 87.8 8.1e-4 Rayleigh-Taylor instability problem Rayleigh-Taylor instability problem offline : ./laghos -p 7 -m ../data/rt2D.mesh -tf 1.5 -rs 4 -ok 2 -ot 1 -pa -o twp_rt -s 7 -writesol -offline -romsns -sdim 200000 -romsvds -romos -romgs -nwinsamp 21 -ef 0.9999999999 -sample-stages hyper-reduction preprocessing : ./laghos -p 7 -m ../data/rt2D.mesh -tf 1.5 -rs 4 -ok 2 -ot 1 -pa -o twp_rt -s 7 -online -romsns -romos -romgs -nwin 187 -sfacv 2 -sface 2 -romhrprep online : ./laghos -p 7 -m ../data/rt2D.mesh -tf 1.5 -rs 4 -ok 2 -ot 1 -pa -o twp_rt -s 7 -online -romsns -romos -romgs -nwin 187 -sfacv 2 -sface 2 -romhr restore : ./laghos -p 7 -m ../data/rt2D.mesh -tf 1.5 -rs 4 -ok 2 -ot 1 -pa -o twp_rt -s 7 -restore -romsns -romos -romgs -soldiff -nwin 187 FOM solution time ROM solution time Speed-up Velocity relative error 127 sec 8.7 sec 14.6 7.8e-3 This is an external miniapp, available at https://github.com/CEED/Laghos/tree/rom . No examples or miniapps match your criteria. <!-- function showElement(id, show) { //document.getElementById(id).style.display = show ? \"block\" : \"none\"; // workaround because Doxygen splits and duplicates the divs for some reason var divs = document.getElementsByTagName(\"div\"); for (i = 0; i < divs.length; i++) { if (divs.item(i).id == id) { divs.item(i).style.display = show ? \"block\" : \"none\"; } } return show ? 1 : 0; } function getBooleans(comboId) { combo = document.getElementById(comboId); first_selected = false; for (i = 0; i < combo.options.length; i++) { opt = combo.options[i]; selected = opt.selected || first_selected; if (!i) { first_selected = selected; } // create a boolean variable named after the option this[opt.id] = selected; } } function update() { getBooleans(\"group1\"); getBooleans(\"group2\"); getBooleans(\"group3\"); getBooleans(\"group4\"); numShown = 0 // expression continued... // example codes + showElement(\"poisson\", (diffusion) && (prom) && (global) && (no_hr)) + showElement(\"dg_advection\", (advection) && (dmd) && (reproductive) && (no_hr)) + showElement(\"dg_euler\", (euler) && (dmd) && (reproductive) && (no_hr)) + showElement(\"heat_conduction\", (diffusion) && (dmd) && (reproductive) && (no_hr)) + showElement(\"mixed_nonlinear_diffusion\", (diffusion) && (prom) && (global) && (hr)) + showElement(\"nonlinear_elasticity\", (elasticity) && (dmd) && (reproductive) && (no_hr)) + showElement(\"laghos\", (compressibleflow) && (prom) && (global) && (hr)) ; // ...end of expression // show/hide the message \"No examples match your criteria\" showElement(\"nomatch\", numShown == 0); } function initCombos() { var query = location.search.substr(1); query.split(\"&\").forEach(function(id) { if (id) { opt = document.getElementById(id); if (opt) { opt.selected = true; } } }); } // make sure \"no match\" div is not visible after page is loaded window.onload = update; // force vertical scrollbar document.getElementsByTagName(\"body\")[0].style = \"overflow-y: scroll\" // parse URL part after '?', e.g., http://.../index.html?elasticity&nurbs initCombos(); //-->","title":"Examples"},{"location":"examples.html#example-applications","text":"This page provides a list of libROM example applications. For detailed documentation of the libROM sources, including the examples, see the online Doxygen documentation or the doc directory in the distribution. The goal of the example codes is to provide a step-by-step introduction to libROM in simple model settings. Select from the categories below to display examples and miniapps that contain the respective feature. All examples support (arbitrarily) high-order meshes and finite element spaces . The numerical results from the example codes can be visualized using the GLVis or VisIt visualization tools. See the GLVis and VisIt websites for more details. Users are encouraged to submit any example codes and miniapps that they have created and would like to share. Contact a member of the libROM team to report bugs or post questions or comments .","title":"Example Applications"},{"location":"examples.html#application-pde","text":"All Diffusion Elasticity Euler Advection Compressible flow","title":"**Application (PDE)**"},{"location":"examples.html#reduced-order-models-type","text":"All pROM DMD","title":"**Reduced order models type**"},{"location":"examples.html#parameterization-type","text":"All Trust region Interpolation Global Reproductive","title":"**Parameterization type**"},{"location":"examples.html#hyper-reduction","text":"All Hyper-reduction No hyper-reduction","title":"**hyper-reduction**"},{"location":"examples.html#poisson-problem","text":"This example code demonstrates the use of libROM and MFEM to define a reduced order model for a simple isoparametric finite element discretization of the Poisson problem $$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. The example parameterizes the righthand side with frequency variable, $\\kappa$: $$f = \\cases{ \\displaystyle \\sin(\\kappa (x_0+x_1+x_2)) & for 3D \\cr \\displaystyle \\sin(\\kappa (x_0+x_1)) & for 2D }$$ The 2D solution contour plot for $\\kappa=1$ is shown in the figure on the right to show the effect of $\\kappa$. For demonstration, we sample solutions at $\\kappa=1$, $1.1$, and $1.2$. Then a ROM is build with basis size of 3, which is used to predict the solution for $\\kappa = 1.15$. The ROM is able to achieve a speedup of $7.5$ with a relative error of $6.4\\times10^{-4}$. One can follow the command line options below to reproduce the numerical results summarized in the table below: offline1 : poisson -offline -f 1.0 -id 0 offline2 : poisson -offline -f 1.1 -id 1 offline3 : poisson -offline -f 1.2 -id 2 merge : poisson -merge -ns 3 online : poisson -online -f 1.15 FOM solution time ROM solution time Speed-up Solution relative error 0.22 sec 0.029 sec 7.5 6.4e-4 The code that generates the numerical results above can be found in ( poisson.cpp ) and the explanation of codes is provided in here . The poisson.cpp is based on ex1p.cpp from MFEM with a modification on the right hand side function.","title":"Poisson Problem"},{"location":"examples.html#advection","text":"For a given initial condition, i.e., $u_0(x) = u(0,x)$, DG advection solves the time-dependent advection problem: $$\\frac{\\partial u}{\\partial t} + v\\cdot\\nabla u = 0,$$ where $v$ is a given advection velocity. One can run the following command line options to reproduce the DMD results summarized in the table below: dg_advection -p 3 -rp 1 -dt 0.005 -tf 4 -visit FOM solution time DMD setup time DMD query time DMD relative error 5.2 sec 30.6 sec 1.9e-2 sec 1.9e-4 The code that generates the numerical results above can be found in ( dg_advection.cpp ). The dg_advection.cpp is based on ex9p.cpp from MFEM.","title":"Advection"},{"location":"examples.html#euler-equation","text":"For a given initial condition, i.e., $u_0(x) = u(0,x)$, DG Euler solves the compressible Euler system of equation, i.e., a model nonlinear hyperbolic PDE: $$\\frac{\\partial u}{\\partial t} + \\nabla\\cdot \\boldsymbol{F}(u) = 0,$$ with a state vector $\\boldsymbol{u} = [\\rho,\\rho v_0, \\rho v_1, \\rho E]$, where $\\rho$ is the density, $v_i$ is the velocity in the $i$th direction, $E$ is the total specific energy, and $H = E + p/\\rho$ is the total specific enthalpy. The pressure, $p$ is computed through a simple equation of state (EOS) call. The conservative hydrodynamic flux $\\boldsymbol{F}$ in each direction $i$ is $$\\boldsymbol{F}_i = [\\rho v_i, \\rho v_0 v_i + p \\delta_{i,0}, \\rho v_1 v_{i,1} + p\\delta_{i,1}, \\rho v_i H]$$ One can run the following command line options to reproduce the DMD results summarized in the table below: mpirun -n 8 ./dg_euler -p 2 -rs 2 -rp 1 -o 1 -s 3 -visit DMD rel.error FOM solution time DMD setup time DMD query time $\\rho$ $\\rho v_0$ $\\rho v_1$ $E$ 5.65 sec 38.9 sec 1.4e-3 sec 8.0e-7 1.2e-4 1.6e-3 2.6e-6 The code that generates the numerical results above can be found in ( dg_euler.cpp ). The dg_euler.cpp is based on ex18p.cpp from MFEM.","title":"Euler equation"},{"location":"examples.html#heat-conduction-problem","text":"For a given initial condition, i.e., $u_0(x) = u(0,x)$, heat conduction solves a simple 2D/3D time dependent nonlinear heat conduction problem $$\\frac{\\partial u}{\\partial t} = \\nabla\\cdot (\\kappa + \\alpha u)\\nabla u,$$ with a natural insulating boundary condition $\\frac{du}{dn}=0$. We linearize the problem by using the temperature field $u$ from the previous time step to compute the conductivity coefficient. One can run the following command line options to reproduce the DMD results summarized in the table below: mpirun -np 8 ./heat_conduction -s 3 -a 0.5 -k 0.5 -o 4 -tf 0.7 -vs 1 -visit FOM solution time DMD setup time DMD query time DMD relative error 4.8 sec 0.34 sec 1.4e-3 sec 8.2e-4 The code that generates the numerical results above can be found in ( heat_conduction.cpp ). The heat_conduction.cpp is based on ex16p.cpp from MFEM.","title":"Heat conduction problem"},{"location":"examples.html#mixed-nonlinear-diffusion","text":"For a given initial condition, i.e., $p_0(x) = p(0,x)$, mixed nonlinear diffusion problem solves a simple 2D/3D time dependent nonlinear problem: $$\\frac{\\partial p}{\\partial t} + \\nabla\\cdot \\boldsymbol{v} = f\\,, \\qquad \\nabla p = -a(p)\\boldsymbol{v},$$ with a natural insulating boundary condition $\\frac{\\partial v}{\\partial n}=0$. The $H(div)$-conforming Raviart-Thomas finite element space is used for the velocity function $\\boldsymbol{v}$, and the $L^2$ finite element space is used for pressure function, $p$. This example introduces how the hyper-reduction is implemented and how the reduced bases for two field varibles, $p$ and $\\boldsymbol{v}$. One can run the following command line options to reproduce the DMD results summarized in the table below: offline1 : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -offline -id 0 -sh 0.25 offline2 : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -offline -id 1 -sh 0.15 merge : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -merge -ns 2 offline3 : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -offline -id 2 -sh 0.2 online : ./mixed_nonlinear_diffusion -m ../dependencies/mfem/data/inline-quad.mesh -p 1 -online -rrdim 8 -rwdim 8 -sh 0.2 -id 2 FOM solution time ROM solution time Speed-up Solution relative error 41.68 sec 1.7 sec 24.5 1.6e-3 The code that generates the numerical results above can be found in ( mixed_nonlinear_diffusion.cpp ). The mixed_nonlinear_diffusion.cpp is based on ex16p.cpp from MFEM and modified to support mixed finite element approach.","title":"Mixed nonlinear diffusion"},{"location":"examples.html#nonlinear-elasticity","text":"For a given initial condition, i.e., $v_0(x) = v(0,x)$, nonlinear elasticity solves a time dependent nonlinear elasticity problem of the form $$\\frac{\\partial v}{\\partial t} = H(x) + Sv\\,, \\qquad \\frac{\\partial x}{\\partial t} = v,$$ where $H$ is a hyperelastic model and $S$ is a viscosity operator of Laplacian type. One can run the following command line options to reproduce the DMD results summarized in the table below: mpirun -np 8 ./nonlinear_elasticity -s 2 -rs 1 -dt 0.01 -tf 5 -visit FOM solution time DMD setup time DMD query time Position relative error Velocity relative error 3.7 sec 4.7e-1 sec 6.9e-4 sec 7.0e-5 1.4e-3 The code that generates the numerical results above can be found in ( nonlinear_elasticity.cpp ). The nonlinear_elasticity.cpp is based on ex10p.cpp from MFEM.","title":"Nonlinear elasticity"},{"location":"examples.html#laghos-rom-miniapp","text":"Laghos (LAGrangian High-Order Solver) is a miniapp that solves the time-dependent Euler equations of compressible gas dynamics in a moving Lagrangian frame using unstructured high-order finite element spatial discretization and explicit high-order time-stepping. LaghosROM introduces reduced order models of Laghos simulations. A list of example problems that you can solve with LaghosROM includes Sedov blast, Gresho vortex, Taylor-Green vortex, triple-point, and Rayleigh-Taylor instability problems. Below are command line options for each problems and some numerical results. For each problem, four different phases need to be taken, i.e., the offline, hyper-reduction preprocessing, online, and restore phase. The online phase runs necessary full order model (FOM) to generate simulation data. libROM dynamically collects the data as the FOM simulation marches in time domain. In the hyper-reduction preprocessing phase, the libROM builds a library of reduced basis as well as hyper-reduction operators. The online phase runs the ROM and the restore phase projects the ROM solutions to the full order model dimension.","title":"Laghos ROM Miniapp"},{"location":"examples.html#sedov-blast-problem","text":"Sedov blast problem is a three-dimensional standard shock hydrodynamic benchmark test. An initial delta source of internal energy deposited at the origin of a three-dimensional cube is considered. The computational domain is the unit cube $\\tilde{\\Omega} = [0,1]^3$ with wall boundary conditions on all surfaces, i.e., $v\\cdot n = 0$. The initial velocity is given by $v=0$. The initial density is given by $\\rho = 1$. The initial energy is given by a delta function at the origin. The adiabatic index in the ideal gas equations of state is set $\\gamma = 1.4$. The initial mesh is a uniform Catesian hexahedral mesh, which deforms over time. It can be seen that the radial symmetry is maintained in the shock wave propagation in both FOM and ROM simulations. One can reproduce the numerical result, following the command line options described below: offline : ./laghos -o twp_sedov -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -offline -visit -romsvds -ef 0.9999 -writesol -romos -rostype load -romsns -nwinsamp 21 -sample-stages hyper-reduction preprocessing : ./laghos -o twp_sedov -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -online -romsvds -romos -rostype load -romhrprep -romsns -romgs -nwin 66 -sfacv 2 -sface 2 online : ./laghos -o twp_sedov -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -online -romsvds -romos -rostype load -romhr -romsns -romgs -nwin 66 -sfacv 2 -sface 2 restore : ./laghos -o twp_sedov -m ../data/cube01_hex.mesh -pt 211 -tf 0.8 -s 7 -pa -restore -soldiff -romsvds -romos -rostype load -romsns -romgs -nwin 66 FOM solution time ROM solution time Speed-up Velocity relative error 191 sec 8.3 sec 22.8 2.2e-4","title":"Sedov blast problem"},{"location":"examples.html#gresho-vortex-problem","text":"Gresho vortex problem is a two-dimensional benchmark test for the incompressible inviscid Navier-Stokes equations. The computational domain is the unit square $\\tilde\\Omega = [-0.5,0.5]^2$ with wall boundary conditions on all surfaces, i.e., $v\\dot n = 0$. Let $(r,\\phi)$ denote the polar coordinates of a particle $\\tilde{x} \\in \\tilde{\\Omega}$. The initial angular velocity is given by $$v_\\phi = \\cases{ \\displaystyle 5r & for 0 $\\leq$ r < 0.2 \\cr \\displaystyle 2-5r & for 0.2 $\\leq$ r < 0.4 \\cr \\displaystyle 0 i & for r $\\geq$ 0.4. }$$ The initial density if given by $\\rho=1$. The initial thermodynamic pressure is given by $$p = \\cases{ 5 + \\frac{25}{2} r^2 & for 0 $\\leq$ r < 0.2 \\cr 9 - 4 \\log(0.2) + \\frac{25}{2} - 20r + 4 \\log(r) & for 0.2 $\\leq$ r < 0.4 \\cr 3 + 4\\log(2) & for r $\\geq$ 0.4 }$$ offline : ./laghos -o twp_gresho -p 4 -m ../data/square_gresho.mesh -rs 4 -ok 3 -ot 2 -tf 0.62 -s 7 -visit -writesol -offline -ef 0.9999 -romsvds -romos -rostype load -romsns -nwinsamp 21 -sample-stages hyper-reduction preprocessing : ./laghos -o twp_gresho -p 4 -m ../data/square_gresho.mesh -rs 4 -ok 3 -ot 2 -tf 0.62 -s 7 -online -romhrprep -romsvds -romos -rostype load -romsns -romgs -nwin 152 -sfacv 2 -sface 2 online : ./laghos -o twp_gresho -p 4 -m ../data/square_gresho.mesh -rs 4 -ok 3 -ot 2 -tf 0.62 -s 7 -online -romhr -romsvds -romos -rostype load -romsns -romgs -nwin 152 -sfacv 2 -sface 2 restore : ./laghos -o twp_gresho -p 4 -m ../data/square_gresho.mesh -rs 4 -ok 3 -ot 2 -tf 0.62 -s 7 -soldiff -restore -romsvds -romos -rostype load -romsns -romgs -nwin 152 FOM solution time ROM solution time Speed-up Velocity relative error 218 sec 8.4 sec 25.9 2.1e-4","title":"Gresho vortex problem"},{"location":"examples.html#taylor-green-vortex","text":"Taylor-Green vortex problem is a three-dimensional benchmark test for the incompressible Navier-Stokes equasions. A manufactured smooth solution is considered by extending the steady state Taylor-Green vortex solution to the compressible Euler equations. The computational domain is the unit cube $\\tilde{\\Omega}=[0,1]^3$ with wall boundary conditions on all surfaces, i.e., $v\\cdot n = 0$. The initial velocity is given by $$ v = (\\sin{(\\pi x)} \\cos{(\\pi y)} \\cos{(\\pi z)}, -\\cos{(\\pi x)}\\sin{(\\pi y)}\\cos{(\\pi z)}, 0) $$ The initial density is given by $\\rho =1$. The initial thermodynamic pressure is given by $$ p = 100 + \\frac{(\\cos{(2\\pi x)} + \\cos{(2\\pi y))(\\cos{(2\\pi z)+2})-2}}{16} $$ The initial energy is related to the pressure and the density by the equation of state for the ideal gas, $p=(\\gamma-1)\\rho e$, with $\\gamma = 5/3$. The initial mesh is a uniform Cartesian hexahedral mesh, which deforms over time. The visualized solution is given on the right. One can reproduce the numerical result, following the command line options described below: offline : ./laghos -o twp_taylor -m ../data/cube01_hex.mesh -p 0 -rs 2 -cfl 0.1 -tf 0.25 -s 7 -pa -offline -visit -romsvds -ef 0.9999 -writesol -romos -rostype load -romsns -nwinsamp 21 -sdim 1000 -sample-stages hyper-reduction preprocessing : ./laghos -o twp_taylor -m ../data/cube01_hex.mesh -p 0 -rs 2 -cfl 0.1 -tf 0.25 -s 7 -pa -online -romsvds -romos -rostype load -romhrprep -romsns -romgs -nwin 82 -sfacv 2 -sface 2 online : ./laghos -o twp_taylor -m ../data/cube01_hex.mesh -p 0 -rs 2 -cfl 0.1 -tf 0.25 -s 7 -pa -online -romsvds -romos -rostype load -romhr -romsns -romgs -nwin 82 -sfacv 2 -sface 2 restore : ./laghos -o twp_taylor -m ../data/cube01_hex.mesh -p 0 -rs 2 -cfl 0.1 -tf 0.25 -s 7 -pa -restore -soldiff -romsvds -romos -rostype load -romsns -romgs -nwin 82 FOM solution time ROM solution time Speed-up Velocity relative error 170 sec 5.4 sec 31.2 1.1e-6","title":"Taylor-Green vortex"},{"location":"examples.html#triple-point-problem","text":"Triple-point problem is a three-dimensional shock test with two materials in three states. The computational domain is $\\tilde{\\Omega} = [0,7] \\times [0,3 ] \\times [0,1.5]$ with wall boundary conditions on all surfaces, i.e., $v\\cdot n = 0$. The initial velocity is given by $v=0$. The initial density is given by $$\\rho = \\cases{ \\displaystyle 1 & for x $\\leq$ 1 or y $\\leq$ 1.5, \\cr \\displaystyle 1/8 & for x $>$ 1 and y $>$ 1.5 }$$ The initial thermodynamic pressure is given for $$p = \\cases{ \\displaystyle 1 & for x $\\leq$ 1, \\cr \\displaystyle 0.1 & for x $>$ 1 }$$ The initial energy is related to the pressure and the density by the equation of state for the ideal gas, $p=(\\gamma-1)\\rho e$, with $$\\gamma = \\cases{ \\displaystyle 1.5 & for x $\\leq$ 1 or y $>$ 1.5\\cr \\displaystyle 1.4 & for x $>$ 1 and y $\\leq$ 1.5 }$$ The initial mesh is a uniform Cartesian hexahedral mesh, which deforms over time. The visualized solution is given on the right. One can reproduce the numerical result, following the command line options described below: offline : ./laghos -o twp_triple -p 3 -m ../data/box01_hex.mesh -rs 2 -tf 0.8 -s 7 -cfl 0.5 -pa -offline -writesol -visit -romsvds -romos -rostype load -romsns -nwinsamp 21 -ef 0.9999 -sdim 200 -sample-stages hyper-reduction preprocessing : ./laghos -o twp_triple -p 3 -m ../data/box01_hex.mesh -rs 2 -tf 0.8 -s 7 -cfl 0.5 -pa -online -romhrprep -romsvds -romos -rostype load -romgs -romsns -nwin 18 -sfacv 2 -sface 2 online : ./laghos -o twp_triple -p 3 -m ../data/box01_hex.mesh -rs 2 -tf 0.8 -s 7 -cfl 0.5 -pa -online -romhr -romsvds -romos -rostype load -romgs -romsns -nwin 18 -sfacv 2 -sface 2 restore : ./laghos -o twp_triple -p 3 -m ../data/box01_hex.mesh -rs 2 -tf 0.8 -s 7 -cfl 0.5 -pa -restore -soldiff -romsvds -romos -rostype load -romgs -romsns -nwin 18 FOM solution time ROM solution time Speed-up Velocity relative error 122 sec 1.4 sec 87.8 8.1e-4","title":"Triple-point problem"},{"location":"examples.html#rayleigh-taylor-instability-problem","text":"Rayleigh-Taylor instability problem offline : ./laghos -p 7 -m ../data/rt2D.mesh -tf 1.5 -rs 4 -ok 2 -ot 1 -pa -o twp_rt -s 7 -writesol -offline -romsns -sdim 200000 -romsvds -romos -romgs -nwinsamp 21 -ef 0.9999999999 -sample-stages hyper-reduction preprocessing : ./laghos -p 7 -m ../data/rt2D.mesh -tf 1.5 -rs 4 -ok 2 -ot 1 -pa -o twp_rt -s 7 -online -romsns -romos -romgs -nwin 187 -sfacv 2 -sface 2 -romhrprep online : ./laghos -p 7 -m ../data/rt2D.mesh -tf 1.5 -rs 4 -ok 2 -ot 1 -pa -o twp_rt -s 7 -online -romsns -romos -romgs -nwin 187 -sfacv 2 -sface 2 -romhr restore : ./laghos -p 7 -m ../data/rt2D.mesh -tf 1.5 -rs 4 -ok 2 -ot 1 -pa -o twp_rt -s 7 -restore -romsns -romos -romgs -soldiff -nwin 187 FOM solution time ROM solution time Speed-up Velocity relative error 127 sec 8.7 sec 14.6 7.8e-3 This is an external miniapp, available at https://github.com/CEED/Laghos/tree/rom . No examples or miniapps match your criteria. <!-- function showElement(id, show) { //document.getElementById(id).style.display = show ? \"block\" : \"none\"; // workaround because Doxygen splits and duplicates the divs for some reason var divs = document.getElementsByTagName(\"div\"); for (i = 0; i < divs.length; i++) { if (divs.item(i).id == id) { divs.item(i).style.display = show ? \"block\" : \"none\"; } } return show ? 1 : 0; } function getBooleans(comboId) { combo = document.getElementById(comboId); first_selected = false; for (i = 0; i < combo.options.length; i++) { opt = combo.options[i]; selected = opt.selected || first_selected; if (!i) { first_selected = selected; } // create a boolean variable named after the option this[opt.id] = selected; } } function update() { getBooleans(\"group1\"); getBooleans(\"group2\"); getBooleans(\"group3\"); getBooleans(\"group4\"); numShown = 0 // expression continued... // example codes + showElement(\"poisson\", (diffusion) && (prom) && (global) && (no_hr)) + showElement(\"dg_advection\", (advection) && (dmd) && (reproductive) && (no_hr)) + showElement(\"dg_euler\", (euler) && (dmd) && (reproductive) && (no_hr)) + showElement(\"heat_conduction\", (diffusion) && (dmd) && (reproductive) && (no_hr)) + showElement(\"mixed_nonlinear_diffusion\", (diffusion) && (prom) && (global) && (hr)) + showElement(\"nonlinear_elasticity\", (elasticity) && (dmd) && (reproductive) && (no_hr)) + showElement(\"laghos\", (compressibleflow) && (prom) && (global) && (hr)) ; // ...end of expression // show/hide the message \"No examples match your criteria\" showElement(\"nomatch\", numShown == 0); } function initCombos() { var query = location.search.substr(1); query.split(\"&\").forEach(function(id) { if (id) { opt = document.getElementById(id); if (opt) { opt.selected = true; } } }); } // make sure \"no match\" div is not visible after page is loaded window.onload = update; // force vertical scrollbar document.getElementsByTagName(\"body\")[0].style = \"overflow-y: scroll\" // parse URL part after '?', e.g., http://.../index.html?elasticity&nurbs initCombos(); //-->","title":"Rayleigh-Taylor instability problem"},{"location":"examples_mfem.html","text":"MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}}); Example Codes and Miniapps This page provides a brief overview of MFEM's example codes and miniapps. For detailed documentation of the MFEM sources, including the examples, see the online Doxygen documentation , or the doc directory in the distribution. The goal of the example codes is to provide a step-by-step introduction to MFEM in simple model settings. The miniapps are more complex, and are intended to be more representative of the advanced usage of the library in physics/application codes. We recommend that new users start with the example codes before moving to the miniapps. Select from the categories below to display examples and miniapps that contain the respective feature. All examples support (arbitrarily) high-order meshes and finite element spaces . The numerical results from the example codes can be visualized using the GLVis visualization tool (based on MFEM). See the GLVis website for more details. Users are encouraged to submit any example codes and miniapps that they have created and would like to share. Contact a member of the MFEM team to report bugs or post questions or comments . **Application (PDE)** All Diffusion Elasticity Electromagnetics grad-div Darcy Advection Conduction Wave Compressible flow Incompressible flow Meshing **Finite Elements** All H1 nodal elements L2 discontinuous elements H(curl) Nedelec elements H(div) Raviart-Thomas elements H^{-1/2} interfacial elements **Discretization** All Galerkin FEM Mixed FEM Discontinuous Galerkin (DG) Discont. Petrov-Galerkin (DPG) Hybridization Static condensation Isogeometric analysis (NURBS) Adaptive mesh refinement (AMR) Partial assembly **Solver** All Jacobi Gauss-Seidel PCG MINRES GMRES Algebraic Multigrid (BoomerAMG) Auxiliary-space Maxwell Solver (AMS) Auxiliary-space Divergence Solver (ADS) SuperLU/STRUMPACK (parallel direct) UMFPACK (serial direct) Newton method (nonlinear solver) Explicit Runge-Kutta (ODE integration) Implicit Runge-Kutta (ODE integration) Newmark (ODE Integration) Symplectic Algorithm (ODE Integration) LOBPCG, AME (eigensolvers) SUNDIALS solvers PETSc solvers SLEPc eigensolvers HiOp solvers Example 1: Laplace Problem This example code demonstrates the use of MFEM to define a simple isoparametric finite element discretization of the Laplace problem $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary conditions. Specifically, we discretize with the finite element space coming from the mesh (linear by default, quadratic for quadratic curvilinear mesh, NURBS for NURBS mesh, etc.) The example highlights the use of mesh refinement, finite element grid functions, as well as linear and bilinear forms corresponding to the left-hand side and right-hand side of the discrete linear system. We also cover the explicit elimination of essential boundary conditions, static condensation, and the optional connection to the GLVis tool for visualization. The example has a serial ( ex1.cpp ), a parallel ( ex1p.cpp ), and HPC versions: performance/ex1.cpp , performance/ex1p.cpp . It also has a PETSc modification in examples/petsc , a PUMI modification in examples/pumi and a Ginkgo modification in examples/ginkgo . Example 2: Linear Elasticity This example code solves a simple linear elasticity problem describing a multi-material cantilever beam. Specifically, we approximate the weak form of $$-{\\rm div}({\\sigma}({\\bf u})) = 0$$ where $${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$ is the stress tensor corresponding to displacement field ${\\bf u}$, and $\\lambda$ and $\\mu$ are the material Lame constants. The boundary conditions are ${\\bf u}=0$ on the fixed part of the boundary with attribute 1, and ${\\sigma}({\\bf u})\\cdot n = f$ on the remainder with $f$ being a constant pull down vector on boundary elements with attribute 2, and zero otherwise. The geometry of the domain is assumed to be as follows: The example demonstrates the use of high-order and NURBS vector finite element spaces with the linear elasticity bilinear form, meshes with curved elements, and the definition of piece-wise constant and vector coefficient objects. Static condensation is also illustrated. The example has a serial ( ex2.cpp ) and a parallel ( ex2p.cpp ) version. It also has a PETSc modification in examples/petsc and a PUMI modification in examples/pumi . We recommend viewing Example 1 before viewing this example. Example 3: Definite Maxwell Problem This example code solves a simple 3D electromagnetic diffusion problem corresponding to the second order definite Maxwell equation $$\\nabla\\times\\nabla\\times\\, E + E = f$$ with boundary condition $ E \\times n $ = \"given tangential field\". Here, we use a given exact solution $E$ and compute the corresponding r.h.s. $f$. We discretize with Nedelec finite elements in 2D or 3D. The example demonstrates the use of $H(curl)$ finite element spaces with the curl-curl and the (vector finite element) mass bilinear form, as well as the computation of discretization error when the exact solution is known. Static condensation is also illustrated. The example has a serial ( ex3.cpp ) and a parallel ( ex3p.cpp ) version. It also has a PETSc modification in examples/petsc . Partial assembly and GPU devices are supported. We recommend viewing examples 1-2 before viewing this example. Example 4: Grad-div Problem This example code solves a simple 2D/3D $H(div)$ diffusion problem corresponding to the second order definite equation $$-{\\rm grad}(\\alpha\\,{\\rm div}(F)) + \\beta F = f$$ with boundary condition $F \\cdot n$ = \"given normal field\". Here we use a given exact solution $F$ and compute the corresponding right hand side $f$. We discretize with the Raviart-Thomas finite elements. The example demonstrates the use of $H(div)$ finite element spaces with the grad-div and $H(div)$ vector finite element mass bilinear form, as well as the computation of discretization error when the exact solution is known. Bilinear form hybridization and static condensation are also illustrated. The example has a serial ( ex4.cpp ) and a parallel ( ex4p.cpp ) version. It also has a PETSc modification in examples/petsc . Partial assembly and GPU devices are supported. We recommend viewing examples 1-3 before viewing this example. Example 5: Darcy Problem This example code solves a simple 2D/3D mixed Darcy problem corresponding to the saddle point system $$ \\begin{array}{rcl} k\\,{\\bf u} + {\\rm grad}\\,p &=& f \\\\ -{\\rm div}\\,{\\bf u} &=& g \\end{array} $$ with natural boundary condition $-p = $ \"given pressure\". Here we use a given exact solution $({\\bf u},p)$ and compute the corresponding right hand side $(f, g)$. We discretize with Raviart-Thomas finite elements (velocity $\\bf u$) and piecewise discontinuous polynomials (pressure $p$). The example demonstrates the use of the BlockMatrix and BlockOperator classes, as well as the collective saving of several grid functions in VisIt and ParaView formats. The example has a serial ( ex5.cpp ) and a parallel ( ex5p.cpp ) version. It also has a PETSc modification in examples/petsc . Partial assembly is supported. We recommend viewing examples 1-4 before viewing this example. Example 6: Laplace Problem with AMR This is a version of Example 1 with a simple adaptive mesh refinement loop. The problem being solved is again the Laplace equation $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary conditions. The problem is solved on a sequence of meshes which are locally refined in a conforming (triangles, tetrahedrons) or non-conforming (quadrilaterals, hexahedra) manner according to a simple ZZ error estimator. The example demonstrates MFEM's capability to work with both conforming and nonconforming refinements, in 2D and 3D, on linear, curved and surface meshes. Interpolation of functions from coarse to fine meshes, as well as persistent GLVis visualization are also illustrated. The example has a serial ( ex6.cpp ) and a parallel ( ex6p.cpp ) version. It also has a PETSc modification in examples/petsc and a PUMI modification in examples/pumi . Partial assembly and GPU devices are supported. We recommend viewing Example 1 before viewing this example. Example 7: Surface Meshes This example code demonstrates the use of MFEM to define a triangulation of a unit sphere and a simple isoparametric finite element discretization of the Laplace problem with mass term, $$-\\Delta u + u = f.$$ The example highlights mesh generation, the use of mesh refinement, high-order meshes and finite elements, as well as surface-based linear and bilinear forms corresponding to the left-hand side and right-hand side of the discrete linear system. Simple local mesh refinement is also demonstrated. The example has a serial ( ex7.cpp ) and a parallel ( ex7p.cpp ) version. We recommend viewing Example 1 before viewing this example. Example 8: DPG for the Laplace Problem This example code demonstrates the use of the Discontinuous Petrov-Galerkin (DPG) method in its primal 2x2 block form as a simple finite element discretization of the Laplace problem $$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. We use high-order continuous trial space, a high-order interfacial (trace) space, and a high-order discontinuous test space defining a local dual ($H^{-1}$) norm. We use the primal form of DPG, see \"A primal DPG method without a first-order reformulation\" , Demkowicz and Gopalakrishnan, CAM 2013. The example highlights the use of interfacial (trace) finite elements and spaces, trace face integrators and the definition of block operators and preconditioners. The example has a serial ( ex8.cpp ) and a parallel ( ex8p.cpp ) version. We recommend viewing examples 1-5 before viewing this example. Example 9: DG Advection This example code solves the time-dependent advection equation $$\\frac{\\partial u}{\\partial t} + v \\cdot \\nabla u = 0,$$ where $v$ is a given fluid velocity, and $u_0(x)=u(0,x)$ is a given initial condition. The example demonstrates the use of Discontinuous Galerkin (DG) bilinear forms in MFEM (face integrators), the use of explicit and implicit (with block ILU preconditioning) ODE time integrators, the definition of periodic boundary conditions through periodic meshes, as well as the use of GLVis for persistent visualization of a time-evolving solution. The saving of time-dependent data files for external visualization with VisIt and ParaView is also illustrated. The example has a serial ( ex9.cpp ) and a parallel ( ex9p.cpp ) version. It also has a SUNDIALS modification in examples/sundials , a PETSc modification in examples/petsc , and a HiOp modification in examples/hiop . Example 10: Nonlinear Elasticity This example solves a time dependent nonlinear elasticity problem of the form $$ \\frac{dv}{dt} = H(x) + S v\\,,\\qquad \\frac{dx}{dt} = v\\,, $$ where $H$ is a hyperelastic model and $S$ is a viscosity operator of Laplacian type. The geometry of the domain is assumed to be as follows: The example demonstrates the use of nonlinear operators, as well as their implicit time integration using a Newton method for solving an associated reduced backward-Euler type nonlinear equation. Each Newton step requires the inversion of a Jacobian matrix, which is done through a (preconditioned) inner solver. The example has a serial ( ex10.cpp ) and a parallel ( ex10p.cpp ) version. It also has a SUNDIALS modification in examples/sundials and a PETSc modification in examples/petsc . We recommend viewing examples 2 and 9 before viewing this example. Example 11: Laplace Eigenproblem This example code demonstrates the use of MFEM to solve the eigenvalue problem $$-\\Delta u = \\lambda u$$ with homogeneous Dirichlet boundary conditions. We compute a number of the lowest eigenmodes by discretizing the Laplacian and Mass operators using a finite element space of the specified order, or an isoparametric/isogeometric space if order < 1 (quadratic for quadratic curvilinear mesh, NURBS for NURBS mesh, etc.) The example highlights the use of the LOBPCG eigenvalue solver together with the BoomerAMG preconditioner in HYPRE, as well as optionally the SuperLU or STRUMPACK parallel direct solvers. Reusing a single GLVis visualization window for multiple eigenfunctions is also illustrated. The example has only a parallel ( ex11p.cpp ) version. It also has a SLEPc modification in examples/petsc . We recommend viewing Example 1 before viewing this example. Example 12: Linear Elasticity Eigenproblem This example code solves the linear elasticity eigenvalue problem for a multi-material cantilever beam. Specifically, we compute a number of the lowest eigenmodes by approximating the weak form of $$-{\\rm div}({\\sigma}({\\bf u})) = \\lambda {\\bf u} \\,,$$ where $${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$ is the stress tensor corresponding to displacement field $\\bf u$, and $\\lambda$ and $\\mu$ are the material Lame constants. The boundary conditions are ${\\bf u}=0$ on the fixed part of the boundary with attribute 1, and ${\\sigma}({\\bf u})\\cdot n = f$ on the remainder. The geometry of the domain is assumed to be as follows: The example highlights the use of the LOBPCG eigenvalue solver together with the BoomerAMG preconditioner in HYPRE. Reusing a single GLVis visualization window for multiple eigenfunctions is also illustrated. The example has only a parallel ( ex12p.cpp ) version. We recommend viewing examples 2 and 11 before viewing this example. Example 13: Maxwell Eigenproblem This example code solves the Maxwell (electromagnetic) eigenvalue problem $$\\nabla\\times\\nabla\\times\\, E = \\lambda\\, E $$ with homogeneous Dirichlet boundary conditions $E \\times n = 0$. We compute a number of the lowest nonzero eigenmodes by discretizing the curl curl operator using a Nedelec finite element space of the specified order in 2D or 3D. The example highlights the use of the AME subspace eigenvalue solver from HYPRE, which uses LOBPCG and AMS internally. Reusing a single GLVis visualization window for multiple eigenfunctions is also illustrated. The example has only a parallel ( ex13p.cpp ) version. We recommend viewing examples 3 and 11 before viewing this example. Example 14: DG Diffusion This example code demonstrates the use of MFEM to define a discontinuous Galerkin (DG) finite element discretization of the Laplace problem $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary conditions. Finite element spaces of any order, including zero on regular grids, are supported. The example highlights the use of discontinuous spaces and DG-specific face integrators. The example has a serial ( ex14.cpp ) and a parallel ( ex14p.cpp ) version. We recommend viewing examples 1 and 9 before viewing this example. Example 15: Dynamic AMR Building on Example 6 , this example demonstrates dynamic adaptive mesh refinement. The mesh is adapted to a time-dependent solution by refinement as well as by derefinement. For simplicity, the solution is prescribed and no time integration is done. However, the error estimation and refinement/derefinement decisions are realistic. At each outer iteration the right hand side function is changed to mimic a time dependent problem. Within each inner iteration the problem is solved on a sequence of meshes which are locally refined according to a simple ZZ error estimator. At the end of the inner iteration the error estimates are also used to identify any elements which may be over-refined and a single derefinement step is performed. After each refinement or derefinement step a rebalance operation is performed to keep the mesh evenly distributed among the available processors. The example demonstrates MFEM's capability to refine, derefine and load balance nonconforming meshes, in 2D and 3D, and on linear, curved and surface meshes. Interpolation of functions between coarse and fine meshes, persistent GLVis visualization, and saving of time-dependent fields for external visualization with VisIt are also illustrated. The example has a serial ( ex15.cpp ) and a parallel ( ex15p.cpp ) version. We recommend viewing examples 1, 6 and 9 before viewing this example. Example 16: Time Dependent Heat Conduction This example code solves a simple 2D/3D time dependent nonlinear heat conduction problem $$\\frac{du}{dt} = \\nabla \\cdot \\left( \\kappa + \\alpha u \\right) \\nabla u$$ with a natural insulating boundary condition $\\frac{du}{dn} = 0$. We linearize the problem by using the temperature field $u$ from the previous time step to compute the conductivity coefficient. This example demonstrates both implicit and explicit time integration as well as a single Picard step method for linearization. The saving of time dependent data files for external visualization with VisIt is also illustrated. The example has a serial ( ex16.cpp ) and a parallel ( ex16p.cpp ) version. We recommend viewing examples 2, 9, and 10 before viewing this example. Example 17: DG Linear Elasticity This example code solves a simple linear elasticity problem describing a multi-material cantilever beam using symmetric or non-symmetric discontinuous Galerkin (DG) formulation. Specifically, we approximate the weak form of $$-{\\rm div}({\\sigma}({\\bf u})) = 0$$ where $${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$ is the stress tensor corresponding to displacement field ${\\bf u}$, and $\\lambda$ and $\\mu$ are the material Lame constants. The boundary conditions are Dirichlet, $\\bf{u}=\\bf{u_D}$, on the fixed part of the boundary, namely boundary attributes 1 and 2; on the rest of the boundary we use ${\\sigma}({\\bf u})\\cdot n = {\\bf 0}$. The geometry of the domain is assumed to be as follows: The example demonstrates the use of high-order DG vector finite element spaces with the linear DG elasticity bilinear form, meshes with curved elements, and the definition of piece-wise constant and function vector-coefficient objects. The use of non-homogeneous Dirichlet b.c. imposed weakly, is also illustrated. The example has a serial ( ex17.cpp ) and a parallel ( ex17p.cpp ) version. We recommend viewing examples 2 and 14 before viewing this example. Example 18: DG Euler Equations This example code solves the compressible Euler system of equations, a model nonlinear hyperbolic PDE, with a discontinuous Galerkin (DG) formulation. The primary purpose is to show how a transient system of nonlinear equations can be formulated in MFEM. The equations are solved in conservative form $$\\frac{\\partial u}{\\partial t} + \\nabla \\cdot {\\bf F}(u) = 0$$ with a state vector $u = [ \\rho, \\rho v_0, \\rho v_1, \\rho E ]$, where $\\rho$ is the density, $v_i$ is the velocity in the $i^{\\rm th}$ direction, $E$ is the total specific energy, and $H = E + p / \\rho$ is the total specific enthalpy. The pressure, $p$ is computed through a simple equation of state (EOS) call. The conservative hydrodynamic flux ${\\bf F}$ in each direction $i$ is $${\\bf F_{\\it i}} = [ \\rho v_i, \\rho v_0 v_i + p \\delta_{i,0}, \\rho v_1 v_i + p \\delta_{i,1}, \\rho v_i H ]$$ Specifically, the example solves for an exact solution of the equations whereby a vortex is transported by a uniform flow. Since all boundaries are periodic here, the method's accuracy can be assessed by measuring the difference between the solution and the initial condition at a later time when the vortex returns to its initial location. Note that as the order of the spatial discretization increases, the timestep must become smaller. This example currently uses a simple estimate derived by Cockburn and Shu for the 1D RKDG method. An additional factor can be tuned by passing the --cfl (or -c shorter) flag. The example demonstrates user-defined bilinear and nonlinear form integrators for systems of equations that are defined with block vectors, and how these are used with an operator for explicit time integrators. In this case the system also involves an external approximate Riemann solver for the DG interface flux. It also demonstrates how to use GLVis for in-situ visualization of vector grid functions. The example has a serial ( ex18.cpp ) and a parallel ( ex18p.cpp ) version. We recommend viewing examples 9, 14 and 17 before viewing this example. Example 19: Incompressible Nonlinear Elasticity This example code solves the quasi-static incompressible nonlinear hyperelasticity equations. Specifically, it solves the nonlinear equation $$ \\nabla \\cdot \\sigma(F) = 0 $$ subject to the constraint $$ \\text{det } F = 1 $$ where $\\sigma$ is the Cauchy stress and $F_{ij} = \\delta_{ij} + u_{i,j}$ is the deformation gradient. To handle the incompressibility constraint, pressure is included as an independent unknown $p$ and the stress response is modeled as an incompressible neo-Hookean hyperelastic solid . The geometry of the domain is assumed to be as follows: This formulation requires solving the saddle point system $$ \\left[ \\begin{array}{cc} K &B^T \\\\ B & 0 \\end{array} \\right] \\left[\\begin{array}{c} \\Delta u \\\\ \\Delta p \\end{array} \\right] = \\left[\\begin{array}{c} R_u \\\\ R_p \\end{array} \\right] $$ at each Newton step. To solve this linear system, we implement a specialized block preconditioner of the form $$ P^{-1} = \\left[\\begin{array}{cc} I & -\\tilde{K}^{-1}B^T \\\\ 0 & I \\end{array} \\right] \\left[\\begin{array}{cc} \\tilde{K}^{-1} & 0 \\\\ 0 & -\\gamma \\tilde{S}^{-1} \\end{array} \\right] $$ where $\\tilde{K}^{-1}$ is an approximation of the inverse of the stiffness matrix $K$ and $\\tilde{S}^{-1}$ is an approximation of the inverse of the Schur complement $S = BK^{-1}B^T$. To approximate the Schur complement, we use the mass matrix for the pressure variable $p$. The example demonstrates how to solve nonlinear systems of equations that are defined with block vectors as well as how to implement specialized block preconditioners for use in iterative solvers. The example has a serial ( ex19.cpp ) and a parallel ( ex19p.cpp ) version. We recommend viewing examples 2, 5 and 10 before viewing this example. Example 20: Symplectic Integration of Hamiltonian Systems This example demonstrates the use of the variable order, symplectic time integration algorithm. Symplectic integration algorithms are designed to conserve energy when integrating systems of ODEs which are derived from Hamiltonian systems. Hamiltonian systems define the energy of a system as a function of time (t), a set of generalized coordinates (q), and their corresponding generalized momenta (p). $$ H(q,p,t) = T(p) + V(q,t) $$ Hamilton's equations then specify how q and p evolve in time: $$ \\frac{dq}{dt} = \\frac{dH}{dp}\\,,\\qquad \\frac{dp}{dt} = -\\frac{dH}{dq} $$ To use the symplectic integration classes we need to define an mfem::Operator ${\\bf P}$ which evaluates the action of dH/dp, and an mfem::TimeDependentOperator ${\\bf F}$ which computes -dH/dq. This example visualizes its results as an evolution in phase space by defining the axes to be $q$, $p$, and $t$ rather than $x$, $y$, and $z$. In this space we build a ribbon-like mesh with nodes at $(0,0,t)$ and $(q,p,t)$. Finally we plot the energy as a function of time as a scalar field on this ribbon-like mesh. This scheme highlights any variations in the energy of the system. This example offers five simple 1D Hamiltonians: Simple Harmonic Oscillator (mass on a spring) $$H = \\frac{1}{2}\\left( \\frac{p^2}{m} + \\frac{q^2}{k} \\right)$$ Pendulum $$H = \\frac{1}{2}\\left[ \\frac{p^2}{m} - k \\left( 1 - cos(q) \\right) \\right]$$ Gaussian Potential Well $$H = \\frac{p^2}{2m} - k e^{-q^2 / 2}$$ Quartic Potential $$H = \\frac{1}{2}\\left[ \\frac{p^2}{m} + k \\left( 1 + q^2 \\right) q^2 \\right]$$ Negative Quartic Potential $$H = \\frac{1}{2}\\left[ \\frac{p^2}{m} + k \\left( 1 - \\frac{q^2}{8} \\right) q^2 \\right]$$ In all cases these Hamiltonians are shifted by constant values so that the energy will remain positive. The mean and standard deviation of the computed energies at each time step are displayed upon completion. When run in parallel, each processor integrates the same Hamiltonian system but starting from different initial conditions. The example has a serial ( ex20.cpp ) and a parallel ( ex20p.cpp ) version. See the Maxwell miniapp for another application of symplectic integration. Example 21: Adaptive mesh refinement for linear elasticity This is a version of Example 2 with a simple adaptive mesh refinement loop. The problem being solved is again linear elasticity describing a multi-material cantilever beam. The problem is solved on a sequence of meshes which are locally refined in a conforming (triangles, tetrahedrons) or non-conforming (quadrilaterals, hexahedra) manner according to a simple ZZ error estimator. The example demonstrates MFEM's capability to work with both conforming and nonconforming refinements, in 2D and 3D, on linear and curved meshes. Interpolation of functions from coarse to fine meshes, as well as persistent GLVis visualization are also illustrated. The example has a serial ( ex21.cpp ) and a parallel ( ex21p.cpp ) version. We recommend viewing Examples 2 and 6 before viewing this example. Example 22: Complex Linear Systems This example code demonstrates the use of MFEM to define and solve a complex-valued linear system. It implements three variants of a damped harmonic oscillator: A scalar $H^1$ field: $$-\\nabla\\cdot\\left(a \\nabla u\\right) - \\omega^2 b\\,u + i\\,\\omega\\,c\\,u = 0$$ A vector $H(curl)$ field: $$\\nabla\\times\\left(a\\nabla\\times\\vec{u}\\right) - \\omega^2 b\\,\\vec{u} + i\\,\\omega\\,c\\,\\vec{u} = 0$$ A vector $H(div)$ field: $$-\\nabla\\left(a \\nabla\\cdot\\vec{u}\\right) - \\omega^2 b\\,\\vec{u} + i\\,\\omega\\,c\\,\\vec{u} = 0$$ In each case the field is driven by a forced oscillation, with angular frequency $\\omega$, imposed at the boundary or a portion of the boundary. The example also demonstrates how to display a time-varying solution as a sequence of fields sent to a single GLVis socket. The example has a serial ( ex22.cpp ) and a parallel ( ex22p.cpp ) version. We recommend viewing examples 1, 3, and 4 before viewing this example. Example 23: Wave Problem This example code solves a simple 2D/3D wave equation with a second order time derivative: $$\\frac{\\partial^2 u}{\\partial t^2} - c^2\\Delta u = 0$$ The boundary conditions are either Dirichlet or Neumann. The example demonstrates the use of time dependent operators, implicit solvers and second order time integration. The example has only a serial ( ex23.cpp ) version. We recommend viewing examples 9 and 10 before viewing this example. Example 24: Mixed finite element spaces This example code illustrates usage of mixed finite element spaces, with three variants: $H^1 \\times H(curl)$ $H(curl) \\times H(div)$ $H(div) \\times L_2$ Using different approaches for demonstration purposes, we project or interpolate a gradient, curl, or divergence in the appropriate spaces, comparing the errors in each case. Partial assembly and GPU devices are supported. The example has a serial ( ex24.cpp ) and a parallel ( ex24p.cpp ) version. We recommend viewing examples 1 and 3 before viewing this example. Example 25: Perfectly Matched Layers The example illustrates the use of a Perfectly Matched Layer (PML) for the simulation of time-harmonic electromagnetic waves propagating in unbounded domains. PML was originally introduced by Berenger in \"A Perfectly Matched Layer for the Absorption of Electromagnetic Waves\" . It is a technique used to solve wave propagation problems posed in infinite domains. The implementation involves the introduction of an artificial absorbing layer that minimizes undesired reflections. Inside this layer a complex coordinate stretching map is used which forces the wave modes to decay exponentially. The example solves the indefinite Maxwell equations $$\\nabla \\times (a \\nabla \\times E) - \\omega^2 b E = f.$$ where $a = \\mu^{-1} |J|^{-1} J^T J$, $b= \\epsilon |J| J^{-1} J^{-T}$ and $J$ is the Jacobian matrix of the coordinate transformation. The example demonstrates discretization with Nedelec finite elements in 2D or 3D, as well as the use of complex-valued bilinear and linear forms. Several test problems are included, with known exact solutions. The example has a serial ( ex25.cpp ) and a parallel ( ex25p.cpp ) version. We recommend viewing Example 22 before viewing this example. Example 26: Multigrid Preconditioner This example code demonstrates the use of MFEM to define a simple isoparametric finite element discretization of the Laplace problem $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary conditions and how to solve it efficiently using a matrix-free multigrid preconditioner. The example highlights on the creation of a hierarchy of discretization spaces and diffusion bilinear forms using partial assembly. The levels in the hierarchy of finite element spaces maybe constructed through geometric or order refinements. Moreover, the construction of a multigrid preconditioner for the PCG solver is shown. The multigrid uses a PCG solver on the coarsest level and second order Chebyshev accelerated smoothers on the other levels. The example has a serial ( ex26.cpp ) and a parallel ( ex26p.cpp ) version. We recommend viewing Example 1 before viewing this example. Example 27: Laplace Boundary Conditions This example code demonstrates the use of MFEM to define a simple finite element discretization of the Laplace problem: $$ -\\Delta u = 0 $$ with a variety of boundary conditions. Specifically, we discretize using a FE space of the specified order using a continuous or discontinuous space. We then apply Dirichlet, Neumann (both homogeneous and inhomogeneous), Robin, and Periodic boundary conditions on different portions of a predefined mesh. Boundary conditions: $u = u_{dbc}$ on $\\Gamma_{dbc}$ $\\hat{n}\\cdot\\nabla u = g_{nbc}$ on $\\Gamma_{nbc}$ $\\hat{n}\\cdot\\nabla u = 0$ on $\\Gamma_{nbc_0}$ $\\hat{n}\\cdot\\nabla u + a u = b$ on $\\Gamma_{rbc}$ as well as periodic boundary conditions which are enforced topologically. The example has a serial ( ex27.cpp ) and a parallel ( ex27p.cpp ) version. We recommend viewing examples 1 and 14 before viewing this example. Volta Miniapp: Electrostatics This miniapp demonstrates the use of MFEM to solve realistic problems in the field of linear electrostatics. Its features include: dielectric materials charge densities surface charge densities prescribed voltages applied polarizations high order meshes high order basis functions adaptive mesh refinement advanced visualization For more details, please see the documentation in the miniapps/electromagnetics directory. The miniapp has only a parallel ( volta.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Tesla Miniapp: Magnetostatics This miniapp showcases many of MFEM's features while solving a variety of realistic magnetostatics problems. Its features include: diamagnetic and/or paramagnetic materials ferromagnetic materials volumetric current densities surface current densities external fields high order meshes high order basis functions adaptive mesh refinement advanced visualization For more details, please see the documentation in the miniapps/electromagnetics directory. The miniapp has only a parallel ( tesla.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Maxwell Miniapp: Transient Full-Wave Electromagnetics This miniapp solves the equations of transient full-wave electromagnetics. Its features include: mixed formulation of the coupled first-order Maxwell equations $H(\\mathrm{curl})$ discretization of the electric field $H(\\mathrm{div})$ discretization of the magnetic flux energy conserving, variable order, implicit time integration dielectric materials diamagnetic and/or paramagnetic materials conductive materials volumetric current densities Sommerfeld absorbing boundary conditions high order meshes high order basis functions advanced visualization For more details, please see the documentation in the miniapps/electromagnetics directory. The miniapp has only a parallel ( maxwell.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Joule Miniapp: Transient Magnetics and Joule Heating This miniapp solves the equations of transient low-frequency (a.k.a. eddy current) electromagnetics, and simultaneously computes transient heat transfer with the heat source given by the electromagnetic Joule heating. Its features include: $H^1$ discretization of the electrostatic potential $H(\\mathrm{curl})$ discretization of the electric field $H(\\mathrm{div})$ discretization of the magnetic field $H(\\mathrm{div})$ discretization of the heat flux $L^2$ discretization of the temperature implicit transient time integration high order meshes high order basis functions adaptive mesh refinement advanced visualization For more details, please see the documentation in the miniapps/electromagnetics directory. The miniapp has only a parallel ( joule.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Mobius Strip Miniapp This miniapp generates various Mobius strip-like surface meshes. It is a good way to generate complex surface meshes. Manipulating the mesh topology and performing mesh transformation are demonstrated. The mobius-strip mesh in the data directory was generated with this miniapp. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( mobius-strip.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Klein Bottle Miniapp This miniapp generates three types of Klein bottle surfaces. It is similar to the mobius-strip miniapp. Manipulating the mesh topology and performing mesh transformation are demonstrated. The klein-bottle and klein-donut meshes in the data directory were generated with this miniapp. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( klein-bottle.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Toroid Miniapp This miniapp generates two types of toroidal volume meshes; one with triangular cross sections and one with square cross sections. It works by defining a stack of individual elements and bending them so that the bottom and top of the stack can be joined to form a torus. It supports various options including: The element type: 0 - Wedge, 1 - Hexahedron The geometric order of the elements The major and minor radii The number of elements in the azimuthal direction The number of nodes to offset by before rejoining the stack The initial angle of the cross sectional shape The number of uniform refinement steps to apply Along with producing some visually interesting meshes, this miniapp demonstrates how simple 3D meshes can be constructed and transformed in MFEM. It also produces a family of meshes with simple but non-trivial topology for testing various features in MFEM. This miniapp has only a serial ( toroid.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Twist Miniapp This miniapp generates simple periodic meshes to demonstrate MFEM's handling of periodic domains. MFEM's strategy is to use a discontinuous vector field to define the mesh coordinates on a topologically periodic mesh. It works by defining a stack of individual elements and stitching together the top and bottom of the mesh. The stack can also be twisted so that the vertices of the bottom and top can be joined with any integer offset (for tetrahedral and wedge meshes only even offsets are supported). The Twist miniapp supports various options including: The element type: 4 - Tetrahedron, 6 - Wedge, 8 - Hexahedron The geometric order of the elements The dimensions of the initial brick-shaped stack of elements The number of elements in the z direction The number of nodes to offset by before rejoining the stack The number of uniform refinement steps to apply Along with producing some visually interesting meshes, this miniapp demonstrates how simple 3D meshes can be constructed and transformed in MFEM. It also produces a family of meshes with simple but non-trivial topology for testing various features in MFEM. This miniapp has only a serial ( twist.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Extruder Miniapp This miniapp creates higher dimensional meshes from lower dimensional meshes by extrusion. Simple coordinate transformations can also be applied if desired. The initial mesh can be 1D or 2D 1D meshes can be extruded in both the y and z directions 2D meshes can be triangular, quadrilateral, or contain both element types Meshes with high order geometry are supported User can specify the number of elements and the distance to extrude Geometric order of the transformed mesh can be user selected or automatic This miniapp provides another demonstration of how simple meshes can be constructed and transformed in MFEM. This miniapp has only a serial ( extruder.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Polar-NC Miniapp This miniapp generates a circular sector mesh that consist of quadrilaterals and triangles of similar sizes. The 3D version of the mesh is made of prisms and tetrahedra. The mesh is non-conforming by design, and can optionally be made curvilinear. The elements are ordered along a space-filling curve by default, which makes the mesh ready for parallel non-conforming AMR in MFEM. The implementation also demonstrates how to initialize a non-conforming mesh on the fly by marking hanging nodes with Mesh::AddVertexParents . For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( polar-nc.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Shaper Miniapp This miniapp performs multiple levels of adaptive mesh refinement to resolve the interfaces between different \"materials\" in the mesh, as specified by a given material function. It can be used as a simple initial mesh generator, for example in the case when the interface is too complex to describe without local refinement. Both conforming and non-conforming refinements are supported. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( shaper.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Mesh Explorer Miniapp This miniapp is a handy tool to examine, visualize and manipulate a given mesh. Some of its features are: visualizing of mesh materials and individual mesh elements mesh scaling, randomization, and general transformation manipulation of the mesh curvature the ability to simulate parallel partitioning quantitative and visual reports of mesh quality For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( mesh-explorer.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Mesh Optimizer Miniapp This miniapp performs mesh optimization using the Target-Matrix Optimization Paradigm (TMOP) by P.Knupp et al., and a global variational minimization approach. It minimizes the quantity $$\\sum_T \\int_T \\mu(J(x)),$$ where $T$ are the target (ideal) elements, $J$ is the Jacobian of the transformation from the target to the physical element, and $\\mu$ is the mesh quality metric. This metric can measure shape, size or alignment of the region around each quadrature point. The combination of targets and quality metrics is used to optimize the physical node positions, i.e., they must be as close as possible to the shape / size / alignment of their targets. This code also demonstrates a possible use of nonlinear operators, as well as their coupling to Newton methods for solving minimization problems. Note that the utilized Newton methods are oriented towards avoiding invalid meshes with negative Jacobian determinants. Each Newton step requires the inversion of a Jacobian matrix, which is done through an inner linear solver. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has a serial ( mesh-optimizer.cpp ) and a parallel ( pmesh-optimizer.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Minimal Surface Miniapp This miniapp solves Plateau's problem: the Dirichlet problem for the minimal surface equation. Options to solve the minimal surface equations of both parametric surfaces as well as surfaces restricted to be graphs of the form $z=f(x,y)$ are supported, including a number of examples such as the Catenoid, Helicoid, Costa and Schrek surfaces. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has a serial ( minimal-surface.cpp ) and a parallel ( pminimal-surface.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Low-Order Refined Transfer Miniapp The lor-transfer miniapp, found under miniapps/tools demonstrates the capability to generate a low-order refined mesh from a high-order mesh, and to transfer solutions between these meshes. Grid functions can be transferred between the coarse, high-order mesh and the low-order refined mesh using either $L^2$ projection or pointwise evaluation. These transfer operators can be designed to discretely conserve mass and to recover the original high-order solution when transferring a low-order grid function that was obtained by restricting a high-order grid function to the low-order refined space. The miniapp has only a serial ( lor-transfer.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. Interpolation Miniapps The interpolation miniapp, found under miniapps/gslib , demonstrate the capability to interpolate high-order finite element functions at given set of points in physical space. These miniapps utilize the gslib library's high-order interpolation utility for quad and hex meshes: Find Points miniapp has a serial ( findpts.cpp ) and a parallel ( pfindpts.cpp ) version that demonstrate the basic procedures for point search and evaluation of grid functions. Field Interp miniapp ( field-interp.cpp ) demonstrates how grid functions can be transferred between meshes. Field Diff miniapp ( field-diff.cpp ) demonstrates how grid functions on two different meshes can be compared with each other. These miniapps require installation of the gslib library. We recommend that new users start with the example codes before moving to the miniapps. Laghos Miniapp Laghos (LAGrangian High-Order Solver) is a miniapp that solves the time-dependent Euler equations of compressible gas dynamics in a moving Lagrangian frame using unstructured high-order finite element spatial discretization and explicit high-order time-stepping. The computational motives captured in Laghos include: Support for unstructured meshes, in 2D and 3D, with quadrilateral and hexahedral elements (triangular and tetrahedral elements can also be used, but with the less efficient full assembly option). Serial and parallel mesh refinement options can be set via a command-line flag. Explicit time-stepping loop with a variety of time integrator options. Laghos supports Runge-Kutta ODE solvers of orders 1, 2, 3, 4 and 6. Continuous and discontinuous high-order finite element discretization spaces of runtime-specified order. Moving (high-order) meshes. Separation between the assembly and the quadrature point-based computations. Point-wise definition of mesh size, time-step estimate and artificial viscosity coefficient. Constant-in-time velocity mass operator that is inverted iteratively on each time step. This is an example of an operator that is prepared once (fully or partially assembled), but is applied many times. The application cost is dominant for this operator. Time-dependent force matrix that is prepared every time step (fully or partially assembled) and is applied just twice per \"assembly\". Both the preparation and the application costs are important for this operator. Domain-decomposed MPI parallelism. Optional in-situ visualization with GLVis and data output for visualization / data analysis with VisIt . The Laghos miniapp is part of the CEED software suite , a collection of software benchmarks, miniapps, libraries and APIs for efficient exascale discretizations based on high-order finite element and spectral element methods. See http://github.com/ceed for more information and source code availability. This is an external miniapp, available at https://github.com/CEED/Laghos . Remhos Miniapp Remhos (REMap High-Order Solver) is a miniapp that solves the pure advection equations that are used to perform monotonic and conservative discontinuous field interpolation (remap) as part of the Eulerian phase in Arbitrary Lagrangian Eulerian (ALE) simulations. The computational motives captured in Remhos include: Support for unstructured meshes, in 2D and 3D, with quadrilateral and hexahedral elements. Serial and parallel mesh refinement options can be set via a command-line flag. Explicit time-stepping loop with a variety of time integrator options. Remhos supports Runge-Kutta ODE solvers of orders 1, 2, 3, 4 and 6. Discontinuous high-order finite element discretization spaces of runtime-specified order. Moving (high-order) meshes. Mass operator that is local per each zone. It is inverted by iterative or exact methods at each time step. This operator is constant in time (transport mode) or changing in time (remap mode). Options for full or partial assembly. Advection operator that couples neighboring zones. It is applied once at each time step. This operator is constant in time (transport mode) or changing in time (remap mode). Options for full or partial assembly. Domain-decomposed MPI parallelism. Optional in-situ visualization with GLVis and data output for visualization and data analysis with VisIt . The Remhos miniapp is part of the CEED software suite , a collection of software benchmarks, miniapps, libraries and APIs for efficient exascale discretizations based on high-order finite element and spectral element methods. See http://github.com/ceed for more information and source code availability. This is an external miniapp, available at https://github.com/CEED/Remhos . Navier Miniapp Navier is a miniapp that solves the time-dependent Navier-Stokes equations of incompressible fluid dynamics \\begin{align} \\frac{\\partial u}{\\partial t} + (u \\cdot \\nabla) u - \\frac{1}{Re} \\nabla^2 u - \\nabla p &= f \\\\ \\nabla \\cdot u &= 0 \\end{align} using a spatially high-order finite element discretization. The time-dependent problem is solved using a (up to) third order implicit-explicit method which leverages an extrapolation scheme for the convective parts and a backward-difference formulation for the viscous parts of the equation. The miniapp supports: Arbitrary order H1 elements High order mesh elements IMEX (EXTk-BDFk) time-stepping up to third order Convenient interface for new users A variety of test cases and benchmarks This miniapp has only a parallel ( navier_solver.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. No examples or miniapps match your criteria. <!-- function showElement(id, show) { //document.getElementById(id).style.display = show ? \"block\" : \"none\"; // workaround because Doxygen splits and duplicates the divs for some reason var divs = document.getElementsByTagName(\"div\"); for (i = 0; i < divs.length; i++) { if (divs.item(i).id == id) { divs.item(i).style.display = show ? \"block\" : \"none\"; } } return show ? 1 : 0; } function getBooleans(comboId) { combo = document.getElementById(comboId); first_selected = false; for (i = 0; i < combo.options.length; i++) { opt = combo.options[i]; selected = opt.selected || first_selected; if (!i) { first_selected = selected; } // create a boolean variable named after the option this[opt.id] = selected; } } function update() { getBooleans(\"group1\"); getBooleans(\"group2\"); getBooleans(\"group3\"); getBooleans(\"group4\"); numShown = 0 // expression continued... // example codes + showElement(\"ex1\", (diffusion) && h1 && (galerkin || nurbs || staticcond || pa) && (gs || pcg || umfpack || amg || petsc)) + showElement(\"ex2\", elasticity && h1 && (galerkin || nurbs || staticcond) && (gs || pcg || umfpack || amg || petsc)) + showElement(\"ex3\", (maxwell) && hcurl && (galerkin || staticcond || pa) && (gs || pcg || umfpack || ams || petsc)) + showElement(\"ex4\", graddiv && (hdiv || h12) && (galerkin || hybr || staticcond || pa) && (gs || pcg || umfpack || amg || ads || ams || petsc)) + showElement(\"ex5\", darcy && (l2 || hdiv) && (mixed || pa) && (gs || jacobi || minres || umfpack || amg || petsc)) + showElement(\"ex6\", (diffusion) && h1 && (galerkin || nurbs || amr || pa) && (gs || pcg || umfpack || amg || petsc)) + showElement(\"ex7\", (diffusion || meshing) && h1 && (galerkin || amr) && (gs || pcg || umfpack || amg)) + showElement(\"ex8\", diffusion && (l2 || h1 || h12) && dpg && (gs || pcg || umfpack || amg || ads || ams)) + showElement(\"ex9\", (advection) && l2 && (dg || pa) && (pcg || rk || sundials || petsc || hiop || gmres || sdirk)) + showElement(\"ex10\", elasticity && (l2 || h1) && galerkin && (jacobi || pcg || minres || umfpack || newton || rk || sdirk || sundials || petsc)) + showElement(\"ex11\", diffusion && h1 && (galerkin || nurbs) && (lobpcg || amg || superlu || slepc)) + showElement(\"ex12\", elasticity && h1 && (galerkin || nurbs) && (lobpcg || amg)) + showElement(\"ex13\", maxwell && hcurl && galerkin && (lobpcg || ams)) + showElement(\"ex14\", diffusion && l2 && dg && (gs || pcg || gmres || umfpack || amg)) + showElement(\"ex15\", diffusion && h1 && (galerkin || nurbs || amr) && (gs || pcg || umfpack || amg)) + showElement(\"ex16\", conduction && h1 && galerkin && (pcg || jacobi || rk || sdirk || sundials)) + showElement(\"ex17\", elasticity && l2 && dg && (gs || pcg || gmres || umfpack || amg)) + showElement(\"ex18\", compressibleflow && l2 && dg && (rk)) + showElement(\"ex19\", elasticity && h1 && mixed && (gs || gmres || newton || amg)) + showElement(\"ex20\", (elasticity || maxwell || conduction || compressibleflow) && h1 && mixed && symplectic) + showElement(\"ex21\", elasticity && h1 && (galerkin || amr) && (gs || pcg || umfpack || amg)) + showElement(\"ex22\", (diffusion || maxwell || graddiv) && (h1 || hcurl || hdiv) && galerkin && (gmres || amg || ams || ads)) + showElement(\"ex23\", (diffusion || wave) && h1 && (galerkin || nurbs) && newmark) + showElement(\"ex24\", (graddiv) && (h1 || hcurl) && (galerkin || pa) && pcg) + showElement(\"ex25\", (maxwell || wave) && hcurl && galerkin && (gmres || ams)) + showElement(\"ex26\", diffusion && h1 && (galerkin || pa) && (jacobi || pcg || amg)) + showElement(\"ex27\", (elasticity || maxwell || conduction || compressibleflow) && (h1 || l2) && (galerkin || dg) && (gs || pcg || gmres || amg || umfpack)) // electromagnetic miniapps + showElement(\"volta\", maxwell && (l2 || hdiv) && (galerkin || amr) && (pcg || amg)) + showElement(\"tesla\", maxwell && (hdiv || hcurl) && (galerkin || amr) && (pcg || amg || ams)) + showElement(\"maxwell\", (maxwell || conduction || wave) && (hdiv || hcurl) && (galerkin || staticcond || mixed) && (pcg || symplectic)) + showElement(\"joule\", (maxwell || conduction) && (l2 || h1 || hdiv || hcurl) && (galerkin || amr || staticcond) && (pcg || amg || ams || ads || sdirk)) // meshing miniapps + showElement(\"mobius-strip\", meshing && all2 && all3 && all4) + showElement(\"klein-bottle\", meshing && all2 && all3 && all4) + showElement(\"toroid\", meshing && all2 && all3 && all4) + showElement(\"twist\", meshing && all2 && all3 && all4) + showElement(\"extruder\", meshing && all2 && all3 && all4) + showElement(\"polar-nc\", meshing && all2 && all3 && all4) + showElement(\"shaper\", meshing && all2 && all3 && all4) + showElement(\"mesh-explorer\", meshing && all2 && all3 && all4) + showElement(\"mesh-optimizer\", meshing && all2 && all3 && all4) + showElement(\"minimal-surface\", meshing && all2 && (galerkin || amr || pa) && all4) + showElement(\"lor-transfer\", meshing && (l2 || h1) && all3 && all4) + showElement(\"gslib-interpolation\", meshing && all2 && all3 && all4) // external miniapps + showElement(\"laghos\", (compressibleflow) && (l2 || h1) && (galerkin || dg || pa) && (rk)) + showElement(\"remhos\", (advection) && (l2) && (galerkin || dg || pa) && (rk)) + showElement(\"navier\", (incompressibleflow) && (h1) && (galerkin || pa) && (gmres || pcg || amg)) ; // ...end of expression // show/hide the message \"No examples match your criteria\" showElement(\"nomatch\", numShown == 0); } function initCombos() { var query = location.search.substr(1); query.split(\"&\").forEach(function(id) { if (id) { opt = document.getElementById(id); if (opt) { opt.selected = true; } } }); } // make sure \"no match\" div is not visible after page is loaded window.onload = update; // force vertical scrollbar document.getElementsByTagName(\"body\")[0].style = \"overflow-y: scroll\" // parse URL part after '?', e.g., http://.../index.html?elasticity&nurbs initCombos(); //-->","title":"Examples mfem"},{"location":"examples_mfem.html#example-codes-and-miniapps","text":"This page provides a brief overview of MFEM's example codes and miniapps. For detailed documentation of the MFEM sources, including the examples, see the online Doxygen documentation , or the doc directory in the distribution. The goal of the example codes is to provide a step-by-step introduction to MFEM in simple model settings. The miniapps are more complex, and are intended to be more representative of the advanced usage of the library in physics/application codes. We recommend that new users start with the example codes before moving to the miniapps. Select from the categories below to display examples and miniapps that contain the respective feature. All examples support (arbitrarily) high-order meshes and finite element spaces . The numerical results from the example codes can be visualized using the GLVis visualization tool (based on MFEM). See the GLVis website for more details. Users are encouraged to submit any example codes and miniapps that they have created and would like to share. Contact a member of the MFEM team to report bugs or post questions or comments .","title":"Example Codes and Miniapps"},{"location":"examples_mfem.html#application-pde","text":"All Diffusion Elasticity Electromagnetics grad-div Darcy Advection Conduction Wave Compressible flow Incompressible flow Meshing","title":"**Application (PDE)**"},{"location":"examples_mfem.html#finite-elements","text":"All H1 nodal elements L2 discontinuous elements H(curl) Nedelec elements H(div) Raviart-Thomas elements H^{-1/2} interfacial elements","title":"**Finite Elements**"},{"location":"examples_mfem.html#discretization","text":"All Galerkin FEM Mixed FEM Discontinuous Galerkin (DG) Discont. Petrov-Galerkin (DPG) Hybridization Static condensation Isogeometric analysis (NURBS) Adaptive mesh refinement (AMR) Partial assembly","title":"**Discretization**"},{"location":"examples_mfem.html#solver","text":"All Jacobi Gauss-Seidel PCG MINRES GMRES Algebraic Multigrid (BoomerAMG) Auxiliary-space Maxwell Solver (AMS) Auxiliary-space Divergence Solver (ADS) SuperLU/STRUMPACK (parallel direct) UMFPACK (serial direct) Newton method (nonlinear solver) Explicit Runge-Kutta (ODE integration) Implicit Runge-Kutta (ODE integration) Newmark (ODE Integration) Symplectic Algorithm (ODE Integration) LOBPCG, AME (eigensolvers) SUNDIALS solvers PETSc solvers SLEPc eigensolvers HiOp solvers","title":"**Solver**"},{"location":"examples_mfem.html#example-1-laplace-problem","text":"This example code demonstrates the use of MFEM to define a simple isoparametric finite element discretization of the Laplace problem $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary conditions. Specifically, we discretize with the finite element space coming from the mesh (linear by default, quadratic for quadratic curvilinear mesh, NURBS for NURBS mesh, etc.) The example highlights the use of mesh refinement, finite element grid functions, as well as linear and bilinear forms corresponding to the left-hand side and right-hand side of the discrete linear system. We also cover the explicit elimination of essential boundary conditions, static condensation, and the optional connection to the GLVis tool for visualization. The example has a serial ( ex1.cpp ), a parallel ( ex1p.cpp ), and HPC versions: performance/ex1.cpp , performance/ex1p.cpp . It also has a PETSc modification in examples/petsc , a PUMI modification in examples/pumi and a Ginkgo modification in examples/ginkgo .","title":"Example 1: Laplace Problem"},{"location":"examples_mfem.html#example-2-linear-elasticity","text":"This example code solves a simple linear elasticity problem describing a multi-material cantilever beam. Specifically, we approximate the weak form of $$-{\\rm div}({\\sigma}({\\bf u})) = 0$$ where $${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$ is the stress tensor corresponding to displacement field ${\\bf u}$, and $\\lambda$ and $\\mu$ are the material Lame constants. The boundary conditions are ${\\bf u}=0$ on the fixed part of the boundary with attribute 1, and ${\\sigma}({\\bf u})\\cdot n = f$ on the remainder with $f$ being a constant pull down vector on boundary elements with attribute 2, and zero otherwise. The geometry of the domain is assumed to be as follows: The example demonstrates the use of high-order and NURBS vector finite element spaces with the linear elasticity bilinear form, meshes with curved elements, and the definition of piece-wise constant and vector coefficient objects. Static condensation is also illustrated. The example has a serial ( ex2.cpp ) and a parallel ( ex2p.cpp ) version. It also has a PETSc modification in examples/petsc and a PUMI modification in examples/pumi . We recommend viewing Example 1 before viewing this example.","title":"Example 2: Linear Elasticity"},{"location":"examples_mfem.html#example-3-definite-maxwell-problem","text":"This example code solves a simple 3D electromagnetic diffusion problem corresponding to the second order definite Maxwell equation $$\\nabla\\times\\nabla\\times\\, E + E = f$$ with boundary condition $ E \\times n $ = \"given tangential field\". Here, we use a given exact solution $E$ and compute the corresponding r.h.s. $f$. We discretize with Nedelec finite elements in 2D or 3D. The example demonstrates the use of $H(curl)$ finite element spaces with the curl-curl and the (vector finite element) mass bilinear form, as well as the computation of discretization error when the exact solution is known. Static condensation is also illustrated. The example has a serial ( ex3.cpp ) and a parallel ( ex3p.cpp ) version. It also has a PETSc modification in examples/petsc . Partial assembly and GPU devices are supported. We recommend viewing examples 1-2 before viewing this example.","title":"Example 3: Definite Maxwell Problem"},{"location":"examples_mfem.html#example-4-grad-div-problem","text":"This example code solves a simple 2D/3D $H(div)$ diffusion problem corresponding to the second order definite equation $$-{\\rm grad}(\\alpha\\,{\\rm div}(F)) + \\beta F = f$$ with boundary condition $F \\cdot n$ = \"given normal field\". Here we use a given exact solution $F$ and compute the corresponding right hand side $f$. We discretize with the Raviart-Thomas finite elements. The example demonstrates the use of $H(div)$ finite element spaces with the grad-div and $H(div)$ vector finite element mass bilinear form, as well as the computation of discretization error when the exact solution is known. Bilinear form hybridization and static condensation are also illustrated. The example has a serial ( ex4.cpp ) and a parallel ( ex4p.cpp ) version. It also has a PETSc modification in examples/petsc . Partial assembly and GPU devices are supported. We recommend viewing examples 1-3 before viewing this example.","title":"Example 4: Grad-div Problem"},{"location":"examples_mfem.html#example-5-darcy-problem","text":"This example code solves a simple 2D/3D mixed Darcy problem corresponding to the saddle point system $$ \\begin{array}{rcl} k\\,{\\bf u} + {\\rm grad}\\,p &=& f \\\\ -{\\rm div}\\,{\\bf u} &=& g \\end{array} $$ with natural boundary condition $-p = $ \"given pressure\". Here we use a given exact solution $({\\bf u},p)$ and compute the corresponding right hand side $(f, g)$. We discretize with Raviart-Thomas finite elements (velocity $\\bf u$) and piecewise discontinuous polynomials (pressure $p$). The example demonstrates the use of the BlockMatrix and BlockOperator classes, as well as the collective saving of several grid functions in VisIt and ParaView formats. The example has a serial ( ex5.cpp ) and a parallel ( ex5p.cpp ) version. It also has a PETSc modification in examples/petsc . Partial assembly is supported. We recommend viewing examples 1-4 before viewing this example.","title":"Example 5: Darcy Problem"},{"location":"examples_mfem.html#example-6-laplace-problem-with-amr","text":"This is a version of Example 1 with a simple adaptive mesh refinement loop. The problem being solved is again the Laplace equation $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary conditions. The problem is solved on a sequence of meshes which are locally refined in a conforming (triangles, tetrahedrons) or non-conforming (quadrilaterals, hexahedra) manner according to a simple ZZ error estimator. The example demonstrates MFEM's capability to work with both conforming and nonconforming refinements, in 2D and 3D, on linear, curved and surface meshes. Interpolation of functions from coarse to fine meshes, as well as persistent GLVis visualization are also illustrated. The example has a serial ( ex6.cpp ) and a parallel ( ex6p.cpp ) version. It also has a PETSc modification in examples/petsc and a PUMI modification in examples/pumi . Partial assembly and GPU devices are supported. We recommend viewing Example 1 before viewing this example.","title":"Example 6: Laplace Problem with AMR"},{"location":"examples_mfem.html#example-7-surface-meshes","text":"This example code demonstrates the use of MFEM to define a triangulation of a unit sphere and a simple isoparametric finite element discretization of the Laplace problem with mass term, $$-\\Delta u + u = f.$$ The example highlights mesh generation, the use of mesh refinement, high-order meshes and finite elements, as well as surface-based linear and bilinear forms corresponding to the left-hand side and right-hand side of the discrete linear system. Simple local mesh refinement is also demonstrated. The example has a serial ( ex7.cpp ) and a parallel ( ex7p.cpp ) version. We recommend viewing Example 1 before viewing this example.","title":"Example 7: Surface Meshes"},{"location":"examples_mfem.html#example-8-dpg-for-the-laplace-problem","text":"This example code demonstrates the use of the Discontinuous Petrov-Galerkin (DPG) method in its primal 2x2 block form as a simple finite element discretization of the Laplace problem $$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. We use high-order continuous trial space, a high-order interfacial (trace) space, and a high-order discontinuous test space defining a local dual ($H^{-1}$) norm. We use the primal form of DPG, see \"A primal DPG method without a first-order reformulation\" , Demkowicz and Gopalakrishnan, CAM 2013. The example highlights the use of interfacial (trace) finite elements and spaces, trace face integrators and the definition of block operators and preconditioners. The example has a serial ( ex8.cpp ) and a parallel ( ex8p.cpp ) version. We recommend viewing examples 1-5 before viewing this example.","title":"Example 8: DPG for the Laplace Problem"},{"location":"examples_mfem.html#example-9-dg-advection","text":"This example code solves the time-dependent advection equation $$\\frac{\\partial u}{\\partial t} + v \\cdot \\nabla u = 0,$$ where $v$ is a given fluid velocity, and $u_0(x)=u(0,x)$ is a given initial condition. The example demonstrates the use of Discontinuous Galerkin (DG) bilinear forms in MFEM (face integrators), the use of explicit and implicit (with block ILU preconditioning) ODE time integrators, the definition of periodic boundary conditions through periodic meshes, as well as the use of GLVis for persistent visualization of a time-evolving solution. The saving of time-dependent data files for external visualization with VisIt and ParaView is also illustrated. The example has a serial ( ex9.cpp ) and a parallel ( ex9p.cpp ) version. It also has a SUNDIALS modification in examples/sundials , a PETSc modification in examples/petsc , and a HiOp modification in examples/hiop .","title":"Example 9: DG Advection"},{"location":"examples_mfem.html#example-10-nonlinear-elasticity","text":"This example solves a time dependent nonlinear elasticity problem of the form $$ \\frac{dv}{dt} = H(x) + S v\\,,\\qquad \\frac{dx}{dt} = v\\,, $$ where $H$ is a hyperelastic model and $S$ is a viscosity operator of Laplacian type. The geometry of the domain is assumed to be as follows: The example demonstrates the use of nonlinear operators, as well as their implicit time integration using a Newton method for solving an associated reduced backward-Euler type nonlinear equation. Each Newton step requires the inversion of a Jacobian matrix, which is done through a (preconditioned) inner solver. The example has a serial ( ex10.cpp ) and a parallel ( ex10p.cpp ) version. It also has a SUNDIALS modification in examples/sundials and a PETSc modification in examples/petsc . We recommend viewing examples 2 and 9 before viewing this example.","title":"Example 10: Nonlinear Elasticity"},{"location":"examples_mfem.html#example-11-laplace-eigenproblem","text":"This example code demonstrates the use of MFEM to solve the eigenvalue problem $$-\\Delta u = \\lambda u$$ with homogeneous Dirichlet boundary conditions. We compute a number of the lowest eigenmodes by discretizing the Laplacian and Mass operators using a finite element space of the specified order, or an isoparametric/isogeometric space if order < 1 (quadratic for quadratic curvilinear mesh, NURBS for NURBS mesh, etc.) The example highlights the use of the LOBPCG eigenvalue solver together with the BoomerAMG preconditioner in HYPRE, as well as optionally the SuperLU or STRUMPACK parallel direct solvers. Reusing a single GLVis visualization window for multiple eigenfunctions is also illustrated. The example has only a parallel ( ex11p.cpp ) version. It also has a SLEPc modification in examples/petsc . We recommend viewing Example 1 before viewing this example.","title":"Example 11: Laplace Eigenproblem"},{"location":"examples_mfem.html#example-12-linear-elasticity-eigenproblem","text":"This example code solves the linear elasticity eigenvalue problem for a multi-material cantilever beam. Specifically, we compute a number of the lowest eigenmodes by approximating the weak form of $$-{\\rm div}({\\sigma}({\\bf u})) = \\lambda {\\bf u} \\,,$$ where $${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$ is the stress tensor corresponding to displacement field $\\bf u$, and $\\lambda$ and $\\mu$ are the material Lame constants. The boundary conditions are ${\\bf u}=0$ on the fixed part of the boundary with attribute 1, and ${\\sigma}({\\bf u})\\cdot n = f$ on the remainder. The geometry of the domain is assumed to be as follows: The example highlights the use of the LOBPCG eigenvalue solver together with the BoomerAMG preconditioner in HYPRE. Reusing a single GLVis visualization window for multiple eigenfunctions is also illustrated. The example has only a parallel ( ex12p.cpp ) version. We recommend viewing examples 2 and 11 before viewing this example.","title":"Example 12: Linear Elasticity Eigenproblem"},{"location":"examples_mfem.html#example-13-maxwell-eigenproblem","text":"This example code solves the Maxwell (electromagnetic) eigenvalue problem $$\\nabla\\times\\nabla\\times\\, E = \\lambda\\, E $$ with homogeneous Dirichlet boundary conditions $E \\times n = 0$. We compute a number of the lowest nonzero eigenmodes by discretizing the curl curl operator using a Nedelec finite element space of the specified order in 2D or 3D. The example highlights the use of the AME subspace eigenvalue solver from HYPRE, which uses LOBPCG and AMS internally. Reusing a single GLVis visualization window for multiple eigenfunctions is also illustrated. The example has only a parallel ( ex13p.cpp ) version. We recommend viewing examples 3 and 11 before viewing this example.","title":"Example 13: Maxwell Eigenproblem"},{"location":"examples_mfem.html#example-14-dg-diffusion","text":"This example code demonstrates the use of MFEM to define a discontinuous Galerkin (DG) finite element discretization of the Laplace problem $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary conditions. Finite element spaces of any order, including zero on regular grids, are supported. The example highlights the use of discontinuous spaces and DG-specific face integrators. The example has a serial ( ex14.cpp ) and a parallel ( ex14p.cpp ) version. We recommend viewing examples 1 and 9 before viewing this example.","title":"Example 14: DG Diffusion"},{"location":"examples_mfem.html#example-15-dynamic-amr","text":"Building on Example 6 , this example demonstrates dynamic adaptive mesh refinement. The mesh is adapted to a time-dependent solution by refinement as well as by derefinement. For simplicity, the solution is prescribed and no time integration is done. However, the error estimation and refinement/derefinement decisions are realistic. At each outer iteration the right hand side function is changed to mimic a time dependent problem. Within each inner iteration the problem is solved on a sequence of meshes which are locally refined according to a simple ZZ error estimator. At the end of the inner iteration the error estimates are also used to identify any elements which may be over-refined and a single derefinement step is performed. After each refinement or derefinement step a rebalance operation is performed to keep the mesh evenly distributed among the available processors. The example demonstrates MFEM's capability to refine, derefine and load balance nonconforming meshes, in 2D and 3D, and on linear, curved and surface meshes. Interpolation of functions between coarse and fine meshes, persistent GLVis visualization, and saving of time-dependent fields for external visualization with VisIt are also illustrated. The example has a serial ( ex15.cpp ) and a parallel ( ex15p.cpp ) version. We recommend viewing examples 1, 6 and 9 before viewing this example.","title":"Example 15: Dynamic AMR"},{"location":"examples_mfem.html#example-16-time-dependent-heat-conduction","text":"This example code solves a simple 2D/3D time dependent nonlinear heat conduction problem $$\\frac{du}{dt} = \\nabla \\cdot \\left( \\kappa + \\alpha u \\right) \\nabla u$$ with a natural insulating boundary condition $\\frac{du}{dn} = 0$. We linearize the problem by using the temperature field $u$ from the previous time step to compute the conductivity coefficient. This example demonstrates both implicit and explicit time integration as well as a single Picard step method for linearization. The saving of time dependent data files for external visualization with VisIt is also illustrated. The example has a serial ( ex16.cpp ) and a parallel ( ex16p.cpp ) version. We recommend viewing examples 2, 9, and 10 before viewing this example.","title":"Example 16: Time Dependent Heat Conduction"},{"location":"examples_mfem.html#example-17-dg-linear-elasticity","text":"This example code solves a simple linear elasticity problem describing a multi-material cantilever beam using symmetric or non-symmetric discontinuous Galerkin (DG) formulation. Specifically, we approximate the weak form of $$-{\\rm div}({\\sigma}({\\bf u})) = 0$$ where $${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$ is the stress tensor corresponding to displacement field ${\\bf u}$, and $\\lambda$ and $\\mu$ are the material Lame constants. The boundary conditions are Dirichlet, $\\bf{u}=\\bf{u_D}$, on the fixed part of the boundary, namely boundary attributes 1 and 2; on the rest of the boundary we use ${\\sigma}({\\bf u})\\cdot n = {\\bf 0}$. The geometry of the domain is assumed to be as follows: The example demonstrates the use of high-order DG vector finite element spaces with the linear DG elasticity bilinear form, meshes with curved elements, and the definition of piece-wise constant and function vector-coefficient objects. The use of non-homogeneous Dirichlet b.c. imposed weakly, is also illustrated. The example has a serial ( ex17.cpp ) and a parallel ( ex17p.cpp ) version. We recommend viewing examples 2 and 14 before viewing this example.","title":"Example 17: DG Linear Elasticity"},{"location":"examples_mfem.html#example-18-dg-euler-equations","text":"This example code solves the compressible Euler system of equations, a model nonlinear hyperbolic PDE, with a discontinuous Galerkin (DG) formulation. The primary purpose is to show how a transient system of nonlinear equations can be formulated in MFEM. The equations are solved in conservative form $$\\frac{\\partial u}{\\partial t} + \\nabla \\cdot {\\bf F}(u) = 0$$ with a state vector $u = [ \\rho, \\rho v_0, \\rho v_1, \\rho E ]$, where $\\rho$ is the density, $v_i$ is the velocity in the $i^{\\rm th}$ direction, $E$ is the total specific energy, and $H = E + p / \\rho$ is the total specific enthalpy. The pressure, $p$ is computed through a simple equation of state (EOS) call. The conservative hydrodynamic flux ${\\bf F}$ in each direction $i$ is $${\\bf F_{\\it i}} = [ \\rho v_i, \\rho v_0 v_i + p \\delta_{i,0}, \\rho v_1 v_i + p \\delta_{i,1}, \\rho v_i H ]$$ Specifically, the example solves for an exact solution of the equations whereby a vortex is transported by a uniform flow. Since all boundaries are periodic here, the method's accuracy can be assessed by measuring the difference between the solution and the initial condition at a later time when the vortex returns to its initial location. Note that as the order of the spatial discretization increases, the timestep must become smaller. This example currently uses a simple estimate derived by Cockburn and Shu for the 1D RKDG method. An additional factor can be tuned by passing the --cfl (or -c shorter) flag. The example demonstrates user-defined bilinear and nonlinear form integrators for systems of equations that are defined with block vectors, and how these are used with an operator for explicit time integrators. In this case the system also involves an external approximate Riemann solver for the DG interface flux. It also demonstrates how to use GLVis for in-situ visualization of vector grid functions. The example has a serial ( ex18.cpp ) and a parallel ( ex18p.cpp ) version. We recommend viewing examples 9, 14 and 17 before viewing this example.","title":"Example 18: DG Euler Equations"},{"location":"examples_mfem.html#example-19-incompressible-nonlinear-elasticity","text":"This example code solves the quasi-static incompressible nonlinear hyperelasticity equations. Specifically, it solves the nonlinear equation $$ \\nabla \\cdot \\sigma(F) = 0 $$ subject to the constraint $$ \\text{det } F = 1 $$ where $\\sigma$ is the Cauchy stress and $F_{ij} = \\delta_{ij} + u_{i,j}$ is the deformation gradient. To handle the incompressibility constraint, pressure is included as an independent unknown $p$ and the stress response is modeled as an incompressible neo-Hookean hyperelastic solid . The geometry of the domain is assumed to be as follows: This formulation requires solving the saddle point system $$ \\left[ \\begin{array}{cc} K &B^T \\\\ B & 0 \\end{array} \\right] \\left[\\begin{array}{c} \\Delta u \\\\ \\Delta p \\end{array} \\right] = \\left[\\begin{array}{c} R_u \\\\ R_p \\end{array} \\right] $$ at each Newton step. To solve this linear system, we implement a specialized block preconditioner of the form $$ P^{-1} = \\left[\\begin{array}{cc} I & -\\tilde{K}^{-1}B^T \\\\ 0 & I \\end{array} \\right] \\left[\\begin{array}{cc} \\tilde{K}^{-1} & 0 \\\\ 0 & -\\gamma \\tilde{S}^{-1} \\end{array} \\right] $$ where $\\tilde{K}^{-1}$ is an approximation of the inverse of the stiffness matrix $K$ and $\\tilde{S}^{-1}$ is an approximation of the inverse of the Schur complement $S = BK^{-1}B^T$. To approximate the Schur complement, we use the mass matrix for the pressure variable $p$. The example demonstrates how to solve nonlinear systems of equations that are defined with block vectors as well as how to implement specialized block preconditioners for use in iterative solvers. The example has a serial ( ex19.cpp ) and a parallel ( ex19p.cpp ) version. We recommend viewing examples 2, 5 and 10 before viewing this example.","title":"Example 19: Incompressible Nonlinear Elasticity"},{"location":"examples_mfem.html#example-20-symplectic-integration-of-hamiltonian-systems","text":"This example demonstrates the use of the variable order, symplectic time integration algorithm. Symplectic integration algorithms are designed to conserve energy when integrating systems of ODEs which are derived from Hamiltonian systems. Hamiltonian systems define the energy of a system as a function of time (t), a set of generalized coordinates (q), and their corresponding generalized momenta (p). $$ H(q,p,t) = T(p) + V(q,t) $$ Hamilton's equations then specify how q and p evolve in time: $$ \\frac{dq}{dt} = \\frac{dH}{dp}\\,,\\qquad \\frac{dp}{dt} = -\\frac{dH}{dq} $$ To use the symplectic integration classes we need to define an mfem::Operator ${\\bf P}$ which evaluates the action of dH/dp, and an mfem::TimeDependentOperator ${\\bf F}$ which computes -dH/dq. This example visualizes its results as an evolution in phase space by defining the axes to be $q$, $p$, and $t$ rather than $x$, $y$, and $z$. In this space we build a ribbon-like mesh with nodes at $(0,0,t)$ and $(q,p,t)$. Finally we plot the energy as a function of time as a scalar field on this ribbon-like mesh. This scheme highlights any variations in the energy of the system. This example offers five simple 1D Hamiltonians: Simple Harmonic Oscillator (mass on a spring) $$H = \\frac{1}{2}\\left( \\frac{p^2}{m} + \\frac{q^2}{k} \\right)$$ Pendulum $$H = \\frac{1}{2}\\left[ \\frac{p^2}{m} - k \\left( 1 - cos(q) \\right) \\right]$$ Gaussian Potential Well $$H = \\frac{p^2}{2m} - k e^{-q^2 / 2}$$ Quartic Potential $$H = \\frac{1}{2}\\left[ \\frac{p^2}{m} + k \\left( 1 + q^2 \\right) q^2 \\right]$$ Negative Quartic Potential $$H = \\frac{1}{2}\\left[ \\frac{p^2}{m} + k \\left( 1 - \\frac{q^2}{8} \\right) q^2 \\right]$$ In all cases these Hamiltonians are shifted by constant values so that the energy will remain positive. The mean and standard deviation of the computed energies at each time step are displayed upon completion. When run in parallel, each processor integrates the same Hamiltonian system but starting from different initial conditions. The example has a serial ( ex20.cpp ) and a parallel ( ex20p.cpp ) version. See the Maxwell miniapp for another application of symplectic integration.","title":"Example 20: Symplectic Integration of Hamiltonian Systems"},{"location":"examples_mfem.html#example-21-adaptive-mesh-refinement-for-linear-elasticity","text":"This is a version of Example 2 with a simple adaptive mesh refinement loop. The problem being solved is again linear elasticity describing a multi-material cantilever beam. The problem is solved on a sequence of meshes which are locally refined in a conforming (triangles, tetrahedrons) or non-conforming (quadrilaterals, hexahedra) manner according to a simple ZZ error estimator. The example demonstrates MFEM's capability to work with both conforming and nonconforming refinements, in 2D and 3D, on linear and curved meshes. Interpolation of functions from coarse to fine meshes, as well as persistent GLVis visualization are also illustrated. The example has a serial ( ex21.cpp ) and a parallel ( ex21p.cpp ) version. We recommend viewing Examples 2 and 6 before viewing this example.","title":"Example 21: Adaptive mesh refinement for linear elasticity"},{"location":"examples_mfem.html#example-22-complex-linear-systems","text":"This example code demonstrates the use of MFEM to define and solve a complex-valued linear system. It implements three variants of a damped harmonic oscillator: A scalar $H^1$ field: $$-\\nabla\\cdot\\left(a \\nabla u\\right) - \\omega^2 b\\,u + i\\,\\omega\\,c\\,u = 0$$ A vector $H(curl)$ field: $$\\nabla\\times\\left(a\\nabla\\times\\vec{u}\\right) - \\omega^2 b\\,\\vec{u} + i\\,\\omega\\,c\\,\\vec{u} = 0$$ A vector $H(div)$ field: $$-\\nabla\\left(a \\nabla\\cdot\\vec{u}\\right) - \\omega^2 b\\,\\vec{u} + i\\,\\omega\\,c\\,\\vec{u} = 0$$ In each case the field is driven by a forced oscillation, with angular frequency $\\omega$, imposed at the boundary or a portion of the boundary. The example also demonstrates how to display a time-varying solution as a sequence of fields sent to a single GLVis socket. The example has a serial ( ex22.cpp ) and a parallel ( ex22p.cpp ) version. We recommend viewing examples 1, 3, and 4 before viewing this example.","title":"Example 22: Complex Linear Systems"},{"location":"examples_mfem.html#example-23-wave-problem","text":"This example code solves a simple 2D/3D wave equation with a second order time derivative: $$\\frac{\\partial^2 u}{\\partial t^2} - c^2\\Delta u = 0$$ The boundary conditions are either Dirichlet or Neumann. The example demonstrates the use of time dependent operators, implicit solvers and second order time integration. The example has only a serial ( ex23.cpp ) version. We recommend viewing examples 9 and 10 before viewing this example.","title":"Example 23: Wave Problem"},{"location":"examples_mfem.html#example-24-mixed-finite-element-spaces","text":"This example code illustrates usage of mixed finite element spaces, with three variants: $H^1 \\times H(curl)$ $H(curl) \\times H(div)$ $H(div) \\times L_2$ Using different approaches for demonstration purposes, we project or interpolate a gradient, curl, or divergence in the appropriate spaces, comparing the errors in each case. Partial assembly and GPU devices are supported. The example has a serial ( ex24.cpp ) and a parallel ( ex24p.cpp ) version. We recommend viewing examples 1 and 3 before viewing this example.","title":"Example 24: Mixed finite element spaces"},{"location":"examples_mfem.html#example-25-perfectly-matched-layers","text":"The example illustrates the use of a Perfectly Matched Layer (PML) for the simulation of time-harmonic electromagnetic waves propagating in unbounded domains. PML was originally introduced by Berenger in \"A Perfectly Matched Layer for the Absorption of Electromagnetic Waves\" . It is a technique used to solve wave propagation problems posed in infinite domains. The implementation involves the introduction of an artificial absorbing layer that minimizes undesired reflections. Inside this layer a complex coordinate stretching map is used which forces the wave modes to decay exponentially. The example solves the indefinite Maxwell equations $$\\nabla \\times (a \\nabla \\times E) - \\omega^2 b E = f.$$ where $a = \\mu^{-1} |J|^{-1} J^T J$, $b= \\epsilon |J| J^{-1} J^{-T}$ and $J$ is the Jacobian matrix of the coordinate transformation. The example demonstrates discretization with Nedelec finite elements in 2D or 3D, as well as the use of complex-valued bilinear and linear forms. Several test problems are included, with known exact solutions. The example has a serial ( ex25.cpp ) and a parallel ( ex25p.cpp ) version. We recommend viewing Example 22 before viewing this example.","title":"Example 25: Perfectly Matched Layers"},{"location":"examples_mfem.html#example-26-multigrid-preconditioner","text":"This example code demonstrates the use of MFEM to define a simple isoparametric finite element discretization of the Laplace problem $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary conditions and how to solve it efficiently using a matrix-free multigrid preconditioner. The example highlights on the creation of a hierarchy of discretization spaces and diffusion bilinear forms using partial assembly. The levels in the hierarchy of finite element spaces maybe constructed through geometric or order refinements. Moreover, the construction of a multigrid preconditioner for the PCG solver is shown. The multigrid uses a PCG solver on the coarsest level and second order Chebyshev accelerated smoothers on the other levels. The example has a serial ( ex26.cpp ) and a parallel ( ex26p.cpp ) version. We recommend viewing Example 1 before viewing this example.","title":"Example 26: Multigrid Preconditioner"},{"location":"examples_mfem.html#example-27-laplace-boundary-conditions","text":"This example code demonstrates the use of MFEM to define a simple finite element discretization of the Laplace problem: $$ -\\Delta u = 0 $$ with a variety of boundary conditions. Specifically, we discretize using a FE space of the specified order using a continuous or discontinuous space. We then apply Dirichlet, Neumann (both homogeneous and inhomogeneous), Robin, and Periodic boundary conditions on different portions of a predefined mesh. Boundary conditions: $u = u_{dbc}$ on $\\Gamma_{dbc}$ $\\hat{n}\\cdot\\nabla u = g_{nbc}$ on $\\Gamma_{nbc}$ $\\hat{n}\\cdot\\nabla u = 0$ on $\\Gamma_{nbc_0}$ $\\hat{n}\\cdot\\nabla u + a u = b$ on $\\Gamma_{rbc}$ as well as periodic boundary conditions which are enforced topologically. The example has a serial ( ex27.cpp ) and a parallel ( ex27p.cpp ) version. We recommend viewing examples 1 and 14 before viewing this example.","title":"Example 27: Laplace Boundary Conditions"},{"location":"examples_mfem.html#volta-miniapp-electrostatics","text":"This miniapp demonstrates the use of MFEM to solve realistic problems in the field of linear electrostatics. Its features include: dielectric materials charge densities surface charge densities prescribed voltages applied polarizations high order meshes high order basis functions adaptive mesh refinement advanced visualization For more details, please see the documentation in the miniapps/electromagnetics directory. The miniapp has only a parallel ( volta.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Volta Miniapp: Electrostatics"},{"location":"examples_mfem.html#tesla-miniapp-magnetostatics","text":"This miniapp showcases many of MFEM's features while solving a variety of realistic magnetostatics problems. Its features include: diamagnetic and/or paramagnetic materials ferromagnetic materials volumetric current densities surface current densities external fields high order meshes high order basis functions adaptive mesh refinement advanced visualization For more details, please see the documentation in the miniapps/electromagnetics directory. The miniapp has only a parallel ( tesla.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Tesla Miniapp: Magnetostatics"},{"location":"examples_mfem.html#maxwell-miniapp-transient-full-wave-electromagnetics","text":"This miniapp solves the equations of transient full-wave electromagnetics. Its features include: mixed formulation of the coupled first-order Maxwell equations $H(\\mathrm{curl})$ discretization of the electric field $H(\\mathrm{div})$ discretization of the magnetic flux energy conserving, variable order, implicit time integration dielectric materials diamagnetic and/or paramagnetic materials conductive materials volumetric current densities Sommerfeld absorbing boundary conditions high order meshes high order basis functions advanced visualization For more details, please see the documentation in the miniapps/electromagnetics directory. The miniapp has only a parallel ( maxwell.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Maxwell Miniapp: Transient Full-Wave Electromagnetics"},{"location":"examples_mfem.html#joule-miniapp-transient-magnetics-and-joule-heating","text":"This miniapp solves the equations of transient low-frequency (a.k.a. eddy current) electromagnetics, and simultaneously computes transient heat transfer with the heat source given by the electromagnetic Joule heating. Its features include: $H^1$ discretization of the electrostatic potential $H(\\mathrm{curl})$ discretization of the electric field $H(\\mathrm{div})$ discretization of the magnetic field $H(\\mathrm{div})$ discretization of the heat flux $L^2$ discretization of the temperature implicit transient time integration high order meshes high order basis functions adaptive mesh refinement advanced visualization For more details, please see the documentation in the miniapps/electromagnetics directory. The miniapp has only a parallel ( joule.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Joule Miniapp: Transient Magnetics and Joule Heating"},{"location":"examples_mfem.html#mobius-strip-miniapp","text":"This miniapp generates various Mobius strip-like surface meshes. It is a good way to generate complex surface meshes. Manipulating the mesh topology and performing mesh transformation are demonstrated. The mobius-strip mesh in the data directory was generated with this miniapp. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( mobius-strip.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Mobius Strip Miniapp"},{"location":"examples_mfem.html#klein-bottle-miniapp","text":"This miniapp generates three types of Klein bottle surfaces. It is similar to the mobius-strip miniapp. Manipulating the mesh topology and performing mesh transformation are demonstrated. The klein-bottle and klein-donut meshes in the data directory were generated with this miniapp. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( klein-bottle.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Klein Bottle Miniapp"},{"location":"examples_mfem.html#toroid-miniapp","text":"This miniapp generates two types of toroidal volume meshes; one with triangular cross sections and one with square cross sections. It works by defining a stack of individual elements and bending them so that the bottom and top of the stack can be joined to form a torus. It supports various options including: The element type: 0 - Wedge, 1 - Hexahedron The geometric order of the elements The major and minor radii The number of elements in the azimuthal direction The number of nodes to offset by before rejoining the stack The initial angle of the cross sectional shape The number of uniform refinement steps to apply Along with producing some visually interesting meshes, this miniapp demonstrates how simple 3D meshes can be constructed and transformed in MFEM. It also produces a family of meshes with simple but non-trivial topology for testing various features in MFEM. This miniapp has only a serial ( toroid.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Toroid Miniapp"},{"location":"examples_mfem.html#twist-miniapp","text":"This miniapp generates simple periodic meshes to demonstrate MFEM's handling of periodic domains. MFEM's strategy is to use a discontinuous vector field to define the mesh coordinates on a topologically periodic mesh. It works by defining a stack of individual elements and stitching together the top and bottom of the mesh. The stack can also be twisted so that the vertices of the bottom and top can be joined with any integer offset (for tetrahedral and wedge meshes only even offsets are supported). The Twist miniapp supports various options including: The element type: 4 - Tetrahedron, 6 - Wedge, 8 - Hexahedron The geometric order of the elements The dimensions of the initial brick-shaped stack of elements The number of elements in the z direction The number of nodes to offset by before rejoining the stack The number of uniform refinement steps to apply Along with producing some visually interesting meshes, this miniapp demonstrates how simple 3D meshes can be constructed and transformed in MFEM. It also produces a family of meshes with simple but non-trivial topology for testing various features in MFEM. This miniapp has only a serial ( twist.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Twist Miniapp"},{"location":"examples_mfem.html#extruder-miniapp","text":"This miniapp creates higher dimensional meshes from lower dimensional meshes by extrusion. Simple coordinate transformations can also be applied if desired. The initial mesh can be 1D or 2D 1D meshes can be extruded in both the y and z directions 2D meshes can be triangular, quadrilateral, or contain both element types Meshes with high order geometry are supported User can specify the number of elements and the distance to extrude Geometric order of the transformed mesh can be user selected or automatic This miniapp provides another demonstration of how simple meshes can be constructed and transformed in MFEM. This miniapp has only a serial ( extruder.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Extruder Miniapp"},{"location":"examples_mfem.html#polar-nc-miniapp","text":"This miniapp generates a circular sector mesh that consist of quadrilaterals and triangles of similar sizes. The 3D version of the mesh is made of prisms and tetrahedra. The mesh is non-conforming by design, and can optionally be made curvilinear. The elements are ordered along a space-filling curve by default, which makes the mesh ready for parallel non-conforming AMR in MFEM. The implementation also demonstrates how to initialize a non-conforming mesh on the fly by marking hanging nodes with Mesh::AddVertexParents . For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( polar-nc.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Polar-NC Miniapp"},{"location":"examples_mfem.html#shaper-miniapp","text":"This miniapp performs multiple levels of adaptive mesh refinement to resolve the interfaces between different \"materials\" in the mesh, as specified by a given material function. It can be used as a simple initial mesh generator, for example in the case when the interface is too complex to describe without local refinement. Both conforming and non-conforming refinements are supported. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( shaper.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Shaper Miniapp"},{"location":"examples_mfem.html#mesh-explorer-miniapp","text":"This miniapp is a handy tool to examine, visualize and manipulate a given mesh. Some of its features are: visualizing of mesh materials and individual mesh elements mesh scaling, randomization, and general transformation manipulation of the mesh curvature the ability to simulate parallel partitioning quantitative and visual reports of mesh quality For more details, please see the documentation in the miniapps/meshing directory. The miniapp has only a serial ( mesh-explorer.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Mesh Explorer Miniapp"},{"location":"examples_mfem.html#mesh-optimizer-miniapp","text":"This miniapp performs mesh optimization using the Target-Matrix Optimization Paradigm (TMOP) by P.Knupp et al., and a global variational minimization approach. It minimizes the quantity $$\\sum_T \\int_T \\mu(J(x)),$$ where $T$ are the target (ideal) elements, $J$ is the Jacobian of the transformation from the target to the physical element, and $\\mu$ is the mesh quality metric. This metric can measure shape, size or alignment of the region around each quadrature point. The combination of targets and quality metrics is used to optimize the physical node positions, i.e., they must be as close as possible to the shape / size / alignment of their targets. This code also demonstrates a possible use of nonlinear operators, as well as their coupling to Newton methods for solving minimization problems. Note that the utilized Newton methods are oriented towards avoiding invalid meshes with negative Jacobian determinants. Each Newton step requires the inversion of a Jacobian matrix, which is done through an inner linear solver. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has a serial ( mesh-optimizer.cpp ) and a parallel ( pmesh-optimizer.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Mesh Optimizer Miniapp"},{"location":"examples_mfem.html#minimal-surface-miniapp","text":"This miniapp solves Plateau's problem: the Dirichlet problem for the minimal surface equation. Options to solve the minimal surface equations of both parametric surfaces as well as surfaces restricted to be graphs of the form $z=f(x,y)$ are supported, including a number of examples such as the Catenoid, Helicoid, Costa and Schrek surfaces. For more details, please see the documentation in the miniapps/meshing directory. The miniapp has a serial ( minimal-surface.cpp ) and a parallel ( pminimal-surface.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Minimal Surface Miniapp"},{"location":"examples_mfem.html#low-order-refined-transfer-miniapp","text":"The lor-transfer miniapp, found under miniapps/tools demonstrates the capability to generate a low-order refined mesh from a high-order mesh, and to transfer solutions between these meshes. Grid functions can be transferred between the coarse, high-order mesh and the low-order refined mesh using either $L^2$ projection or pointwise evaluation. These transfer operators can be designed to discretely conserve mass and to recover the original high-order solution when transferring a low-order grid function that was obtained by restricting a high-order grid function to the low-order refined space. The miniapp has only a serial ( lor-transfer.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.","title":"Low-Order Refined Transfer Miniapp"},{"location":"examples_mfem.html#interpolation-miniapps","text":"The interpolation miniapp, found under miniapps/gslib , demonstrate the capability to interpolate high-order finite element functions at given set of points in physical space. These miniapps utilize the gslib library's high-order interpolation utility for quad and hex meshes: Find Points miniapp has a serial ( findpts.cpp ) and a parallel ( pfindpts.cpp ) version that demonstrate the basic procedures for point search and evaluation of grid functions. Field Interp miniapp ( field-interp.cpp ) demonstrates how grid functions can be transferred between meshes. Field Diff miniapp ( field-diff.cpp ) demonstrates how grid functions on two different meshes can be compared with each other. These miniapps require installation of the gslib library. We recommend that new users start with the example codes before moving to the miniapps.","title":"Interpolation Miniapps"},{"location":"examples_mfem.html#laghos-miniapp","text":"Laghos (LAGrangian High-Order Solver) is a miniapp that solves the time-dependent Euler equations of compressible gas dynamics in a moving Lagrangian frame using unstructured high-order finite element spatial discretization and explicit high-order time-stepping. The computational motives captured in Laghos include: Support for unstructured meshes, in 2D and 3D, with quadrilateral and hexahedral elements (triangular and tetrahedral elements can also be used, but with the less efficient full assembly option). Serial and parallel mesh refinement options can be set via a command-line flag. Explicit time-stepping loop with a variety of time integrator options. Laghos supports Runge-Kutta ODE solvers of orders 1, 2, 3, 4 and 6. Continuous and discontinuous high-order finite element discretization spaces of runtime-specified order. Moving (high-order) meshes. Separation between the assembly and the quadrature point-based computations. Point-wise definition of mesh size, time-step estimate and artificial viscosity coefficient. Constant-in-time velocity mass operator that is inverted iteratively on each time step. This is an example of an operator that is prepared once (fully or partially assembled), but is applied many times. The application cost is dominant for this operator. Time-dependent force matrix that is prepared every time step (fully or partially assembled) and is applied just twice per \"assembly\". Both the preparation and the application costs are important for this operator. Domain-decomposed MPI parallelism. Optional in-situ visualization with GLVis and data output for visualization / data analysis with VisIt . The Laghos miniapp is part of the CEED software suite , a collection of software benchmarks, miniapps, libraries and APIs for efficient exascale discretizations based on high-order finite element and spectral element methods. See http://github.com/ceed for more information and source code availability. This is an external miniapp, available at https://github.com/CEED/Laghos .","title":"Laghos Miniapp"},{"location":"examples_mfem.html#remhos-miniapp","text":"Remhos (REMap High-Order Solver) is a miniapp that solves the pure advection equations that are used to perform monotonic and conservative discontinuous field interpolation (remap) as part of the Eulerian phase in Arbitrary Lagrangian Eulerian (ALE) simulations. The computational motives captured in Remhos include: Support for unstructured meshes, in 2D and 3D, with quadrilateral and hexahedral elements. Serial and parallel mesh refinement options can be set via a command-line flag. Explicit time-stepping loop with a variety of time integrator options. Remhos supports Runge-Kutta ODE solvers of orders 1, 2, 3, 4 and 6. Discontinuous high-order finite element discretization spaces of runtime-specified order. Moving (high-order) meshes. Mass operator that is local per each zone. It is inverted by iterative or exact methods at each time step. This operator is constant in time (transport mode) or changing in time (remap mode). Options for full or partial assembly. Advection operator that couples neighboring zones. It is applied once at each time step. This operator is constant in time (transport mode) or changing in time (remap mode). Options for full or partial assembly. Domain-decomposed MPI parallelism. Optional in-situ visualization with GLVis and data output for visualization and data analysis with VisIt . The Remhos miniapp is part of the CEED software suite , a collection of software benchmarks, miniapps, libraries and APIs for efficient exascale discretizations based on high-order finite element and spectral element methods. See http://github.com/ceed for more information and source code availability. This is an external miniapp, available at https://github.com/CEED/Remhos .","title":"Remhos Miniapp"},{"location":"examples_mfem.html#navier-miniapp","text":"Navier is a miniapp that solves the time-dependent Navier-Stokes equations of incompressible fluid dynamics \\begin{align} \\frac{\\partial u}{\\partial t} + (u \\cdot \\nabla) u - \\frac{1}{Re} \\nabla^2 u - \\nabla p &= f \\\\ \\nabla \\cdot u &= 0 \\end{align} using a spatially high-order finite element discretization. The time-dependent problem is solved using a (up to) third order implicit-explicit method which leverages an extrapolation scheme for the convective parts and a backward-difference formulation for the viscous parts of the equation. The miniapp supports: Arbitrary order H1 elements High order mesh elements IMEX (EXTk-BDFk) time-stepping up to third order Convenient interface for new users A variety of test cases and benchmarks This miniapp has only a parallel ( navier_solver.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps. No examples or miniapps match your criteria. <!-- function showElement(id, show) { //document.getElementById(id).style.display = show ? \"block\" : \"none\"; // workaround because Doxygen splits and duplicates the divs for some reason var divs = document.getElementsByTagName(\"div\"); for (i = 0; i < divs.length; i++) { if (divs.item(i).id == id) { divs.item(i).style.display = show ? \"block\" : \"none\"; } } return show ? 1 : 0; } function getBooleans(comboId) { combo = document.getElementById(comboId); first_selected = false; for (i = 0; i < combo.options.length; i++) { opt = combo.options[i]; selected = opt.selected || first_selected; if (!i) { first_selected = selected; } // create a boolean variable named after the option this[opt.id] = selected; } } function update() { getBooleans(\"group1\"); getBooleans(\"group2\"); getBooleans(\"group3\"); getBooleans(\"group4\"); numShown = 0 // expression continued... // example codes + showElement(\"ex1\", (diffusion) && h1 && (galerkin || nurbs || staticcond || pa) && (gs || pcg || umfpack || amg || petsc)) + showElement(\"ex2\", elasticity && h1 && (galerkin || nurbs || staticcond) && (gs || pcg || umfpack || amg || petsc)) + showElement(\"ex3\", (maxwell) && hcurl && (galerkin || staticcond || pa) && (gs || pcg || umfpack || ams || petsc)) + showElement(\"ex4\", graddiv && (hdiv || h12) && (galerkin || hybr || staticcond || pa) && (gs || pcg || umfpack || amg || ads || ams || petsc)) + showElement(\"ex5\", darcy && (l2 || hdiv) && (mixed || pa) && (gs || jacobi || minres || umfpack || amg || petsc)) + showElement(\"ex6\", (diffusion) && h1 && (galerkin || nurbs || amr || pa) && (gs || pcg || umfpack || amg || petsc)) + showElement(\"ex7\", (diffusion || meshing) && h1 && (galerkin || amr) && (gs || pcg || umfpack || amg)) + showElement(\"ex8\", diffusion && (l2 || h1 || h12) && dpg && (gs || pcg || umfpack || amg || ads || ams)) + showElement(\"ex9\", (advection) && l2 && (dg || pa) && (pcg || rk || sundials || petsc || hiop || gmres || sdirk)) + showElement(\"ex10\", elasticity && (l2 || h1) && galerkin && (jacobi || pcg || minres || umfpack || newton || rk || sdirk || sundials || petsc)) + showElement(\"ex11\", diffusion && h1 && (galerkin || nurbs) && (lobpcg || amg || superlu || slepc)) + showElement(\"ex12\", elasticity && h1 && (galerkin || nurbs) && (lobpcg || amg)) + showElement(\"ex13\", maxwell && hcurl && galerkin && (lobpcg || ams)) + showElement(\"ex14\", diffusion && l2 && dg && (gs || pcg || gmres || umfpack || amg)) + showElement(\"ex15\", diffusion && h1 && (galerkin || nurbs || amr) && (gs || pcg || umfpack || amg)) + showElement(\"ex16\", conduction && h1 && galerkin && (pcg || jacobi || rk || sdirk || sundials)) + showElement(\"ex17\", elasticity && l2 && dg && (gs || pcg || gmres || umfpack || amg)) + showElement(\"ex18\", compressibleflow && l2 && dg && (rk)) + showElement(\"ex19\", elasticity && h1 && mixed && (gs || gmres || newton || amg)) + showElement(\"ex20\", (elasticity || maxwell || conduction || compressibleflow) && h1 && mixed && symplectic) + showElement(\"ex21\", elasticity && h1 && (galerkin || amr) && (gs || pcg || umfpack || amg)) + showElement(\"ex22\", (diffusion || maxwell || graddiv) && (h1 || hcurl || hdiv) && galerkin && (gmres || amg || ams || ads)) + showElement(\"ex23\", (diffusion || wave) && h1 && (galerkin || nurbs) && newmark) + showElement(\"ex24\", (graddiv) && (h1 || hcurl) && (galerkin || pa) && pcg) + showElement(\"ex25\", (maxwell || wave) && hcurl && galerkin && (gmres || ams)) + showElement(\"ex26\", diffusion && h1 && (galerkin || pa) && (jacobi || pcg || amg)) + showElement(\"ex27\", (elasticity || maxwell || conduction || compressibleflow) && (h1 || l2) && (galerkin || dg) && (gs || pcg || gmres || amg || umfpack)) // electromagnetic miniapps + showElement(\"volta\", maxwell && (l2 || hdiv) && (galerkin || amr) && (pcg || amg)) + showElement(\"tesla\", maxwell && (hdiv || hcurl) && (galerkin || amr) && (pcg || amg || ams)) + showElement(\"maxwell\", (maxwell || conduction || wave) && (hdiv || hcurl) && (galerkin || staticcond || mixed) && (pcg || symplectic)) + showElement(\"joule\", (maxwell || conduction) && (l2 || h1 || hdiv || hcurl) && (galerkin || amr || staticcond) && (pcg || amg || ams || ads || sdirk)) // meshing miniapps + showElement(\"mobius-strip\", meshing && all2 && all3 && all4) + showElement(\"klein-bottle\", meshing && all2 && all3 && all4) + showElement(\"toroid\", meshing && all2 && all3 && all4) + showElement(\"twist\", meshing && all2 && all3 && all4) + showElement(\"extruder\", meshing && all2 && all3 && all4) + showElement(\"polar-nc\", meshing && all2 && all3 && all4) + showElement(\"shaper\", meshing && all2 && all3 && all4) + showElement(\"mesh-explorer\", meshing && all2 && all3 && all4) + showElement(\"mesh-optimizer\", meshing && all2 && all3 && all4) + showElement(\"minimal-surface\", meshing && all2 && (galerkin || amr || pa) && all4) + showElement(\"lor-transfer\", meshing && (l2 || h1) && all3 && all4) + showElement(\"gslib-interpolation\", meshing && all2 && all3 && all4) // external miniapps + showElement(\"laghos\", (compressibleflow) && (l2 || h1) && (galerkin || dg || pa) && (rk)) + showElement(\"remhos\", (advection) && (l2) && (galerkin || dg || pa) && (rk)) + showElement(\"navier\", (incompressibleflow) && (h1) && (galerkin || pa) && (gmres || pcg || amg)) ; // ...end of expression // show/hide the message \"No examples match your criteria\" showElement(\"nomatch\", numShown == 0); } function initCombos() { var query = location.search.substr(1); query.split(\"&\").forEach(function(id) { if (id) { opt = document.getElementById(id); if (opt) { opt.selected = true; } } }); } // make sure \"no match\" div is not visible after page is loaded window.onload = update; // force vertical scrollbar document.getElementsByTagName(\"body\")[0].style = \"overflow-y: scroll\" // parse URL part after '?', e.g., http://.../index.html?elasticity&nurbs initCombos(); //-->","title":"Navier Miniapp"},{"location":"features.html","text":"MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}}); Features The goal of libROM is to provide high-performance scalable library for data-driven reduced order modeling. Proper orthogonal decomposition One of the core features in libROM is the ability to extract important modes from given physical simulation data. The proper othogonal decomposition (POD) is a popular method for compressing physical simulation data to obtain optimal \"reduced\" bases in the following sense: $$\\boldsymbol{\\Phi} =\\underset{\\boldsymbol{A}\\in\\mathbb{R}^{n\\times r}, \\boldsymbol{A}^T\\boldsymbol{A} = \\boldsymbol{I}_{r\\times r} }{\\arg\\min} || \\boldsymbol{U} - \\boldsymbol{A}\\boldsymbol{A}^T\\boldsymbol{U} ||_F^2, $$ where $\\boldsymbol{U}\\in\\mathbb{R}^{n\\times m}$ is simulation data and $\\boldsymbol{I}_{r\\times r} \\in \\mathbb{R}^{r\\times r}$ denotes an identity matrix. That is, the POD tries to find the orthogonal matrix, $\\boldsymbol{\\Phi}$, whose span minimizes the projection error in the Frobenius norm. The POD modes can be obtained in two equivalent ways: (i) eigenvalue decomposition and (ii) singular value decomposition (SVD). We take the latter approach, i.e., let's say the thin SVD of $\\boldsymbol{U}$ is given by $$\\boldsymbol{U} = \\boldsymbol{W\\Sigma V}^T.$$ Then the solution of the POD is given by taking the first $r$ columns of the left singular matrix, i.e., $\\boldsymbol{\\Phi} = [\\boldsymbol{w}_{1},\\ldots ,\\boldsymbol{w}_r]$, where $\\boldsymbol{w}_k$ is $k$th left singular vector, assuming that the singular value is written in the decreasing order. Efficient data collection High-fidelity physical simulations generate intensive data in its size, which makes the data collection process daunting. Therefore, the libROM aims to ease the difficulty associated with the intensive data size. The libROM can be directly integrated to the physics solver that generates the intensive simulation data. For example, if the physical simulation is time dependent, then each time step solution data can be feed into the libROM incrementally so that the singular value decomposition is efficiently updated in parallel. This approach is incremental SVD . There are other types of SVDs which exploits efficiency. The libROM provides following four SVDs: Static SVD incremental SVD randomized SVD space-time SVD Static SVD The static SVD waits the libROM to collect all the simulation data. Once the snapshot matrix $\\boldsymbol{U}$ is formed, then the SVD is performed. Therefore, if the data size is big, this approach is not efficient and not recommended. However, because it gives the most accurate SVD results, it is ideal for a small problem. Incremental SVD Unlike the static SVD, the incremental SVD does not wait. Instead, as the data comes in, the SVD is performed right away. Because the incremental SVD only needs to find out the effect of one additional simulation data vector to the previous SVD, the update can be done very efficiently without requiring much memory. Therefore, it is useful for large-scale problems. For the detailed explanation about the incremental SVD, we refer to the following journal papers: M. Brand, Incremental singular value decomposition of uncertain data with missing values , In European Conference on Computer Vision , p707-720, 2002 G. Oxberry, T. Kostova-Vassilevska, W. Arrighi, K. Chand, Limited-memory adaptive snapshot selection for proper orthogonal decomposition , International Journal for Numerical Methods in Engineering , 109(2), p198-217, 2016 H. Fareed, J.R. Singler, Error Analysis of an Incremental Proper Orthogonal Decomposition Algorithm for PDE Simulation Data , Journal of Computational and Applied Mathematics , 368, 112525, 2020 Randomized SVD Randomization can bring computational efficiency in computing SVDs. For example, consider that one needs to extract $p$ dominant modes from $n \\times m$ tall dense matrix, using SVD. The randomized SVD requires $\\mathcal{O}(nm\\log(p))$ floating-point operations, while the static SVD algorithm requires $\\mathcal{O}(nmp)$ flops. The randomized SVD that is implemented in libROM can be found in the following journal paper: N. Halko, P.G. Martinsson, J.A. Tropp, Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions . SIAM review , 53(2), p217-288, 2011 Space-time SVD For time dependent problems, one can reduce not only the spatial degrees of freedom, but also the temporal degrees of freedom by representing the space-time solution as a linear combination of a space-time reduced basis. The space-time reduced basis can be mathematically written as a Kronecker product of temporal and spatial bases. Fortunately, one can extract temporal as well as spatial reduced bases from one single SVD. The procedure is schematically depicted in the figure below: For the detailed explanation about the incremental SVD, we refer to the following three journal papers: Y. Kim, K. Wang, Y. Choi, Efficient space\u2013time reduced order model for linear dynamical systems in Python using less than 120 lines of code . Mathematics , 9(14), 1690, 2021 Y. Choi, P. Brown, W. Arrighi, R. Anderson, K. Huynh, Space\u2013time reduced order model for large-scale linear dynamical systems with application to boltzmann transport problems . Journal of Computational Physics , 424, 109845, 2021 Y. Choi, K. Carlberg, Space-time least-squares Petrov-Galerkin projection for nonlinear model reduction , SIAM Journal on Scientific Computing , 41(1), A26-A58, 2019 Dynamic Mode Decomposition The dynamic mode decomposition (DMD) provides a great way of finding an approximate locally linear dynamical system, $$ \\frac{d\\boldsymbol{u}}{dt} = \\mathcal{A}\\boldsymbol{u},$$ for a given nonlinear dynamical system, $$ \\frac{d\\boldsymbol{u}}{dt} = \\boldsymbol{f}(\\boldsymbol{u},t;\\boldsymbol{\\mu}),$$ with initial condition, $\\boldsymbol{u}_0$. It takes non-intrusive approach, i.e., equation-free method, so it is applicable even if there is only data, but no $\\boldsymbol{f}(\\boldsymbol{u},t;\\boldsymbol{\\mu})$. For example, let's say the discrete-time data are given as: $$\\boldsymbol{U} = [\\boldsymbol{u}_1,\\ldots,\\boldsymbol{u}_m],$$ where $\\boldsymbol{u}_k\\in\\mathbb{R}^n$ denotes solution at $t=k\\Delta t$. The DMD is trying to find the best $\\boldsymbol{A}$ such that $$\\boldsymbol{U}^+ = \\boldsymbol{A}\\boldsymbol{U}^-,$$ where $\\boldsymbol{U}^+ = [\\boldsymbol{u}_2,\\ldots,\\boldsymbol{u}_m]$ and $\\boldsymbol{U}^- = [\\boldsymbol{u}_1, \\ldots, \\boldsymbol{u}_{m-1}]$. The following procedure is taken to find the best $\\boldsymbol{A}$. Take the singular value decomposition (SVD) of $\\boldsymbol{U}^-$ $$\\boldsymbol{U}^- \\approx \\boldsymbol{W}\\boldsymbol{\\Omega}\\boldsymbol{V}^*,$$ where $*$ denotes the conjugate transpose, $\\boldsymbol{W}\\in\\mathbb{C}^{n\\times r}$, $\\boldsymbol{\\Sigma}\\in\\mathbb{C}^{r\\times r}$, $\\boldsymbol{V}\\in\\mathbb{C}^{m\\times r}$, and $r \\leq m$. Because $\\boldsymbol{U}^+ = \\boldsymbol{A}\\boldsymbol{U}^-$, using the pseudo-inverse of the approximate $\\boldsymbol{U}^-$, we have $$\\boldsymbol{A} \\approx \\tilde{\\boldsymbol{A}} = \\boldsymbol{U}^+\\boldsymbol{V}\\boldsymbol{\\Omega}^{-1}\\boldsymbol{W}^*$$ It is easier to deal with the reduced operator $\\tilde{\\boldsymbol{A}}_r$, which relates the discrete-time dynamic of reduced states: $$\\tilde{\\boldsymbol{u}}_{k+1} = \\tilde{\\boldsymbol{A}}_r\\tilde{\\boldsymbol{u}}_k,$$ where $\\boldsymbol{u}_k = \\boldsymbol{W} \\tilde{\\boldsymbol{u}}_k$ and $\\tilde{\\boldsymbol{A}}_r$ is defined as $$\\tilde{\\boldsymbol{A}}_r=\\boldsymbol{W}^*\\tilde{\\boldsymbol{A}}\\boldsymbol{W}$$ $$\\tilde{\\boldsymbol{A}}_r=\\boldsymbol{W}^*\\boldsymbol{U}^+\\boldsymbol{V}\\boldsymbol{\\Omega}^{-1}$$ Let the eigen-decomposition of $\\tilde{\\boldsymbol{A}}_r$ to be $$\\tilde{\\boldsymbol{A}}_r \\boldsymbol{X} = \\boldsymbol{\\Lambda}\\boldsymbol{X}$$ and set $\\boldsymbol{\\Phi} = \\boldsymbol{W}\\boldsymbol{X}$, then the DMD solution at time, $t$, can be found as $$\\boldsymbol{u}(t) = \\boldsymbol{\\Phi}\\boldsymbol{\\Lambda}^{t/\\Delta t} \\boldsymbol{b}_0,$$ where $\\boldsymbol{b}_0 = \\boldsymbol{\\Phi}^\\dagger \\boldsymbol{u}_0$. For the detailed explanation about the DMD, we refer to the following book: J.N. Kutz, S.L. Brunton, B.W. Brunton, J.L. Proctor, Dynamic mode decomposition: data-driven modeling of complex systems . Society for Industrial and Applied Mathematics , 2016 Projection-based reduced order model In contrast to the DMD, the projection-based reduced order model (pROM) takes an intrusive approach, that is, it is NOT equation-free. The pROM first represents the solution as a linear combincation of reduced basis. The reduced basis can be obtained by the POD, for example. Let's denote the reduced basis as $\\boldsymbol{\\Phi}\\in\\mathbb{R}^{n\\times r}$ and express the solution, $\\boldsymbol{u}\\in\\mathbb{R}^n$ as $$\\boldsymbol{u} = \\boldsymbol{u}_{\\text{ref}}+\\boldsymbol{\\Phi}\\hat{\\boldsymbol{u}},$$ where $\\hat{\\boldsymbol{u}} \\in \\mathbb{R}^r$ denotes the generalized coordinates with respect to the reduced basis. Then we substitute $\\boldsymbol{u}$ in the governing equation, say a nonlinear dynamical system governed by the following ordinary differential equations, $$\\frac{d\\boldsymbol{u}}{dt} = \\boldsymbol{f}(\\boldsymbol{u},t;\\boldsymbol{\\mu}),$$ to obtain the over-determined system, i.e., $$\\boldsymbol{\\Phi}\\frac{d\\hat{\\boldsymbol{u}}}{dt} = \\boldsymbol{f}(\\boldsymbol{u}_{\\text{ref}}+\\boldsymbol{\\Phi}\\hat{\\boldsymbol{u}},t;\\boldsymbol{\\mu}),$$ which has more equations than unknowns. Therefore, the system needs to be closed by a projection. Galerkin and Petrov-Galerking projections are popular. For example, the Galerkin projection multiplies both sides by $\\boldsymbol{\\Phi}^T$ and the system of equations become $$\\frac{d\\hat{\\boldsymbol{u}}}{dt} = \\boldsymbol{\\Phi}^T \\boldsymbol{f}(\\boldsymbol{u}_{\\text{ref}}+\\boldsymbol{\\Phi}\\hat{\\boldsymbol{u}},t;\\boldsymbol{\\mu})$$ By the way, the nonlinear term $\\boldsymbol{f}$ still scales with the full order model size and it needs to be updated every time its argument changes due to Newton step updates, for example. The hyper-reduction provides an efficient way of computing nonlinear terms by sampling an important subset. By the way, if $\\boldsymbol{f}$ is linear, then $\\boldsymbol{\\Phi}^T\\boldsymbol{f}$ can be pre-computed, so the hyper-reduction is not necessary. Hyper-reduction Hyper-reduction is essential to reduce the complexity of nonlinear terms in pROM. The most popular hyper-reduction technique is the discrete empirical interpolation method (DEIM). The DEIM approximates the nonlinear term with a gappy POD, i.e., it expresses the nonlinear term with a linear combination of the nonlinear term reduced basis, $\\boldsymbol{\\Phi}_{f}\\in\\mathbb{R}^{n\\times f}$: $$\\boldsymbol{f} \\approx \\boldsymbol{\\Phi}_f \\hat{\\boldsymbol{f}},$$ where $\\hat{\\boldsymbol{f}}\\in\\mathbb{R}^{f}$ is a generalized coordinate for the nonlinear term. The usual data for the nonlinear term basis, $\\boldsymbol{\\Phi}_{f}$ is snapshot of nonlinear term itself. Alternatively, it can be replaced by the solution basis (i.e., $\\boldsymbol{\\Phi}$ or slight modification of it) via the SNS method introduced in the following journal paper: Y. Choi, D. Coombs, R. Anderson, SNS: a solution-based nonlinear subspace method for time-dependent model order reduction . SIAM Journal on Scientific Computing , 42(2), A1116\u2013A1146, 2020 Then, we introduce a sampling matrix (in order words, a collocation matrix), $\\boldsymbol{Z}\\in\\mathbb{R}^{n\\times z}$, which selects a subset of the nonliear term, $\\boldsymbol{F}$. That is, each column of $\\boldsymbol{Z}$ is a column of the identity matrix, $\\boldsymbol{I} \\in \\mathbb{R}^{n\\times n}$. Combining the collocation matrix and the nonlinear basis, we solve the following least-squares problem to solve for the generalized coordinate, $\\hat{\\boldsymbol{f}}$: $$\\hat{\\boldsymbol{f}} = \\underset{\\boldsymbol{y}\\in{\\mathbb{R}^{f}}}{\\arg\\min} \\hspace{3pt} || \\boldsymbol{Z}^T\\boldsymbol{f} - \\boldsymbol{Z}^T\\boldsymbol{\\Phi}_f \\boldsymbol{y} ||_2^2$$ The solution to the least-squares problem is known to be $$\\hat{\\boldsymbol{f}} = (\\boldsymbol{Z}^T\\boldsymbol{\\Phi}_{f})^\\dagger \\boldsymbol{Z}^T\\boldsymbol{f}.$$ Note that $(\\boldsymbol{Z}^T\\boldsymbol{\\Phi}_{f})^\\dagger$ can be pre-computed once the indices for $\\boldsymbol{Z}$ and $\\boldsymbol{\\Phi}_f$ are known. Note also that you do not need to construct $\\boldsymbol{Z}$. You only need to sample selected rows of $\\boldsymbol{\\Phi}_f$ and do the pseudo-inversion. This is what we do in libROM. Also note that we only need to evaluate a subset of $\\boldsymbol{f}$ because of $\\boldsymbol{Z}^T$ in front of $\\boldsymbol{f}$. Parametric ROMs Whether it is intrusive or non-intrusive ROM, if the ROM can only reproduce the full order model simulation data with high accuracy, it is useless because the full order model solution is already available. In order for any ROMs to be useful, they must be able to predict the solution which is not generated yet. We call such a ROM parametric because it is able to predict the solution for a new parameter value. Two extreme types of parametric ROMs are global and local ROMs. Global ROMs The global ROMs collect simulation data over several sampled points in a given parameter space and use all of them as a whole, building a global reduced basis. The size of the reduced basis becomes larger as the number of samples increases. Therefore, the global ROM is only effective when a small number of samples are used. Local ROMs A local ROM is built with the simulation data corresponding only to one specific sample. Usually, several local ROMs are built for several sample points and either interpolation or trust-region is used to predict the solution at points which were not sampled. Greedy sampling algorithm The greedy sampling algorithm is a physics-informed sampling strategy to build a parametric ROM . The parametric ROM can be used to predict the solution of a new parameter point that has not been seen in the training phase. The greey algorithms follow the general procedure below: Define a parameter space Pick an initial point in the parameter space to build a ROM there (a good cancidiate initla point is either the centroid or one of end points) Evaluate error indicator of the current ROM (either global or local ROM) at $N$ random points within the parameter space Check if the maximum error indicator value is less than the desirable accuracy threshold If the answer to Step 4 is yes, then terminate the greedy process. If the answer to Step 4 is no, then collect the full order model simulation data at the maximum error indicator point and add them to update the ROM Go to Step 3. The success of the greedy algorithm depends on the error indicator . The error indicator must satisfy the following two criteria: Its value must have positive correlation with the relative error measure The evaluation of the error indicator must be computationally efficient Note that the error indicator plays a role of a proxy for the accuracy of the ROM. The most popular error indicator is residual-based, which we recommend you to use for your physical simulations. The general framework of the greedy algorithm is implemented in libROM. The example of the libROM usage case can be found for the Poisson problem at poisson_greedy.cpp . The corresponding tutorial page can be found here . Several variants of the greedy procedure described above is possible. For more detailed explanation about the greedy algorithm, we refer to the following jounral paper, where the greedy algorithm is described for the interpolated ROM in a matrix manifold: Y. Choi, G. Boncoraglio, S. Anderson, D. Amsallem, C. Farhat, Gradient-based constrained optimization using a database of linear reduced order models . Journal of Computational Physics , 423, 109787, 2020 We recommend another excellent paper for the greedy algorithm: A. Paul-Dubois-Taine, D. Amsallem, An adaptive and efficient greedy procedure for the optimal training of parametric reduced-order models . International Journal for Numerical Methods in Engineering , 102, p1262-1292, 2014 Open Source libROM is an open-source software, and can be freely used under the terms of the MIT and APACHE license.","title":"Features"},{"location":"features.html#features","text":"The goal of libROM is to provide high-performance scalable library for data-driven reduced order modeling.","title":"Features"},{"location":"features.html#proper-orthogonal-decomposition","text":"One of the core features in libROM is the ability to extract important modes from given physical simulation data. The proper othogonal decomposition (POD) is a popular method for compressing physical simulation data to obtain optimal \"reduced\" bases in the following sense: $$\\boldsymbol{\\Phi} =\\underset{\\boldsymbol{A}\\in\\mathbb{R}^{n\\times r}, \\boldsymbol{A}^T\\boldsymbol{A} = \\boldsymbol{I}_{r\\times r} }{\\arg\\min} || \\boldsymbol{U} - \\boldsymbol{A}\\boldsymbol{A}^T\\boldsymbol{U} ||_F^2, $$ where $\\boldsymbol{U}\\in\\mathbb{R}^{n\\times m}$ is simulation data and $\\boldsymbol{I}_{r\\times r} \\in \\mathbb{R}^{r\\times r}$ denotes an identity matrix. That is, the POD tries to find the orthogonal matrix, $\\boldsymbol{\\Phi}$, whose span minimizes the projection error in the Frobenius norm. The POD modes can be obtained in two equivalent ways: (i) eigenvalue decomposition and (ii) singular value decomposition (SVD). We take the latter approach, i.e., let's say the thin SVD of $\\boldsymbol{U}$ is given by $$\\boldsymbol{U} = \\boldsymbol{W\\Sigma V}^T.$$ Then the solution of the POD is given by taking the first $r$ columns of the left singular matrix, i.e., $\\boldsymbol{\\Phi} = [\\boldsymbol{w}_{1},\\ldots ,\\boldsymbol{w}_r]$, where $\\boldsymbol{w}_k$ is $k$th left singular vector, assuming that the singular value is written in the decreasing order.","title":"Proper orthogonal decomposition"},{"location":"features.html#efficient-data-collection","text":"High-fidelity physical simulations generate intensive data in its size, which makes the data collection process daunting. Therefore, the libROM aims to ease the difficulty associated with the intensive data size. The libROM can be directly integrated to the physics solver that generates the intensive simulation data. For example, if the physical simulation is time dependent, then each time step solution data can be feed into the libROM incrementally so that the singular value decomposition is efficiently updated in parallel. This approach is incremental SVD . There are other types of SVDs which exploits efficiency. The libROM provides following four SVDs: Static SVD incremental SVD randomized SVD space-time SVD","title":"Efficient data collection"},{"location":"features.html#static-svd","text":"The static SVD waits the libROM to collect all the simulation data. Once the snapshot matrix $\\boldsymbol{U}$ is formed, then the SVD is performed. Therefore, if the data size is big, this approach is not efficient and not recommended. However, because it gives the most accurate SVD results, it is ideal for a small problem.","title":"Static SVD"},{"location":"features.html#incremental-svd","text":"Unlike the static SVD, the incremental SVD does not wait. Instead, as the data comes in, the SVD is performed right away. Because the incremental SVD only needs to find out the effect of one additional simulation data vector to the previous SVD, the update can be done very efficiently without requiring much memory. Therefore, it is useful for large-scale problems. For the detailed explanation about the incremental SVD, we refer to the following journal papers: M. Brand, Incremental singular value decomposition of uncertain data with missing values , In European Conference on Computer Vision , p707-720, 2002 G. Oxberry, T. Kostova-Vassilevska, W. Arrighi, K. Chand, Limited-memory adaptive snapshot selection for proper orthogonal decomposition , International Journal for Numerical Methods in Engineering , 109(2), p198-217, 2016 H. Fareed, J.R. Singler, Error Analysis of an Incremental Proper Orthogonal Decomposition Algorithm for PDE Simulation Data , Journal of Computational and Applied Mathematics , 368, 112525, 2020","title":"Incremental SVD"},{"location":"features.html#randomized-svd","text":"Randomization can bring computational efficiency in computing SVDs. For example, consider that one needs to extract $p$ dominant modes from $n \\times m$ tall dense matrix, using SVD. The randomized SVD requires $\\mathcal{O}(nm\\log(p))$ floating-point operations, while the static SVD algorithm requires $\\mathcal{O}(nmp)$ flops. The randomized SVD that is implemented in libROM can be found in the following journal paper: N. Halko, P.G. Martinsson, J.A. Tropp, Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions . SIAM review , 53(2), p217-288, 2011","title":"Randomized SVD"},{"location":"features.html#space-time-svd","text":"For time dependent problems, one can reduce not only the spatial degrees of freedom, but also the temporal degrees of freedom by representing the space-time solution as a linear combination of a space-time reduced basis. The space-time reduced basis can be mathematically written as a Kronecker product of temporal and spatial bases. Fortunately, one can extract temporal as well as spatial reduced bases from one single SVD. The procedure is schematically depicted in the figure below: For the detailed explanation about the incremental SVD, we refer to the following three journal papers: Y. Kim, K. Wang, Y. Choi, Efficient space\u2013time reduced order model for linear dynamical systems in Python using less than 120 lines of code . Mathematics , 9(14), 1690, 2021 Y. Choi, P. Brown, W. Arrighi, R. Anderson, K. Huynh, Space\u2013time reduced order model for large-scale linear dynamical systems with application to boltzmann transport problems . Journal of Computational Physics , 424, 109845, 2021 Y. Choi, K. Carlberg, Space-time least-squares Petrov-Galerkin projection for nonlinear model reduction , SIAM Journal on Scientific Computing , 41(1), A26-A58, 2019","title":"Space-time SVD"},{"location":"features.html#dynamic-mode-decomposition","text":"The dynamic mode decomposition (DMD) provides a great way of finding an approximate locally linear dynamical system, $$ \\frac{d\\boldsymbol{u}}{dt} = \\mathcal{A}\\boldsymbol{u},$$ for a given nonlinear dynamical system, $$ \\frac{d\\boldsymbol{u}}{dt} = \\boldsymbol{f}(\\boldsymbol{u},t;\\boldsymbol{\\mu}),$$ with initial condition, $\\boldsymbol{u}_0$. It takes non-intrusive approach, i.e., equation-free method, so it is applicable even if there is only data, but no $\\boldsymbol{f}(\\boldsymbol{u},t;\\boldsymbol{\\mu})$. For example, let's say the discrete-time data are given as: $$\\boldsymbol{U} = [\\boldsymbol{u}_1,\\ldots,\\boldsymbol{u}_m],$$ where $\\boldsymbol{u}_k\\in\\mathbb{R}^n$ denotes solution at $t=k\\Delta t$. The DMD is trying to find the best $\\boldsymbol{A}$ such that $$\\boldsymbol{U}^+ = \\boldsymbol{A}\\boldsymbol{U}^-,$$ where $\\boldsymbol{U}^+ = [\\boldsymbol{u}_2,\\ldots,\\boldsymbol{u}_m]$ and $\\boldsymbol{U}^- = [\\boldsymbol{u}_1, \\ldots, \\boldsymbol{u}_{m-1}]$. The following procedure is taken to find the best $\\boldsymbol{A}$. Take the singular value decomposition (SVD) of $\\boldsymbol{U}^-$ $$\\boldsymbol{U}^- \\approx \\boldsymbol{W}\\boldsymbol{\\Omega}\\boldsymbol{V}^*,$$ where $*$ denotes the conjugate transpose, $\\boldsymbol{W}\\in\\mathbb{C}^{n\\times r}$, $\\boldsymbol{\\Sigma}\\in\\mathbb{C}^{r\\times r}$, $\\boldsymbol{V}\\in\\mathbb{C}^{m\\times r}$, and $r \\leq m$. Because $\\boldsymbol{U}^+ = \\boldsymbol{A}\\boldsymbol{U}^-$, using the pseudo-inverse of the approximate $\\boldsymbol{U}^-$, we have $$\\boldsymbol{A} \\approx \\tilde{\\boldsymbol{A}} = \\boldsymbol{U}^+\\boldsymbol{V}\\boldsymbol{\\Omega}^{-1}\\boldsymbol{W}^*$$ It is easier to deal with the reduced operator $\\tilde{\\boldsymbol{A}}_r$, which relates the discrete-time dynamic of reduced states: $$\\tilde{\\boldsymbol{u}}_{k+1} = \\tilde{\\boldsymbol{A}}_r\\tilde{\\boldsymbol{u}}_k,$$ where $\\boldsymbol{u}_k = \\boldsymbol{W} \\tilde{\\boldsymbol{u}}_k$ and $\\tilde{\\boldsymbol{A}}_r$ is defined as $$\\tilde{\\boldsymbol{A}}_r=\\boldsymbol{W}^*\\tilde{\\boldsymbol{A}}\\boldsymbol{W}$$ $$\\tilde{\\boldsymbol{A}}_r=\\boldsymbol{W}^*\\boldsymbol{U}^+\\boldsymbol{V}\\boldsymbol{\\Omega}^{-1}$$ Let the eigen-decomposition of $\\tilde{\\boldsymbol{A}}_r$ to be $$\\tilde{\\boldsymbol{A}}_r \\boldsymbol{X} = \\boldsymbol{\\Lambda}\\boldsymbol{X}$$ and set $\\boldsymbol{\\Phi} = \\boldsymbol{W}\\boldsymbol{X}$, then the DMD solution at time, $t$, can be found as $$\\boldsymbol{u}(t) = \\boldsymbol{\\Phi}\\boldsymbol{\\Lambda}^{t/\\Delta t} \\boldsymbol{b}_0,$$ where $\\boldsymbol{b}_0 = \\boldsymbol{\\Phi}^\\dagger \\boldsymbol{u}_0$. For the detailed explanation about the DMD, we refer to the following book: J.N. Kutz, S.L. Brunton, B.W. Brunton, J.L. Proctor, Dynamic mode decomposition: data-driven modeling of complex systems . Society for Industrial and Applied Mathematics , 2016","title":"Dynamic Mode Decomposition"},{"location":"features.html#projection-based-reduced-order-model","text":"In contrast to the DMD, the projection-based reduced order model (pROM) takes an intrusive approach, that is, it is NOT equation-free. The pROM first represents the solution as a linear combincation of reduced basis. The reduced basis can be obtained by the POD, for example. Let's denote the reduced basis as $\\boldsymbol{\\Phi}\\in\\mathbb{R}^{n\\times r}$ and express the solution, $\\boldsymbol{u}\\in\\mathbb{R}^n$ as $$\\boldsymbol{u} = \\boldsymbol{u}_{\\text{ref}}+\\boldsymbol{\\Phi}\\hat{\\boldsymbol{u}},$$ where $\\hat{\\boldsymbol{u}} \\in \\mathbb{R}^r$ denotes the generalized coordinates with respect to the reduced basis. Then we substitute $\\boldsymbol{u}$ in the governing equation, say a nonlinear dynamical system governed by the following ordinary differential equations, $$\\frac{d\\boldsymbol{u}}{dt} = \\boldsymbol{f}(\\boldsymbol{u},t;\\boldsymbol{\\mu}),$$ to obtain the over-determined system, i.e., $$\\boldsymbol{\\Phi}\\frac{d\\hat{\\boldsymbol{u}}}{dt} = \\boldsymbol{f}(\\boldsymbol{u}_{\\text{ref}}+\\boldsymbol{\\Phi}\\hat{\\boldsymbol{u}},t;\\boldsymbol{\\mu}),$$ which has more equations than unknowns. Therefore, the system needs to be closed by a projection. Galerkin and Petrov-Galerking projections are popular. For example, the Galerkin projection multiplies both sides by $\\boldsymbol{\\Phi}^T$ and the system of equations become $$\\frac{d\\hat{\\boldsymbol{u}}}{dt} = \\boldsymbol{\\Phi}^T \\boldsymbol{f}(\\boldsymbol{u}_{\\text{ref}}+\\boldsymbol{\\Phi}\\hat{\\boldsymbol{u}},t;\\boldsymbol{\\mu})$$ By the way, the nonlinear term $\\boldsymbol{f}$ still scales with the full order model size and it needs to be updated every time its argument changes due to Newton step updates, for example. The hyper-reduction provides an efficient way of computing nonlinear terms by sampling an important subset. By the way, if $\\boldsymbol{f}$ is linear, then $\\boldsymbol{\\Phi}^T\\boldsymbol{f}$ can be pre-computed, so the hyper-reduction is not necessary.","title":"Projection-based reduced order model"},{"location":"features.html#hyper-reduction","text":"Hyper-reduction is essential to reduce the complexity of nonlinear terms in pROM. The most popular hyper-reduction technique is the discrete empirical interpolation method (DEIM). The DEIM approximates the nonlinear term with a gappy POD, i.e., it expresses the nonlinear term with a linear combination of the nonlinear term reduced basis, $\\boldsymbol{\\Phi}_{f}\\in\\mathbb{R}^{n\\times f}$: $$\\boldsymbol{f} \\approx \\boldsymbol{\\Phi}_f \\hat{\\boldsymbol{f}},$$ where $\\hat{\\boldsymbol{f}}\\in\\mathbb{R}^{f}$ is a generalized coordinate for the nonlinear term. The usual data for the nonlinear term basis, $\\boldsymbol{\\Phi}_{f}$ is snapshot of nonlinear term itself. Alternatively, it can be replaced by the solution basis (i.e., $\\boldsymbol{\\Phi}$ or slight modification of it) via the SNS method introduced in the following journal paper: Y. Choi, D. Coombs, R. Anderson, SNS: a solution-based nonlinear subspace method for time-dependent model order reduction . SIAM Journal on Scientific Computing , 42(2), A1116\u2013A1146, 2020 Then, we introduce a sampling matrix (in order words, a collocation matrix), $\\boldsymbol{Z}\\in\\mathbb{R}^{n\\times z}$, which selects a subset of the nonliear term, $\\boldsymbol{F}$. That is, each column of $\\boldsymbol{Z}$ is a column of the identity matrix, $\\boldsymbol{I} \\in \\mathbb{R}^{n\\times n}$. Combining the collocation matrix and the nonlinear basis, we solve the following least-squares problem to solve for the generalized coordinate, $\\hat{\\boldsymbol{f}}$: $$\\hat{\\boldsymbol{f}} = \\underset{\\boldsymbol{y}\\in{\\mathbb{R}^{f}}}{\\arg\\min} \\hspace{3pt} || \\boldsymbol{Z}^T\\boldsymbol{f} - \\boldsymbol{Z}^T\\boldsymbol{\\Phi}_f \\boldsymbol{y} ||_2^2$$ The solution to the least-squares problem is known to be $$\\hat{\\boldsymbol{f}} = (\\boldsymbol{Z}^T\\boldsymbol{\\Phi}_{f})^\\dagger \\boldsymbol{Z}^T\\boldsymbol{f}.$$ Note that $(\\boldsymbol{Z}^T\\boldsymbol{\\Phi}_{f})^\\dagger$ can be pre-computed once the indices for $\\boldsymbol{Z}$ and $\\boldsymbol{\\Phi}_f$ are known. Note also that you do not need to construct $\\boldsymbol{Z}$. You only need to sample selected rows of $\\boldsymbol{\\Phi}_f$ and do the pseudo-inversion. This is what we do in libROM. Also note that we only need to evaluate a subset of $\\boldsymbol{f}$ because of $\\boldsymbol{Z}^T$ in front of $\\boldsymbol{f}$.","title":"Hyper-reduction"},{"location":"features.html#parametric-roms","text":"Whether it is intrusive or non-intrusive ROM, if the ROM can only reproduce the full order model simulation data with high accuracy, it is useless because the full order model solution is already available. In order for any ROMs to be useful, they must be able to predict the solution which is not generated yet. We call such a ROM parametric because it is able to predict the solution for a new parameter value. Two extreme types of parametric ROMs are global and local ROMs.","title":"Parametric ROMs"},{"location":"features.html#global-roms","text":"The global ROMs collect simulation data over several sampled points in a given parameter space and use all of them as a whole, building a global reduced basis. The size of the reduced basis becomes larger as the number of samples increases. Therefore, the global ROM is only effective when a small number of samples are used.","title":"Global ROMs"},{"location":"features.html#local-roms","text":"A local ROM is built with the simulation data corresponding only to one specific sample. Usually, several local ROMs are built for several sample points and either interpolation or trust-region is used to predict the solution at points which were not sampled.","title":"Local ROMs"},{"location":"features.html#greedy-sampling-algorithm","text":"The greedy sampling algorithm is a physics-informed sampling strategy to build a parametric ROM . The parametric ROM can be used to predict the solution of a new parameter point that has not been seen in the training phase. The greey algorithms follow the general procedure below: Define a parameter space Pick an initial point in the parameter space to build a ROM there (a good cancidiate initla point is either the centroid or one of end points) Evaluate error indicator of the current ROM (either global or local ROM) at $N$ random points within the parameter space Check if the maximum error indicator value is less than the desirable accuracy threshold If the answer to Step 4 is yes, then terminate the greedy process. If the answer to Step 4 is no, then collect the full order model simulation data at the maximum error indicator point and add them to update the ROM Go to Step 3. The success of the greedy algorithm depends on the error indicator . The error indicator must satisfy the following two criteria: Its value must have positive correlation with the relative error measure The evaluation of the error indicator must be computationally efficient Note that the error indicator plays a role of a proxy for the accuracy of the ROM. The most popular error indicator is residual-based, which we recommend you to use for your physical simulations. The general framework of the greedy algorithm is implemented in libROM. The example of the libROM usage case can be found for the Poisson problem at poisson_greedy.cpp . The corresponding tutorial page can be found here . Several variants of the greedy procedure described above is possible. For more detailed explanation about the greedy algorithm, we refer to the following jounral paper, where the greedy algorithm is described for the interpolated ROM in a matrix manifold: Y. Choi, G. Boncoraglio, S. Anderson, D. Amsallem, C. Farhat, Gradient-based constrained optimization using a database of linear reduced order models . Journal of Computational Physics , 423, 109787, 2020 We recommend another excellent paper for the greedy algorithm: A. Paul-Dubois-Taine, D. Amsallem, An adaptive and efficient greedy procedure for the optimal training of parametric reduced-order models . International Journal for Numerical Methods in Engineering , 102, p1262-1292, 2014","title":"Greedy sampling algorithm"},{"location":"features.html#open-source","text":"libROM is an open-source software, and can be freely used under the terms of the MIT and APACHE license.","title":"Open Source"},{"location":"gallery.html","text":"Gallery This page collects screenshots from various ROM simulations based on libROM. Sedov blast simulated with Laghos and accelerated by libROM . Visualization with VisIt . 2D Gresho vortex simulated with Laghos and accelerated by libROM . Visualization with VisIt . 2D Nonlinear diffusion problem simulated with MFEM and accelerated by libROM . Visualization with VisIt . 3D Crooked pipe for nonlinear radiation diffusion problem simulated with BLAST and accelerated by libROM . Visualization with VisIt . 2D Rayleigh-Taylor instability problem simulated with Laghos and accelerated by libROM . Visualization with VisIt . Triple-point problem simulated with Laghos and accelerated by libROM . Visualization with VisIt . An optimal design for the wind turbine blade solved with LiDO and accelerated by libROM . Visualization with VisIt . 3D Boltzmann particle transport problem solved with ARDRA and accelerated by libROM . Visualization with VisIt . 3D Boltzmann particle transport problem solved with ARDRA and accelerated by libROM . Visualization with VisIt . Taylor-Green vortex problem simulated with Laghos and accelerated by libROM . Visualization with VisIt . Stress-constrained optimal L-bracket problem solved by LiDO and accelerated by libROM . Visualization with VisIt . 3D cantilever beam problem solved by LiDO and accelerated by libROM . Visualization with VisIt . 2D vortex shedding cylinder problem solved by SU2 and its reduced basis by libROM below. Click image below for zoomed-in picture. Visualization with ParaView . 2D NACA0012 airfoil problem solved by SU2 and its reduced basis by libROM . Click image above for zoomed-in picture. Visualization with MATLAB .","title":"Gallery"},{"location":"gallery.html#gallery","text":"This page collects screenshots from various ROM simulations based on libROM. Sedov blast simulated with Laghos and accelerated by libROM . Visualization with VisIt . 2D Gresho vortex simulated with Laghos and accelerated by libROM . Visualization with VisIt . 2D Nonlinear diffusion problem simulated with MFEM and accelerated by libROM . Visualization with VisIt . 3D Crooked pipe for nonlinear radiation diffusion problem simulated with BLAST and accelerated by libROM . Visualization with VisIt . 2D Rayleigh-Taylor instability problem simulated with Laghos and accelerated by libROM . Visualization with VisIt . Triple-point problem simulated with Laghos and accelerated by libROM . Visualization with VisIt . An optimal design for the wind turbine blade solved with LiDO and accelerated by libROM . Visualization with VisIt . 3D Boltzmann particle transport problem solved with ARDRA and accelerated by libROM . Visualization with VisIt . 3D Boltzmann particle transport problem solved with ARDRA and accelerated by libROM . Visualization with VisIt . Taylor-Green vortex problem simulated with Laghos and accelerated by libROM . Visualization with VisIt . Stress-constrained optimal L-bracket problem solved by LiDO and accelerated by libROM . Visualization with VisIt . 3D cantilever beam problem solved by LiDO and accelerated by libROM . Visualization with VisIt . 2D vortex shedding cylinder problem solved by SU2 and its reduced basis by libROM below. Click image below for zoomed-in picture. Visualization with ParaView . 2D NACA0012 airfoil problem solved by SU2 and its reduced basis by libROM . Click image above for zoomed-in picture. Visualization with MATLAB .","title":"Gallery"},{"location":"news.html","text":"All News Updates Date Message Oct 1, 2021 Domain decomposition ROM paper is published in CMAME Sep XX, 2021 First version of libROM webpage is launched July 19, 2021 spacetimeROM-Python paper is published in Mathematics Apr 23, 2021 LaghosROM arXiv preprint is available Jan 1, 2021 spacetimeROM paper is published in Journal of Computational Physics","title":"_News"},{"location":"news.html#all-news-updates","text":"Date Message Oct 1, 2021 Domain decomposition ROM paper is published in CMAME Sep XX, 2021 First version of libROM webpage is launched July 19, 2021 spacetimeROM-Python paper is published in Mathematics Apr 23, 2021 LaghosROM arXiv preprint is available Jan 1, 2021 spacetimeROM paper is published in Journal of Computational Physics","title":"All News Updates"},{"location":"poisson.html","text":"MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}}); Poisson equation The main code for this tutorial can be found in poisson.cpp , which accelerates the Poisson problem $$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. The numerical results can be found in Poisson Problem . libROM assumes that you have a physics code, such as MFEM , SU2 , and Laghos . Then, libROM can be integrated into the physics code to build ROM to accelerate physics simulation. For example, see numerical results in Examples and Gallery . This tutorial illustrates how various libROM objects and functions can be used to collect simulation data, build reduced basis, and construct reduced order model operator to accelerate and predict a target physics simulation. The following tutorials are available: Tutorial 1 : offline , Take and write simulation data with libROM. Tutorial 2 : merge , Collect simulation data and build a reduced basis. Tutorial 3 : online , Build a ROM operator, solve the ROM system, and restore the full order state. Building Follow the building page to build the libROM library. You must build it with -m option to build MFEM library together. ~/libROM> ./scripts/compile.sh -m Tutorial 1 This tutorial demonstrates how to collect simulation data with libROM. The important object is BasisGenerator , which collects simulation data and computes reduced basis, using various singular value decomposition ( SVD ) algorithms, e.g., incremental SVD and static SVD . The incremental SVD is useful for time-dependent problems. Because the Poisson problem is a time-independent problem, we will focus on the usage of the static SVD. The definition of BasisGenerator class can be found in BasisGenerator.h . You must include BasisGenerator.h in your physics code where the simulation data is generated. For example, BasisGenerator.h is included in Line 32 of poisson.cpp for Poisson Problem . #include \"BasisGenerator.h\" A BasisGenerator pointer is defined in Line 204 and the pointer is initiated in Line 212 The BasisGenerator requires four inputs to initialize, i.e., Options , boolean variable, string, and Database::formats. The object, Options, sets various options for the BasisGenerator, such as the basis dimension and singular value tolerance. The boolean variable determines if the incremental or static SVD will be used. For this tutorial, we choose the static SVD, so the boolean variable must be false. Finally, the string input specifies the name of the basis file and Database::formats specifies the file format for the basis file. The default format is Database::HDF5. The detailed description for inputs for Options and BasisGenerator can be found in Options.h and BasisGenerator.h . The specific inputs used for the Poisson problem can be found in Lines 197--201 . Now, the instantiated BasisGenerator, i.e., generator , collects the simulation data once it is available. The Poisson problem generates the solution, $X$, in Line 296 and it is collected in the generator in Line 301 . The member function, writeSnapshot simply writes the solution data in the specified HDF5 file. Make sure that the pointers, generator and options , are deleted after done with sampling. This completes the libROM data collection implementation, which corresponds to the offline phase in the Poisson problem . If you execute the following command: poisson -offline -f 1.0 -id 0 then you should see the HDF5 snapshot output file, i.e., basis0_snapshot.000000 . The command line options above include -offline that indicates the offline phase, -f 1.0 sets the frequency variable $\\kappa=1.0$ (see the Poisson problem for the description of the frequency variable), and -id 0 labels the snapshot index. The visualization of the solution can be done either with VisIt or GLVis. For example, the VisIt shows the following solution contour for this specific simulation: Please execute the following commands: poisson -offline -f 1.1 -id 1 poisson -offline -f 1.2 -id 2 whose solution contour corresponds, respectively, to: Tutorial 2 Once the simulation data are collected within libROM basis files, they can be merged to form a reduced basis. This process is called the merge phase . It is implemented in Lines 218--236 . As in Tutorial 1 , the objects, Options and BasisGenerator must be defined (see Lines 220--221 . The generator iterates over the individual HDF5 snapshot file and loads them all (see Lines 222--226 ). The member function endSamples in Line 227 computes the reduced basis. Again make sure to delete the pointers, i.e., generator and options . For exammple, the following command line option runs the merge phase: poisson -merge -ns 3 The command line option, -merge , invokes the merges phase and -ns 3 option indicates that there are three different snapshot files. The merge phase reads the three snapshot files, i.e., basis0_snapshot.000000 , basis1_snapshot.000000 , and basis2_snapshot.000000 , which were generated in Tutorial 1 , and forms a reduced basis and stores it in the HDF5 basis file, i.e., basis.000000 . Tutorial 3 The online phase builds ROM operators, solves the ROM system, and restores the full order states for a new parameter value. This tutorial demonstrates these three different actions for the frequency value, $\\kappa = 1.15$. Lines 311--312 implements the step of reading a basis file. The BasisReader object reads the basis file, using member function, getSpatialBasis , which returns a Matrix object in libROM. The number of rows and columns of the reduced basis can be obtained through the member functions of the Matrix class, i.e., numRows and numColumns , respectively. Line 318 defines a MFEM DenseMatrix that holds the transpose of the reduced basis matrix. This must be understood as the transpose because libROM stores the matrix row-wise. The MFEM matrix is defined to form a reduced system operator, whose process is implemented in Lines 321--332 . Then the reduced system operator is inverted at Line 333 . The reduced right-hand-side is formed by multiplying the reduced basis transpose to the full order model right-hand-side vector, $B$ at Line 327 . Line 338 solves the reduced system of equation. Line 342 restores the corresponding full order state by multipling the reduced solution by the reduced basis. The command line options that executes the online phase described above are poisson -online -f 1.15 where -online option invokes the online phase and -f 1.15 sets the frequency value $\\kappa = 1.15$. This particular example ROM accelerates the physics simulation by $7.5$ and achieves the relative error, $6.4e-4$, with respect to the corresponding full order model solution.","title":"Poisson equation"},{"location":"poisson.html#poisson-equation","text":"The main code for this tutorial can be found in poisson.cpp , which accelerates the Poisson problem $$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. The numerical results can be found in Poisson Problem . libROM assumes that you have a physics code, such as MFEM , SU2 , and Laghos . Then, libROM can be integrated into the physics code to build ROM to accelerate physics simulation. For example, see numerical results in Examples and Gallery . This tutorial illustrates how various libROM objects and functions can be used to collect simulation data, build reduced basis, and construct reduced order model operator to accelerate and predict a target physics simulation. The following tutorials are available: Tutorial 1 : offline , Take and write simulation data with libROM. Tutorial 2 : merge , Collect simulation data and build a reduced basis. Tutorial 3 : online , Build a ROM operator, solve the ROM system, and restore the full order state.","title":"Poisson equation"},{"location":"poisson.html#building","text":"Follow the building page to build the libROM library. You must build it with -m option to build MFEM library together. ~/libROM> ./scripts/compile.sh -m","title":"Building"},{"location":"poisson.html#tutorial-1","text":"This tutorial demonstrates how to collect simulation data with libROM. The important object is BasisGenerator , which collects simulation data and computes reduced basis, using various singular value decomposition ( SVD ) algorithms, e.g., incremental SVD and static SVD . The incremental SVD is useful for time-dependent problems. Because the Poisson problem is a time-independent problem, we will focus on the usage of the static SVD. The definition of BasisGenerator class can be found in BasisGenerator.h . You must include BasisGenerator.h in your physics code where the simulation data is generated. For example, BasisGenerator.h is included in Line 32 of poisson.cpp for Poisson Problem . #include \"BasisGenerator.h\" A BasisGenerator pointer is defined in Line 204 and the pointer is initiated in Line 212 The BasisGenerator requires four inputs to initialize, i.e., Options , boolean variable, string, and Database::formats. The object, Options, sets various options for the BasisGenerator, such as the basis dimension and singular value tolerance. The boolean variable determines if the incremental or static SVD will be used. For this tutorial, we choose the static SVD, so the boolean variable must be false. Finally, the string input specifies the name of the basis file and Database::formats specifies the file format for the basis file. The default format is Database::HDF5. The detailed description for inputs for Options and BasisGenerator can be found in Options.h and BasisGenerator.h . The specific inputs used for the Poisson problem can be found in Lines 197--201 . Now, the instantiated BasisGenerator, i.e., generator , collects the simulation data once it is available. The Poisson problem generates the solution, $X$, in Line 296 and it is collected in the generator in Line 301 . The member function, writeSnapshot simply writes the solution data in the specified HDF5 file. Make sure that the pointers, generator and options , are deleted after done with sampling. This completes the libROM data collection implementation, which corresponds to the offline phase in the Poisson problem . If you execute the following command: poisson -offline -f 1.0 -id 0 then you should see the HDF5 snapshot output file, i.e., basis0_snapshot.000000 . The command line options above include -offline that indicates the offline phase, -f 1.0 sets the frequency variable $\\kappa=1.0$ (see the Poisson problem for the description of the frequency variable), and -id 0 labels the snapshot index. The visualization of the solution can be done either with VisIt or GLVis. For example, the VisIt shows the following solution contour for this specific simulation: Please execute the following commands: poisson -offline -f 1.1 -id 1 poisson -offline -f 1.2 -id 2 whose solution contour corresponds, respectively, to:","title":"Tutorial 1"},{"location":"poisson.html#tutorial-2","text":"Once the simulation data are collected within libROM basis files, they can be merged to form a reduced basis. This process is called the merge phase . It is implemented in Lines 218--236 . As in Tutorial 1 , the objects, Options and BasisGenerator must be defined (see Lines 220--221 . The generator iterates over the individual HDF5 snapshot file and loads them all (see Lines 222--226 ). The member function endSamples in Line 227 computes the reduced basis. Again make sure to delete the pointers, i.e., generator and options . For exammple, the following command line option runs the merge phase: poisson -merge -ns 3 The command line option, -merge , invokes the merges phase and -ns 3 option indicates that there are three different snapshot files. The merge phase reads the three snapshot files, i.e., basis0_snapshot.000000 , basis1_snapshot.000000 , and basis2_snapshot.000000 , which were generated in Tutorial 1 , and forms a reduced basis and stores it in the HDF5 basis file, i.e., basis.000000 .","title":"Tutorial 2"},{"location":"poisson.html#tutorial-3","text":"The online phase builds ROM operators, solves the ROM system, and restores the full order states for a new parameter value. This tutorial demonstrates these three different actions for the frequency value, $\\kappa = 1.15$. Lines 311--312 implements the step of reading a basis file. The BasisReader object reads the basis file, using member function, getSpatialBasis , which returns a Matrix object in libROM. The number of rows and columns of the reduced basis can be obtained through the member functions of the Matrix class, i.e., numRows and numColumns , respectively. Line 318 defines a MFEM DenseMatrix that holds the transpose of the reduced basis matrix. This must be understood as the transpose because libROM stores the matrix row-wise. The MFEM matrix is defined to form a reduced system operator, whose process is implemented in Lines 321--332 . Then the reduced system operator is inverted at Line 333 . The reduced right-hand-side is formed by multiplying the reduced basis transpose to the full order model right-hand-side vector, $B$ at Line 327 . Line 338 solves the reduced system of equation. Line 342 restores the corresponding full order state by multipling the reduced solution by the reduced basis. The command line options that executes the online phase described above are poisson -online -f 1.15 where -online option invokes the online phase and -f 1.15 sets the frequency value $\\kappa = 1.15$. This particular example ROM accelerates the physics simulation by $7.5$ and achieves the relative error, $6.4e-4$, with respect to the corresponding full order model solution.","title":"Tutorial 3"},{"location":"poisson_greedy.html","text":"MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}}); Greedy for Poisson equation The main code for this tutorial can be found at poisson_greedy.cpp , which demonstrates how to use libROM to execute greedy procedure for the ROM of the Poisson problem introduced in the Poisson equation tutorial . For the recap, the general procedure of the greedy algorithm follows: Define a parameter space Pick an initial point in the parameter space to build a ROM there (a good cancidiate initla point is either the centroid or one of end points) Evaluate error indicator of the current ROM (either global or local ROM) at $N$ random points within the parameter space Check if the maximum error indicator value is less than the desirable accuracy threshold If the answer to Step 4 is yes, then terminate the greedy process. If the answer to Step 4 is no, then collect the full order model simulation data at the maximum error indicator point and add them to update the ROM Go to Step 3. As in the Poisson equation tutorial , we choose to vary the frequency $\\kappa$ as parameter. First, we define the parameter space to be from $0.5$ to $3$, which is larger than the one used in Poisson equation tutorial . You can try the following command line options to run the greedy procedure: ./poisson_greedy -build_database -greedy-param-min 0.5 -greedy-param-max 3 -greedy-param-size 40 -greedysubsize 10 -greedyconvsize 20 -greedyrelerrortol 0.01 The lower and upper bounds of the parameter are determined by the options, -greedy-param-min and -greedy-param-max , respectively. The option -greedy-param-size specifies the total number of random sample points within the parameter space for the whole greedy procedure. The option -greedysubsize sets the number of sub-sample points, where the error indicator is evaluated at every greedy iterations. The option -greedyconvsize sets the number of convergence-sample points on which the error indicator is checked and the termination of the greedy algorithm is determined if the error indicators are below the convergence threshold after the error indicator tests on the sub-sample points have been passed. Finally, -greedyrelerrortol sets the desirable relative error for the greedy algorithm to achieve. The core class of the libROM for the greedy procedure is GreedyParameterPointSampler , which is defined here in poisson_greedy.cpp . The GreedyParameterPointSampler generates sampling points within a given parameter space. The class has two sub-classes, i.e., GreedyParameterPointPreDefinedSampler and GreedyParameterPointRandomSampler . The GreedyParameterPointPreDefinedSampler generates pre-defined sampling points, e.g., a tensor product sampling points, while the GreedyParameterPointRandomSampler generates random sampling points, e.g., Latin hyper-cube sampling points. The GreedyParameterPointSampler also does book-keeping job of at which sampling point to evaluate the error indicator, when to move onto the next greedy step, and which sampling point has the maximum error indicator value. Just to be clear, the libROM does not do everything for you. For example, the error indicator must be defined in the physics solver. For the Poisson example, the residual-based error indicator is defined at Lines 519-527 . Once the greedy procedure completes, the log file, called poisson_greedy_algorithm_log.txt , is generated to show the progress of the greedy procedure and the final parameter points on which the global ROM was built. For example, you will see the following block at the end of the file, indicating the final parameter points on which the global ROM is built. Sampled Parameter Points [ 0.591166 ] [ 0.844964 ] [ 1.066678 ] [ 1.353370 ] [ 1.710334 ] [ 1.992794 ] [ 2.568171 ] [ 2.985638 ] Because we set the -greedyrelerrortol to be 0.01, the global ROM built through the greedy procedure must be able to predict a solution with a relative error less than 1$\\%$ for any points in the parameter space. Indeed, let's try to predict the solution at $\\kappa = 2.2$, which was not one of the final parameter points. Let's first generate the full order model solution with the following command line option: ./poisson_greedy -offline -f 2.2 This full order model solution will be used to compute the relative error for the ROM solution. The ROM solution can be obtained by the following command line option: ./poisson_greedy -use_database -online -f 2.2 Indeed, the relative error of 0.00167671 is achieved","title":"Greedy for Poisson"},{"location":"poisson_greedy.html#greedy-for-poisson-equation","text":"The main code for this tutorial can be found at poisson_greedy.cpp , which demonstrates how to use libROM to execute greedy procedure for the ROM of the Poisson problem introduced in the Poisson equation tutorial . For the recap, the general procedure of the greedy algorithm follows: Define a parameter space Pick an initial point in the parameter space to build a ROM there (a good cancidiate initla point is either the centroid or one of end points) Evaluate error indicator of the current ROM (either global or local ROM) at $N$ random points within the parameter space Check if the maximum error indicator value is less than the desirable accuracy threshold If the answer to Step 4 is yes, then terminate the greedy process. If the answer to Step 4 is no, then collect the full order model simulation data at the maximum error indicator point and add them to update the ROM Go to Step 3. As in the Poisson equation tutorial , we choose to vary the frequency $\\kappa$ as parameter. First, we define the parameter space to be from $0.5$ to $3$, which is larger than the one used in Poisson equation tutorial . You can try the following command line options to run the greedy procedure: ./poisson_greedy -build_database -greedy-param-min 0.5 -greedy-param-max 3 -greedy-param-size 40 -greedysubsize 10 -greedyconvsize 20 -greedyrelerrortol 0.01 The lower and upper bounds of the parameter are determined by the options, -greedy-param-min and -greedy-param-max , respectively. The option -greedy-param-size specifies the total number of random sample points within the parameter space for the whole greedy procedure. The option -greedysubsize sets the number of sub-sample points, where the error indicator is evaluated at every greedy iterations. The option -greedyconvsize sets the number of convergence-sample points on which the error indicator is checked and the termination of the greedy algorithm is determined if the error indicators are below the convergence threshold after the error indicator tests on the sub-sample points have been passed. Finally, -greedyrelerrortol sets the desirable relative error for the greedy algorithm to achieve. The core class of the libROM for the greedy procedure is GreedyParameterPointSampler , which is defined here in poisson_greedy.cpp . The GreedyParameterPointSampler generates sampling points within a given parameter space. The class has two sub-classes, i.e., GreedyParameterPointPreDefinedSampler and GreedyParameterPointRandomSampler . The GreedyParameterPointPreDefinedSampler generates pre-defined sampling points, e.g., a tensor product sampling points, while the GreedyParameterPointRandomSampler generates random sampling points, e.g., Latin hyper-cube sampling points. The GreedyParameterPointSampler also does book-keeping job of at which sampling point to evaluate the error indicator, when to move onto the next greedy step, and which sampling point has the maximum error indicator value. Just to be clear, the libROM does not do everything for you. For example, the error indicator must be defined in the physics solver. For the Poisson example, the residual-based error indicator is defined at Lines 519-527 . Once the greedy procedure completes, the log file, called poisson_greedy_algorithm_log.txt , is generated to show the progress of the greedy procedure and the final parameter points on which the global ROM was built. For example, you will see the following block at the end of the file, indicating the final parameter points on which the global ROM is built. Sampled Parameter Points [ 0.591166 ] [ 0.844964 ] [ 1.066678 ] [ 1.353370 ] [ 1.710334 ] [ 1.992794 ] [ 2.568171 ] [ 2.985638 ] Because we set the -greedyrelerrortol to be 0.01, the global ROM built through the greedy procedure must be able to predict a solution with a relative error less than 1$\\%$ for any points in the parameter space. Indeed, let's try to predict the solution at $\\kappa = 2.2$, which was not one of the final parameter points. Let's first generate the full order model solution with the following command line option: ./poisson_greedy -offline -f 2.2 This full order model solution will be used to compute the relative error for the ROM solution. The ROM solution can be obtained by the following command line option: ./poisson_greedy -use_database -online -f 2.2 Indeed, the relative error of 0.00167671 is achieved","title":"Greedy for Poisson equation"},{"location":"publications.html","text":"Publications 2021 Y. Kim, Y. Choi, D. Widemann, T. Zohdi, A fast and accurate physics-informed neural network reduced order model with shallow masked autoencoder accepted for publication at Journal of Computational Physics , arXiv:2009.11990, 2021 D. Copeland, S.W. Cheung, K. Huynh, Y. Choi, Reduced order models for Lagrangian hydrodynamics , Computer Methods in Applied Mechanics and Engineering , Volume 388, 114259, 2021 C. Hoang, Y. Choi, K. Carlberg, Domain-decomposition least-squares Petrov-Galerkin (DD-LSPG) nonlinear model reduction , Computer Methods in Applied Mechanics and Engineering , Volume 384, 113997, 2021 S. McBane, Y. Choi, Component-wise reduced order model lattice-type structure design , Computer Methods in Applied Mechanics and Engineering , 381, 113813, 2021 . Y. Kim, K.M. Wang, Y. Choi, Efficient space-time reduced order model for linear dynamical systems in Python using less than 120 lines of code , Mathematics , 9(14), 1690, 2021 Y. Choi, P. Brown, W. Arrighi, R. Anderson, K. Huynh, Space-time reduced order model for large-scale linear dynamical systems with application to Boltzmann transport problems , Journal of Computational Physics , 424, 109845, 2021 . Also available as arXiv:1910.01260 . 2020 Y. Choi, D. Coombs, R. Anderson, SNS: A Solution-based nonlinear subspace method for time-dependent model order reduction , SIAM Journal on Scientific Computing , 42(2), A1116-A1147, 2020 Y. Choi, G. Boncoraglio, S. Anderson, D. Amsallem, C. Farhat Gradient-based constrained optimization using a database of linear reduced order models , Journal of Computational Physics , 423, 109787, 2020 . Also available as arXiv:1506.07849 . Y. Kim, Y. Choi, D. Widemann, T. Zohdi, Efficient nonlinear manifold reduced order model Workshop on machine learning for engineering modeling, simulation and design @ NeurIPS 2020 , 2020 . Also available as arXiv:2011.07727 2019 and earlier Y. Choi, K. Carlberg, Space-time least-squares Petrov-Galerkin projection for nonlinear model reduction , SIAM Journal on Scientific Computing , 41(1), A26-A58, 2019 Y. Choi, G. Oxberry, D. Whit, T. Kirchdoerfer, Accelerating design optimization using reduced order models , arXiv preprint , arXiv:1909.11320, 2019 K. Carlberg, Y. Choi, S. Sargsyan, Conservative model reduction for finite-volume models , Journal of Computational Physics , 371, p280-314, 2018 G. Oxberry, T. Kostova-Vassilevska, W. Arrighi, K. Chand, Limited-memory adaptive snapshot selection for proper orthogonal decomposition , International Journal of Numerical Methods in Engineering , 109(2), p198-217, 2016 D. Amsallem, M. Zahr, Y. Choi, C. Farhat, Design optimization using hyper-reduced-order models , Structural and Multidisciplinary Optimization , 51, p919-940, 2015 MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"Publications"},{"location":"publications.html#publications","text":"","title":"Publications"},{"location":"publications.html#2021","text":"Y. Kim, Y. Choi, D. Widemann, T. Zohdi, A fast and accurate physics-informed neural network reduced order model with shallow masked autoencoder accepted for publication at Journal of Computational Physics , arXiv:2009.11990, 2021 D. Copeland, S.W. Cheung, K. Huynh, Y. Choi, Reduced order models for Lagrangian hydrodynamics , Computer Methods in Applied Mechanics and Engineering , Volume 388, 114259, 2021 C. Hoang, Y. Choi, K. Carlberg, Domain-decomposition least-squares Petrov-Galerkin (DD-LSPG) nonlinear model reduction , Computer Methods in Applied Mechanics and Engineering , Volume 384, 113997, 2021 S. McBane, Y. Choi, Component-wise reduced order model lattice-type structure design , Computer Methods in Applied Mechanics and Engineering , 381, 113813, 2021 . Y. Kim, K.M. Wang, Y. Choi, Efficient space-time reduced order model for linear dynamical systems in Python using less than 120 lines of code , Mathematics , 9(14), 1690, 2021 Y. Choi, P. Brown, W. Arrighi, R. Anderson, K. Huynh, Space-time reduced order model for large-scale linear dynamical systems with application to Boltzmann transport problems , Journal of Computational Physics , 424, 109845, 2021 . Also available as arXiv:1910.01260 .","title":"2021"},{"location":"publications.html#2020","text":"Y. Choi, D. Coombs, R. Anderson, SNS: A Solution-based nonlinear subspace method for time-dependent model order reduction , SIAM Journal on Scientific Computing , 42(2), A1116-A1147, 2020 Y. Choi, G. Boncoraglio, S. Anderson, D. Amsallem, C. Farhat Gradient-based constrained optimization using a database of linear reduced order models , Journal of Computational Physics , 423, 109787, 2020 . Also available as arXiv:1506.07849 . Y. Kim, Y. Choi, D. Widemann, T. Zohdi, Efficient nonlinear manifold reduced order model Workshop on machine learning for engineering modeling, simulation and design @ NeurIPS 2020 , 2020 . Also available as arXiv:2011.07727","title":"2020"},{"location":"publications.html#2019-and-earlier","text":"Y. Choi, K. Carlberg, Space-time least-squares Petrov-Galerkin projection for nonlinear model reduction , SIAM Journal on Scientific Computing , 41(1), A26-A58, 2019 Y. Choi, G. Oxberry, D. Whit, T. Kirchdoerfer, Accelerating design optimization using reduced order models , arXiv preprint , arXiv:1909.11320, 2019 K. Carlberg, Y. Choi, S. Sargsyan, Conservative model reduction for finite-volume models , Journal of Computational Physics , 371, p280-314, 2018 G. Oxberry, T. Kostova-Vassilevska, W. Arrighi, K. Chand, Limited-memory adaptive snapshot selection for proper orthogonal decomposition , International Journal of Numerical Methods in Engineering , 109(2), p198-217, 2016 D. Amsallem, M. Zahr, Y. Choi, C. Farhat, Design optimization using hyper-reduced-order models , Structural and Multidisciplinary Optimization , 51, p919-940, 2015 MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});","title":"2019 and earlier"},{"location":"rom.html","text":"Projection-based Reduced Order Model The reduced order models are achieved by applying data-driven model order reduction techniques to high-fidelity physics models, typically represented by partial differential equations (PDEs). There is a large body of literature on reduced order models, including the following excellent books: Certified reduced basis methods for parametrized partial differential equations by Jan S. Hesthaven and Gianluigi Rozza and Benjamin Stamm Model reduction of parametrized systems by Peter Benner and Mario Ohlberger and Anthony T. Patera and Gianluigi Rozza and Karsten Urban Reduced-order modeling (ROM) for simulation and optimization by Winfried Keiper and Anja Milde and Stefan Volkwein Approximation of large-scale dynamical systems by Athanasios C. Antoulas Machine learning, low-rank approximations and reduced order modeling in computational mechanics by Felix Fritzen and David Ryckelynck Machine learning for model order reduction by Khaled Salah Mohamed Reduced order methods for modeling and computational reduction by Alfio Quarteroni and Gianluigi Rozza The successful reduced order model development depends on many factors: Good quality and quantity of data Optimal and scalable data reduction schemes Optimal projection methods Efficient hyper-reduction for nonlinear reduction Sampling algorithms The libROM is designed to provide useful and scalable identify the low-rank approximation be lightweight, general and highly scalable reduced order model toolkit that provides the building blocks for developing finite element algorithms in a manner similar to that of MATLAB for linear algebra methods. The success measure for a reduced order model: speed-up accuracy differentiability verifiability predictability Some of the C++ classes for the finite element realizations of these PDE-level concepts in libROM are described below.","title":"Projection-based Reduced Order Model"},{"location":"rom.html#projection-based-reduced-order-model","text":"The reduced order models are achieved by applying data-driven model order reduction techniques to high-fidelity physics models, typically represented by partial differential equations (PDEs). There is a large body of literature on reduced order models, including the following excellent books: Certified reduced basis methods for parametrized partial differential equations by Jan S. Hesthaven and Gianluigi Rozza and Benjamin Stamm Model reduction of parametrized systems by Peter Benner and Mario Ohlberger and Anthony T. Patera and Gianluigi Rozza and Karsten Urban Reduced-order modeling (ROM) for simulation and optimization by Winfried Keiper and Anja Milde and Stefan Volkwein Approximation of large-scale dynamical systems by Athanasios C. Antoulas Machine learning, low-rank approximations and reduced order modeling in computational mechanics by Felix Fritzen and David Ryckelynck Machine learning for model order reduction by Khaled Salah Mohamed Reduced order methods for modeling and computational reduction by Alfio Quarteroni and Gianluigi Rozza The successful reduced order model development depends on many factors: Good quality and quantity of data Optimal and scalable data reduction schemes Optimal projection methods Efficient hyper-reduction for nonlinear reduction Sampling algorithms The libROM is designed to provide useful and scalable identify the low-rank approximation be lightweight, general and highly scalable reduced order model toolkit that provides the building blocks for developing finite element algorithms in a manner similar to that of MATLAB for linear algebra methods. The success measure for a reduced order model: speed-up accuracy differentiability verifiability predictability Some of the C++ classes for the finite element realizations of these PDE-level concepts in libROM are described below.","title":"Projection-based Reduced Order Model"}]}